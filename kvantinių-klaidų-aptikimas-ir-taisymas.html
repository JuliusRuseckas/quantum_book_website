<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija</title>
  <meta name="description" content="9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija" />
  <meta name="generator" content="bookdown 0.30 and GitBook 2.6.7" />

  <meta property="og:title" content="9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija" />
  <meta name="github-repo" content="JuliusRuseckas/quantum_book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija" />
  
  <meta name="twitter:description" content="9 skyrius. Kvantinių klaidų aptikimas ir taisymas | Kvantinė kompiuterija" />
  

<meta name="author" content="Tadas Paulauskas" />
<meta name="author" content="Julius Ruseckas" />


<meta name="date" content="2022-11-27" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="sistemu-modeliavimas-ir-qml.html"/>
<link rel="next" href="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Kvantinė kompiuterija</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Pratarmė</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#kaip-skaityti-šią-knygą"><i class="fa fa-check"></i>Kaip skaityti šią knygą</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#padėka"><i class="fa fa-check"></i>Padėka</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#apie-autorius"><i class="fa fa-check"></i>Apie autorius</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#prisidėti-prie-knygos"><i class="fa fa-check"></i>Prisidėti prie knygos</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#licencija"><i class="fa fa-check"></i>Licencija</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html"><i class="fa fa-check"></i><b>1</b> Kvantinės kompiuterijos apžvalga</a>
<ul>
<li class="chapter" data-level="1.1" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#įvadas"><i class="fa fa-check"></i><b>1.1</b> Įvadas</a></li>
<li class="chapter" data-level="1.2" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinės-kompiuterijos-pradmenys"><i class="fa fa-check"></i><b>1.2</b> Kvantinės kompiuterijos pradmenys</a></li>
<li class="chapter" data-level="1.3" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#tiuringo-mašina"><i class="fa fa-check"></i><b>1.3</b> Tiuringo mašina</a></li>
<li class="chapter" data-level="1.4" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#skaičiavimų-ištekliai"><i class="fa fa-check"></i><b>1.4</b> Skaičiavimų ištekliai</a></li>
<li class="chapter" data-level="1.5" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantiniai-bitai"><i class="fa fa-check"></i><b>1.5</b> Kvantiniai bitai</a></li>
<li class="chapter" data-level="1.6" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinės-informacijos-apdorojimas"><i class="fa fa-check"></i><b>1.6</b> Kvantinės informacijos apdorojimas</a></li>
<li class="chapter" data-level="1.7" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#skaičiavimo-procesas"><i class="fa fa-check"></i><b>1.7</b> Skaičiavimo procesas</a></li>
<li class="chapter" data-level="1.8" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinių-kompiuterių-charakteristikų-palyginimas"><i class="fa fa-check"></i><b>1.8</b> Kvantinių kompiuterių charakteristikų palyginimas</a></li>
<li class="chapter" data-level="1.9" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#dekoherencija-poskyris"><i class="fa fa-check"></i><b>1.9</b> Dekoherencijos trukmė ir loginių vartų tikslumas</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html"><i class="fa fa-check"></i><b>2</b> Matematinių įrankių rinkinys</a>
<ul>
<li class="chapter" data-level="2.1" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tiesinė-algebra"><i class="fa fa-check"></i><b>2.1</b> Tiesinė algebra</a></li>
<li class="chapter" data-level="2.2" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#kompleksiniai-skaičiai"><i class="fa fa-check"></i><b>2.2</b> Kompleksiniai skaičiai</a></li>
<li class="chapter" data-level="2.3" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#vidinė-vektorių-sandauga"><i class="fa fa-check"></i><b>2.3</b> Vidinė vektorių sandauga</a></li>
<li class="chapter" data-level="2.4" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#kubito-reprezentacija-blocho-sferoje"><i class="fa fa-check"></i><b>2.4</b> Kubito reprezentacija Blocho sferoje</a></li>
<li class="chapter" data-level="2.5" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tiesiniai-operatoriai-ir-matricos"><i class="fa fa-check"></i><b>2.5</b> Tiesiniai operatoriai ir matricos</a></li>
<li class="chapter" data-level="2.6" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#unitariniai-ir-ermitiniai-operatoriai"><i class="fa fa-check"></i><b>2.6</b> Unitariniai ir ermitiniai operatoriai</a></li>
<li class="chapter" data-level="2.7" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#diadinė-operatorių-dekompozicija"><i class="fa fa-check"></i><b>2.7</b> Diadinė operatorių dekompozicija</a></li>
<li class="chapter" data-level="2.8" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#matricos-pėdsakas"><i class="fa fa-check"></i><b>2.8</b> Matricos pėdsakas</a></li>
<li class="chapter" data-level="2.9" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tenzorinė-vektorių-sandauga"><i class="fa fa-check"></i><b>2.9</b> Tenzorinė vektorių sandauga</a></li>
<li class="chapter" data-level="2.10" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tenzorinė-operatorių-sandauga"><i class="fa fa-check"></i><b>2.10</b> Tenzorinė operatorių sandauga</a></li>
<li class="chapter" data-level="2.11" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#operatorių-funkcijos"><i class="fa fa-check"></i><b>2.11</b> Operatorių funkcijos</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html"><i class="fa fa-check"></i><b>3</b> Kvantinės mechanikos pagrindai</a>
<ul>
<li class="chapter" data-level="3.1" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#kvantinės-mechanikos-postulatai"><i class="fa fa-check"></i><b>3.1</b> Kvantinės mechanikos postulatai</a></li>
<li class="chapter" data-level="3.2" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#kvantinis-supynimas"><i class="fa fa-check"></i><b>3.2</b> Kvantinis supynimas</a></li>
<li class="chapter" data-level="3.3" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#tankio-operatorius"><i class="fa fa-check"></i><b>3.3</b> Tankio operatorius</a></li>
<li class="chapter" data-level="3.4" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#epr-paradoksas"><i class="fa fa-check"></i><b>3.4</b> EPR paradoksas</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html"><i class="fa fa-check"></i><b>4</b> Kvantiniai loginiai vartai ir grandinės</a>
<ul>
<li class="chapter" data-level="4.1" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#vieno-kubito-vartai"><i class="fa fa-check"></i><b>4.1</b> Vieno kubito loginiai vartai</a></li>
<li class="chapter" data-level="4.2" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#kvantinių-grandinių-lygybės-ir-atvirkštiniai-loginiai-vartai"><i class="fa fa-check"></i><b>4.2</b> Kvantinių grandinių lygybės ir atvirkštiniai loginiai vartai</a></li>
<li class="chapter" data-level="4.3" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#kubitų-būsenų-matavimas"><i class="fa fa-check"></i><b>4.3</b> Kubitų būsenų matavimas</a></li>
<li class="chapter" data-level="4.4" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#dviejų-kubitų-loginiai-vartai-cnot"><i class="fa fa-check"></i><b>4.4</b> Dviejų kubitų loginiai vartai <em>CNOT</em></a></li>
<li class="chapter" data-level="4.5" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#tofoli-loginiai-vartai"><i class="fa fa-check"></i><b>4.5</b> Tofoli loginiai vartai</a></li>
<li class="chapter" data-level="4.6" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#swap-ir-fredkin-loginiai-vartai"><i class="fa fa-check"></i><b>4.6</b> SWAP ir Fredkin loginiai vartai</a></li>
<li class="chapter" data-level="4.7" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#bendro-tipo-salyginiai-vartai"><i class="fa fa-check"></i><b>4.7</b> Bendro tipo sąlyginiai loginiai vartai <span class="math inline">\(\boldsymbol{cU}\)</span></a></li>
<li class="chapter" data-level="4.8" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#bendro-tipo-būsenų-matavimai"><i class="fa fa-check"></i><b>4.8</b> Bendro tipo būsenų matavimai</a></li>
<li class="chapter" data-level="4.9" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#universalių-loginių-vartų-rinkinys"><i class="fa fa-check"></i><b>4.9</b> Universalių loginių vartų rinkinys</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html"><i class="fa fa-check"></i><b>5</b> Kvantinė informacija ir ryšiai</a>
<ul>
<li class="chapter" data-level="5.1" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinės-informacijos-kopijavimas"><i class="fa fa-check"></i><b>5.1</b> Kvantinės informacijos kopijavimas</a></li>
<li class="chapter" data-level="5.2" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinė-teleportacija"><i class="fa fa-check"></i><b>5.2</b> Kvantinė teleportacija</a></li>
<li class="chapter" data-level="5.3" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinio-supynimo-sukeitimas"><i class="fa fa-check"></i><b>5.3</b> Kvantinio supynimo sukeitimas</a></li>
<li class="chapter" data-level="5.4" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinė-kriptografija"><i class="fa fa-check"></i><b>5.4</b> Kvantinė kriptografija</a>
<ul>
<li class="chapter" data-level="5.4.1" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#bb84-kvantinis-rakto-pasidalijimo-protokolas"><i class="fa fa-check"></i><b>5.4.1</b> BB84 kvantinis rakto pasidalijimo protokolas</a></li>
<li class="chapter" data-level="5.4.2" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#epr-kvantinis-rakto-pasidalijimo-protokolas"><i class="fa fa-check"></i><b>5.4.2</b> EPR kvantinis rakto pasidalijimo protokolas</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#lokalios-operacijos-ir-klasikiniai-ryšiai"><i class="fa fa-check"></i><b>5.5</b> Lokalios operacijos ir klasikiniai ryšiai</a></li>
<li class="chapter" data-level="5.6" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#belo-nelygybės-testas"><i class="fa fa-check"></i><b>5.6</b> Belo nelygybės testas</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html"><i class="fa fa-check"></i><b>6</b> Skaičiavimai kvantiniu kompiuteriu</a>
<ul>
<li class="chapter" data-level="6.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#bazinių-vektorių-numeracija"><i class="fa fa-check"></i><b>6.1</b> Bazinių vektorių numeracija</a></li>
<li class="chapter" data-level="6.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#funkcinis-skaičiavimas"><i class="fa fa-check"></i><b>6.2</b> Funkcinis skaičiavimas</a></li>
<li class="chapter" data-level="6.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#kvantinis-paralelizmas"><i class="fa fa-check"></i><b>6.3</b> Kvantinis paralelizmas</a></li>
<li class="chapter" data-level="6.4" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#duomenų-kodavimo-būdai"><i class="fa fa-check"></i><b>6.4</b> Duomenų kodavimo būdai</a></li>
<li class="chapter" data-level="6.5" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#doičo-algoritmas"><i class="fa fa-check"></i><b>6.5</b> Doičo algoritmas</a></li>
<li class="chapter" data-level="6.6" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#kvantinė-paieška-ir-groverio-algoritmas"><i class="fa fa-check"></i><b>6.6</b> Kvantinė paieška ir Groverio algoritmas</a>
<ul>
<li class="chapter" data-level="6.6.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#algebrinė-interpretacija"><i class="fa fa-check"></i><b>6.6.1</b> Algebrinė interpretacija</a></li>
<li class="chapter" data-level="6.6.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#geometrinė-interpretacija"><i class="fa fa-check"></i><b>6.6.2</b> Geometrinė interpretacija</a></li>
<li class="chapter" data-level="6.6.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#groverio-paieška-su-n-8"><i class="fa fa-check"></i><b>6.6.3</b> Groverio paieška su <span class="math inline">\(N = 8\)</span></a></li>
</ul></li>
<li class="chapter" data-level="6.7" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamardo-swap-testai"><i class="fa fa-check"></i><b>6.7</b> Hadamardo ir SWAP testai</a>
<ul>
<li class="chapter" data-level="6.7.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamard-testas-poskyris"><i class="fa fa-check"></i><b>6.7.1</b> Hadamardo testas</a></li>
<li class="chapter" data-level="6.7.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#modifikuotas-hadamardo-testas"><i class="fa fa-check"></i><b>6.7.2</b> Modifikuotas Hadamardo testas</a></li>
<li class="chapter" data-level="6.7.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#swap-testas"><i class="fa fa-check"></i><b>6.7.3</b> SWAP testas</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html"><i class="fa fa-check"></i><b>7</b> Furjė transformacija ir jos taikymai</a>
<ul>
<li class="chapter" data-level="7.1" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#kvantinė-furjė-transformacija"><i class="fa fa-check"></i><b>7.1</b> Kvantinė Furjė transformacija</a></li>
<li class="chapter" data-level="7.2" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#furjė-transformacijos-realizavimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>7.2</b> Furjė transformacijos realizavimas kvantinėje grandinėje</a></li>
<li class="chapter" data-level="7.3" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#funkcijos-periodiškumo-paieška"><i class="fa fa-check"></i><b>7.3</b> Funkcijos periodiškumo paieška</a></li>
<li class="chapter" data-level="7.4" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#kvantinis-fazes-nustatymas"><i class="fa fa-check"></i><b>7.4</b> Kvantinis fazės nustatymo algoritmas</a></li>
<li class="chapter" data-level="7.5" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#tiesinių-lygčių-sprendimas-hhl-algoritmu"><i class="fa fa-check"></i><b>7.5</b> Tiesinių lygčių sprendimas HHL algoritmu</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html"><i class="fa fa-check"></i><b>8</b> Kvantinių sistemų modeliavimas ir mašininis mokymasis</a>
<ul>
<li class="chapter" data-level="8.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#dinaminių-sistemų-modeliavimas"><i class="fa fa-check"></i><b>8.1</b> Dinaminių sistemų modeliavimas</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#ising-hamiltonian-coding"><i class="fa fa-check"></i><b>8.1.1</b> Aizingo modelis ir hamiltoniano kodavimas</a></li>
<li class="chapter" data-level="8.1.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#troterizacija"><i class="fa fa-check"></i><b>8.1.2</b> Troterizacija</a></li>
<li class="chapter" data-level="8.1.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#aizingo-modelio-realizavimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>8.1.3</b> Aizingo modelio realizavimas kvantinėje grandinėje</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#erdvinės-šriodingerio-lygties-sprendimo-algoritmas"><i class="fa fa-check"></i><b>8.2</b> Erdvinės Šriodingerio lygties sprendimo algoritmas</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#banginė-funkcija"><i class="fa fa-check"></i><b>8.2.1</b> Banginė funkcija</a></li>
<li class="chapter" data-level="8.2.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#diskretizavimas"><i class="fa fa-check"></i><b>8.2.2</b> Diskretizavimas</a></li>
<li class="chapter" data-level="8.2.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#perteikimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>8.2.3</b> Perteikimas kvantinėje grandinėje</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3</b> Mašininis mokymasis</a>
<ul>
<li class="chapter" data-level="8.3.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#klasikinis-mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3.1</b> Klasikinis mašininis mokymasis</a></li>
<li class="chapter" data-level="8.3.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#kvantinis-mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3.2</b> Kvantinis mašininis mokymasis</a></li>
<li class="chapter" data-level="8.3.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#kvantinėmis-grandinėmis-paremtas-klasifikatorius"><i class="fa fa-check"></i><b>8.3.3</b> Kvantinėmis grandinėmis paremtas klasifikatorius</a></li>
<li class="chapter" data-level="8.3.4" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#pagrindinių-komponentų-analizė"><i class="fa fa-check"></i><b>8.3.4</b> Pagrindinių komponentų analizė</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html"><i class="fa fa-check"></i><b>9</b> Kvantinių klaidų aptikimas ir taisymas</a>
<ul>
<li class="chapter" data-level="9.1" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klasikinės-ir-kvantinės-klaidos"><i class="fa fa-check"></i><b>9.1</b> Klasikinės ir kvantinės klaidos</a></li>
<li class="chapter" data-level="9.2" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#supynimas-ir-klaidu-atsiradimas"><i class="fa fa-check"></i><b>9.2</b> Kvantinis supynimas su aplinka ir klaidų atsiradimas</a></li>
<li class="chapter" data-level="9.3" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bito-apvertimo-klaidos-aptikimas-ir-taisymas"><i class="fa fa-check"></i><b>9.3</b> Bito apvertimo klaidos aptikimas ir taisymas</a></li>
<li class="chapter" data-level="9.4" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fazės-apvertimo-klaidos-aptikimas-ir-taisymas"><i class="fa fa-check"></i><b>9.4</b> Fazės apvertimo klaidos aptikimas ir taisymas</a></li>
<li class="chapter" data-level="9.5" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#tolydžiosios-klaidos"><i class="fa fa-check"></i><b>9.5</b> Tolydžiosios klaidos</a></li>
<li class="chapter" data-level="9.6" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bendrieji-klaidų-taisymo-principai"><i class="fa fa-check"></i><b>9.6</b> Bendrieji klaidų taisymo principai</a></li>
<li class="chapter" data-level="9.7" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinė-hamingo-riba"><i class="fa fa-check"></i><b>9.7</b> Kvantinė Hamingo riba</a></li>
<li class="chapter" data-level="9.8" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#šoro-9-kubitų-kodas"><i class="fa fa-check"></i><b>9.8</b> Šoro 9 kubitų kodas</a></li>
<li class="chapter" data-level="9.9" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kodu-stabilizatoriai-poskyris"><i class="fa fa-check"></i><b>9.9</b> Kodų stabilizatoriai</a></li>
<li class="chapter" data-level="9.10" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klaidoms-atsparus-skaičiavimas"><i class="fa fa-check"></i><b>9.10</b> Klaidoms atsparus skaičiavimas</a></li>
<li class="chapter" data-level="9.11" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinis-tūris"><i class="fa fa-check"></i><b>9.11</b> Kvantinis tūris</a></li>
</ul></li>
<li class="appendix"><span><b>Priedai</b></span></li>
<li class="chapter" data-level="A" data-path="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html"><a href="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html"><i class="fa fa-check"></i><b>A</b> Debesyje pasiekiami kvantiniai kompiuteriai ir simuliatoriai</a></li>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html"><i class="fa fa-check"></i>Literatūra</a>
<ul>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html#knygos"><i class="fa fa-check"></i>Knygos</a></li>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html#moksliniai-straipsniai"><i class="fa fa-check"></i>Moksliniai straipsniai</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Kvantinė kompiuterija</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="kvantinių-klaidų-aptikimas-ir-taisymas" class="section level1 hasAnchor" number="9">
<h1><span class="header-section-number">9 skyrius.</span> Kvantinių klaidų aptikimas ir taisymas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinių-klaidų-aptikimas-ir-taisymas" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Klaidų taisymas iš pirmo žvilgsnio neatrodo itin estetiškas ar įdomus
užsiėmimas. Tačiau kvantinėje kompiuterijoje tai yra viena iš labiausiai
apšviečiančių ir stebinančių sričių. Dekoherencija yra artimai susijusi
su mus supančių klasikinių reiškinių atsiradimu iš pasaulio, kuris
fundamentaliai vadovaujasi kvantinėmis taisyklėmis. Dekoherencija –
pagrindinė priežastis, kuri neleidžia realizuoti makroskopinio dydžio
objektų, esančių superpozicijos būsenose. Atliekant klaidų analizę ir
taisymą taip pat geriau atsiskleidžia gili informacijos sąvokos reikšmė
ir kvantinio supynimo svarba. Informacijos atskleidimas gali sugriauti
sistemos superpozicijos būseną net ir tada, jeigu su šia sistema nėra
tiesioginės sąveikos.</p>
<div id="klasikinės-ir-kvantinės-klaidos" class="section level2 hasAnchor" number="9.1">
<h2><span class="header-section-number">9.1</span> Klasikinės ir kvantinės klaidos<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klasikinės-ir-kvantinės-klaidos" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Kvantinė kompiuterija pasikliauja delikačiomis kubitų superpozicijos
būsenomis. Praktikoje kubitai nėra idealiai izoliuoti nuo aplinkos, jų
neišvengiama sąveika su išorinėmis sistemomis mažina gebėjimą išlikti
superpozicijos būsenose ilgą laiką. Pirmame skyriuje minėtos <span class="math inline">\(T_1\)</span> ir <span class="math inline">\(T_2\)</span>
dekoherencijos trukmės atspindi, kaip intensyviai išorinės sąveikos
vyksta su kubitais, taip pat įvardija laiko skalę, pagal kurią galima
spręsti, kiek loginių operacijų įmanoma atlikti iki tol, kol neatsiras
didelė klaidų tikimybė. Dekoherencija nėra vienintelis klaidų
šaltinis – atliekamų loginių vartų netikslumai taip pat praktiškai
neišvengiami. Unitariosios operacijos yra nusakomos tolydžiai
kintančiais parametrais, todėl praktikoje atsiremiama į ribotą loginių
vartų tikslumą. Nepaisant šių klaidų šaltinių, pageidaujamo tikslumo bei
ilgumo kvantiniai skaičiavimai gali būti atlikti pasitelkiant klaidų
taisymo algoritmus. Tam yra reikalaujama, kad dekoherencijos trukmės
nebūtų per daug trumpos, o loginių vartų netikslumai – per daug dideli.
Tada pasitelkus papildomus išteklius – kubitus ir logines operacijas –
galima formaliai pasiekti klaidoms atsparius skaičiavimus. Šiame procese
klaidos yra taisomos dinaminėje situacijoje viso skaičiavimo proceso
metu. Žinoma, kvantines būsenas norima apsaugoti ir statinėse
situacijose – siunčiant kubitus kvantiniais ryšiais ar saugant
kvantinio kompiuterio atmintyje. Kaip matysime, panašūs principai yra
taikomi abiem situacijoms.</p>
<p>Šiuolaikiniai klasikiniai kompiuteriai yra itin atsparūs skaičiavimo
klaidoms ir šiuo atžvilgiu gali būti traktuojami kaip esantys be
trūkumų. Klaidos turi didesnę tikimybę atsirasti siunčiant skaitmeninę
informaciją komunikacijos kanalais ir ją užrašant į atmintį. Klaidų
atsiradimas daugeliu atvejų yra nenuspėjamas (formaliau – stochastinis)
ir šnekamojoje kalboje vadinamas <strong>triukšmu</strong> (angl. <em>noise</em>).
Pagrindinis principas norint užtikrinti, kad esant triukšmui informacija
nebus prarasta, yra pasitelkti papildomą, vadinamąją perteklinę
informaciją. Jeigu dalis
informacijos ir yra prarandama, perteklinė informacija padeda
užtikrinti, kad informacijos turinys bus sėkmingai atstatytas. Šį
principą taiko ir žmonės tarpusavio komunikacijoje, kai paprašoma
pakartoti gerai neišgirstą sakinį. Kaip to pavyzdį kompiuterijoje
imkime, kad Agnė ketina nusiųsti Benui informaciją dvejetainiu pavidalu
naudodama triukšmingą komunikacijos kanalą, kuriame triukšmo efektas yra
kiekvieną bitą apversti (<span class="math inline">\(0 \leftrightarrow 1)\)</span> su tikimybe <span class="math inline">\(p\)</span>
(<span class="math inline">\(0 \leq p \leq 1\)</span>), nepriklausomai nuo kitų bitų verčių. Tad tikimybė,
kad bus gautas teisingas bitas, yra <span class="math inline">\(1 - p\)</span>. Siekdama apsaugoti
dvejetainę informaciją, Agnė kiekvieną turinio bitą prieš siuntimą
pakeičia trimis identiškais bitais: <span class="math inline">\(0 \rightarrow 000\)</span>,
<span class="math inline">\(1 \rightarrow 111\)</span>. Šios 0 ir 1 trijų bitų sekos yra formaliai
vadinamos loginiais 0 ir 1 bitais, o pasirinktas specifinis būdas
perteikti bitų vertėms vadinamas kodu. Benas, žinodamas Agnės kodavimo
būdą ir taikydamas <strong>daugumos balsavimo metodą</strong> (angl. <em>majority
voting</em>), gavęs bitų seką gali nuspręsti, koks bitas jam buvo siųstas.
Pavyzdžiui, jeigu gauta seka yra 001, daugumos balso principu jis
nusprendžia, kad įvyko klaida trečiajame bite ir buvo siųsta <span class="math inline">\(000\)</span>. Toks
trijų bitų kodavimo būdas bus sėkmingas, jeigu kode atsiranda ne daugiau
nei viena klaida. Galima nesunkiai parodyti, kad bendra tikimybė,
nusakanti, jog įvyks nepataisoma dviejų ar trijų bitų apvertimo klaida,
yra <span class="math inline">\(3p^2 (1 - p) + p^3\)</span>. Tad palyginus su <span class="math inline">\(p\)</span>, kai siunčiamas
pavienis bitas, trijų bitų kodas sumažina nepataisomų klaidų tikimybę,
jeigu <span class="math inline">\(p &lt; 0.5\)</span>, ir suteikia sparčiai didėjantį pranašumą toliau
mažėjant <span class="math inline">\(p\)</span>.</p>
<p>Klasikiniuose klaidų taisymo koduose yra taikomas bitų kopijavimas
pridedant perteklinę informaciją, o siekiant klaidas aptikti ir jas
taisyti bitų sekos yra tiesiogiai nuskaitomos. Akivaizdu, kad abu šie
procesai negali būti pritaikomi kvantiniam kompiuteriui ir kvantiniams
ryšiams. Bendrosios kvantinės būsenos neįmanoma nukopijuoti, o tokios
būsenos tiesioginis nuskaitymas sugriauna superpoziciją ir joje laikomą
informaciją. Be to, bitų apvertimas yra vienintelė galima klaida
klasikinėje terpėje; o štai kvantinių klaidų įvairovė yra didesnė, nes
klaidos kinta tolydžiai dėl analoginio kvantinių būsenų pobūdžio.
Pavyzdžiui, 1 kubito būseną <span class="math inline">\(|\psi\rangle\)</span> nusakome
Blocho vektoriumi, kuris apibūdinamas dviem tolydžiais parametrais,
nurodančiais kampus. Jeigu loginiais vartais norima pasukti šį vektorių,
sakykime, apie <span class="math inline">\(x\)</span> ašį kampu <span class="math inline">\(\theta\)</span>, tačiau gaunamas
<span class="math inline">\(\theta + \varepsilon\)</span>, netikslumas <span class="math inline">\(\varepsilon\)</span> yra viena galima
klaida. Tai galima formaliai užrašyti dviem unitariaisiais operatoriais,
veikiančiais kubitą paeiliui:
<span class="math display" id="eq:posukis-klaida">\[\begin{equation}
ER_x(\theta)|\psi\rangle = \mathrm{e}^{-\mathrm{i}\varepsilon X/2}\mathrm{e}^{-\mathrm{i}\theta X/2}|\psi\rangle\,.
\tag{9.1}
\end{equation}\]</span>
Čią <span class="math inline">\(R_x(\theta) = \mathrm{e}^{-\mathrm{i}\theta X/2}\)</span> nusako tikslią operaciją, o po
jos rašomas klaidos operatorius <span class="math inline">\(E = \mathrm{e}^{-\mathrm{i}\varepsilon X/2}\)</span>.
Nepageidaujamos išorinės sąveikos taip pat gali įvesti šias klaidas.
Įsivaizduokime vėl, kad sąveikos efektas yra pasukti Blocho vektorių
aplink <em>x</em> ašį kampu <span class="math inline">\(\varepsilon\)</span>, kai pradinė kubito būsena yra
<span class="math inline">\(|0 \rangle\)</span>. Siekiant supaprastinti simboliką, toliau
minuso ženklą ir faktorių 2 įtrauksime į <span class="math inline">\(\varepsilon\)</span>. Randame paveiktą
būseną:
<span class="math display" id="eq:paveikta-busena">\[\begin{equation}
\mathrm{e}^{\mathrm{i}\varepsilon X}|0\rangle
= \big\lbrack\cos(\varepsilon)I + \mathrm{i}\sin(\varepsilon)X\big\rbrack|0\rangle
= \cos(\varepsilon)|0\rangle + \mathrm{i}\sin(\varepsilon)|1\rangle\,.
\tag{9.2}
\end{equation}\]</span>
Tai formaliai nusako nepaveiktos būsenos <span class="math inline">\(|0\rangle\)</span> ir
klaidingos būsenos <span class="math inline">\(|1\rangle\)</span> superpoziciją. Tikimybė,
kad atlikus matavimą kubitas bus rastas būsenose
<span class="math inline">\(|0\rangle\)</span> arba <span class="math inline">\(|1\rangle\)</span>, kai
<span class="math inline">\(\varepsilon\)</span> yra itin mažas, tampa:
<span class="math display" id="eq:tikimybe-1" id="eq:tikimybe-0">\[\begin{align}
p\big(|0\rangle\big) = &amp; \cos^2(\varepsilon) \approx 1 - \varepsilon^2\,; \tag{9.3}\\
p\big(|1\rangle\big) = &amp; \sin^2(\varepsilon) \approx \varepsilon^2\,.\tag{9.4}
\end{align}\]</span>
Jeigu ši sąveika, ar loginių vartų paklaida, įvyktų sistemiškai
<span class="math inline">\(n\)</span> kartų, tada tikimybės būtų atitinkamai <span class="math inline">\(1 - (n\varepsilon)^2\)</span> ir
<span class="math inline">\((n\varepsilon)^2\)</span>. Itin mažos paklaidos skaičiavimo metu gali būti
toleruotinos, nes tikimybė rasti klaidingą būseną bus itin maža. Tačiau
dideliuose algoritmuose, tokiuose kaip atliekant Šoro pirminių skaičių
faktorizavimą, loginių vartų skaičius gali siekti <span class="math inline">\(\sim 10^{10}\)</span> ir daugiau.
Loginių vartų paklaida <span class="math inline">\(\varepsilon\)</span> atitinkamai turi būti mažesnė nei
<span class="math inline">\(\sim 10^{-10}\)</span>. Šios knygos rašymo metu loginių vartų tikslumas
siekia <span class="math inline">\(\sim 10^{-4}\)</span>, tad klaidų taisymo algoritmai
yra pageidautini.</p>
<p>Kvantinis supynimas ir su juo įvedamos koreliacijos klaidų taisymo
algoritmuose dar kartą iliustruoja ypatingą šio ištekliaus svarbą.
Nepaisant klaidų analoginio pobūdžio ir begalinio tikslumo norint jas
apibūdinti, šis išteklius užtikrina, kad reikia taisyti tik diskrečias
trijų tipų klaidas. Kitaip tariant, kvantinėje kompiuterijoje klaidos
yra efektyviai skaitmenizuojamos. Pirmojo tipo klaida yra, kaip ir
klasikinėje skaitmeninėje kompiuterijoje, vadinama <strong>bito apvertimo
klaida</strong> (angl. <em>bit-flip error</em>), kuri sukeičia kubito būsenas
<span class="math inline">\(|0\rangle \leftrightarrow |1\rangle\)</span>.
Kubito apvertimo klaidos procesas yra nusakomas Pauli-<span class="math inline">\(X\)</span> operatoriumi,
kuris veikdamas bendrą superpozicijos būseną turi efektą:
<span class="math display" id="eq:kubito-apvertimo-klaida">\[\begin{equation}
X\big(a|0\rangle + b|1\rangle\big) = a|1\rangle + b|0\rangle\,.
\tag{9.5}
\end{equation}\]</span>
<strong>Fazės apvertimo klaida</strong> (angl. <em>phase-flip error</em>) yra išskirtinai
kvantinio pobūdžio, nes klasikinėje kompiuterijoje fazės atitikmens
nėra. Fazės apvertimo klaidos atsiradimas yra nusakomas Pauli-<span class="math inline">\(Z\)</span>
operatoriumi:
<span class="math display" id="eq:fazes-klaida">\[\begin{equation}
Z\big(a|0\rangle + b|1\rangle\big) = a|0\rangle - b|1\rangle\,.
\tag{9.6}
\end{equation}\]</span>
Matyti, kad santykinė fazė tarp <span class="math inline">\(|0\rangle\)</span> ir
<span class="math inline">\(|1\rangle\)</span> kubito būsenų yra pakeičiama. Galiausiai, bito ir fazės
apvertimo klaidų kombinacija, <span class="math inline">\(XZ\)</span>, yra trečia galima klaida. Primename
Pauli operatorių sąryšį <span class="math inline">\(XZ = -\mathrm{i}Y\)</span>. Tad šių dviejų klaidų kombinaciją
iki globalios fazės galime išreikšti Pauli-<span class="math inline">\(Y\)</span> loginiais vartais:
<span class="math display" id="eq:kombinuota-klaida">\[\begin{equation}
-\mathrm{i}Y\big(a|0\rangle + b|1\rangle\big) = a|1\rangle - b|0\rangle\,.
\tag{9.7}
\end{equation}\]</span></p>
</div>
<div id="supynimas-ir-klaidu-atsiradimas" class="section level2 hasAnchor" number="9.2">
<h2><span class="header-section-number">9.2</span> Kvantinis supynimas su aplinka ir klaidų atsiradimas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#supynimas-ir-klaidu-atsiradimas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Loginių vartų netikslumai po kiekvieno jų pritaikymo gali įvesti
tolydžiai kintančias klaidas. Sistemiškai atsirandančios vienodo tipo
klaidos yra lengviau aptinkamos bei ištaisomos, na, o kintančios
atsitiktiniu būdu įveda triukšmo pobūdį. Tačiau, net ir palikus kubitus
ramybėje, jų būsenos gali būti paveikiamos nekontroliuojamų sąveikų su
išorinėmis sistemomis. Bendrą kubitų ir aplinkos kvantinę sistemą visada
galime apibūdinti kaip naują išplėstinę sistemą, kuri kinta laike
deterministiškai vadovaujantis Šriodingerio lygtimi. Tačiau dėl
informacijos apie įvykusias sąveikas trūkumo mūsų požiūriu bus stebimi
atsitiktiniai, triukšmo pobūdžio, kubitų būsenų pokyčiai. Dėl sąveikų
tarp kvantinių sistemų bendroje situacijoje atsiranda supynimas.
Siekdami iliustruoti supynimo įtaką imkime paprastą pavyzdį, kuriame
kubitas yra paruoštas pradinėje superpozicijos būsenoje:
<span class="math display" id="eq:superpozicija-klaidoms">\[\begin{equation}
|\psi\rangle = \frac{1}{\sqrt{2}}\big(|0\rangle + |1\rangle\big)\,.
\tag{9.8}
\end{equation}\]</span>
Jeigu atliksime šiai būsenai (idealiai veikiančius) Hadamardo loginius
vartus, ji taps
<span class="math inline">\(H|\psi\rangle = |0\rangle\)</span>. Tad
išmatavus kubito būseną su <span class="math inline">\(p = 1\)</span> tikimybe rasime
<span class="math inline">\(|0\rangle\)</span>. Sakykime, kad prieš atliekant <span class="math inline">\(H\)</span> kubitas
patyrė sąveiką <span class="math inline">\(U\)</span> su aplinkos sistema <span class="math inline">\(|e\rangle\)</span>, ir
tai lėmė jų kvantinį supynimą ir bendrą būseną:
<span class="math display" id="eq:busena-saveika-aplinka">\[\begin{equation}
U|\psi\rangle\otimes|e\rangle
= \frac{1}{\sqrt{2}}\big(|0\rangle\otimes|e_1\rangle + |1\rangle\otimes|e_2\rangle\big)\,.
\tag{9.9}
\end{equation}\]</span>
Čia <span class="math inline">\(|e_0\rangle\)</span> ir <span class="math inline">\(|e_1\rangle\)</span>
yra aplinkos sistemos būsenos. Nežinodami apie įvykusią sąveiką,
atliekame kubitui Hadamardo vartus:
<span class="math display" id="eq:h-po-saveikos">\[\begin{equation}
H\otimes I\big(U|\psi\rangle\otimes|e\rangle\big)
= \frac{1}{2}\big(|0\rangle + |1\rangle )\otimes|e_1\rangle
+ \frac{1}{2}\big(|0\rangle - |1\rangle )\otimes|e_2\rangle\big)\,.
\tag{9.10}
\end{equation}\]</span>
Matome, kad kvantinis supynimas neleidžia panaikinti kubito būsenos
<span class="math inline">\(|1\rangle\)</span>, kaip tai atsitinka dėl interferencijos
<span class="math inline">\(H|\psi\rangle\)</span>. Tolesniame žingsnyje vėl išmatuojame
kubito būseną, tikimybės <span class="math inline">\(p(0)\)</span> ir <span class="math inline">\(p(1)\)</span> rasti
<span class="math inline">\(|0\rangle\)</span> ir <span class="math inline">\(|1\rangle\)</span> yra:
<span class="math display" id="eq:tikimybe-1-po-saveikos" id="eq:tikimybe-0-po-saveikos">\[\begin{align}
p(0) = &amp; \frac{1}{4}\big(\langle e_1 | e_1 \rangle + \langle e_2 | e_2 \rangle
+ \langle e_1 | e_2 \rangle + \langle e_2 | e_1 \rangle\big) \nonumber\\
= &amp; \frac{1}{4}\big(\langle e_1 | e_1 \rangle + \langle e_2 | e_2 \rangle
+ 2\mathrm{Re}\lbrack \langle e_1 | e_2 \rangle\rbrack\big)\,;\tag{9.11}\\
p(1) = &amp; \frac{1}{4}\big(\langle e_1 | e_1 \rangle + \langle e_2 | e_2 \rangle
- 2\mathrm{Re}\lbrack \langle e_1 | e_2 \rangle\rbrack\big)\,.\tag{9.12}
\end{align}\]</span>
Norėdami įvertinti šias tikimybes, turime daugiau pasakyti apie išorinę
sistemą. Darydami prielaidą, kad ji yra normuotoji, o būsenos
ortogonaliosios, <span class="math inline">\(\langle e_1 | e_2 \rangle = 0\)</span>,
randame <span class="math inline">\(p(0) = p(1) = 1/2\)</span>. Tai nusako lygias tikimybes rasti
<span class="math inline">\(|0\rangle\)</span> arba <span class="math inline">\(|1\rangle\)</span> pamatavus
sistemos kubito būseną. Todėl nežinant apie įvykusią sąveiką ir kvantinį
supynimą mūsų požiūriu atrodys, kad kubito būsena tampa visiškai
atsitiktinė, o ne <span class="math inline">\(|0\rangle\)</span>, kaip tikėtasi.
Informacija, koduojama bendrosios būsenos amplitudėse, tampa efektyviai
nebepasiekiama, nes yra delokalizuojama koreliacijose tarp aplinkos ir
kubito. Sąveikos su aplinka priveda kvantines sistemas prie
dekoherencijos, dėl kurios jos panašėja į klasikines triukšmingas
sistemas.</p>
<p>Norėdami aiškiau pamatyti, kaip atsiranda trys minėtos Pauli
operatoriais nusakomos kubitų būsenų klaidos, imkime bendriausio tipo
unitariąją transformaciją <span class="math inline">\(U\)</span>, veikiančią kubito ir aplinkos kvantinę
sistemą. Ji nebūtinai apibūdinama dviem skirtingomis būsenomis, kaip
kubitai, bet gali turėti jų daug daugiau. Transformacijos įtaka kubito
standartiniams baziniams vektoriams ir aplinkos pradinei būsenai
<span class="math inline">\(|e\rangle\)</span> išreiškiama taip:
<span class="math display" id="eq:u-1-e" id="eq:u-0-e">\[\begin{align}
U|0\rangle\otimes|e\rangle = &amp; |0\rangle\otimes|e_1 \rangle + |1\rangle\otimes|e_2 \rangle\,;\tag{9.13} \\
U|1\rangle\otimes|e\rangle = &amp; |0\rangle\otimes|e_3 \rangle + |1\rangle\otimes|e_4 \rangle\,.\tag{9.14}
\end{align}\]</span>
Bendroje situacijoje, aplinkos sistemos būsena, kuri dalyvavo sąveikoje,
gali būti nenormuotoji ir skirtingi <span class="math inline">\(|e_i \rangle\)</span>
tarpusavyje neortogonalūs,
<span class="math inline">\(\langle e_i | e_j \rangle \neq 0\)</span>. Imkime bendrą
kubito būseną
<span class="math inline">\(|\psi\rangle = a|0\rangle + b|1\rangle\)</span>,
tada randame:
<span class="math display" id="eq:bendra-situacija-saveika-su-aplinka">\[\begin{equation}
\begin{aligned}
U|\psi\rangle\otimes|e\rangle
= &amp; a\big(|0\rangle\otimes|e_1 \rangle + |1\rangle\otimes|e_2 \rangle\big)
+ b\big(|0\rangle\otimes|e_3 \rangle + |1\rangle\otimes|e_4 \rangle\big) \\
= &amp; \frac{1}{2}\Big\lbrack\big(a|0\rangle + b|1\rangle\big)
\otimes\big(|e_0 \rangle + |e_3 \rangle\big)
+ \big(a|1\rangle + b|0\rangle\big)
\otimes\big(|e_1 \rangle + |e_2 \rangle\big) \\
&amp; + \big(a|0\rangle - b|1\rangle\big)
\otimes\big(|e_0 \rangle - |e_3 \rangle\big)
+ \big(a|1\rangle - b|0\rangle\big)
\otimes\big(|e_1 \rangle - |e_2 \rangle\big)\Big\rbrack\,.
\end{aligned}
\tag{9.15}
\end{equation}\]</span>
Antroje eilutėje pergrupavome būsenas siekdami parodyti, kad kubito
sąveika su aplinka gali būti išreikšta Pauli operatoriais, veikiančiais
kubito superpozicijos būseną:
<span class="math display" id="eq:saveika-su-aplinka-pauli">\[\begin{equation}
U|\psi\rangle\otimes|e\rangle
= I|\psi\rangle\otimes|e_I \rangle + X|\psi\rangle\otimes|e_x \rangle
+ Z|\psi\rangle\otimes|e_z \rangle + XZ|\psi\rangle\otimes|e_{xz}\rangle\,.
\tag{9.16}
\end{equation}\]</span>
Aplinkos būsenas pervadinome taip:
<span class="math display" id="eq:aplinkos-busenos">\[\begin{equation}
\begin{aligned}
|e_I \rangle = &amp; \frac{\big(|e_0 \rangle + |e_3 \rangle\big)}{2}\,,\quad
|e_x \rangle = \frac{\big(|e_1 \rangle + |e_2 \rangle\big)}{2}\,,\\
|e_z \rangle = &amp; \frac{\big(|e_0 \rangle - |e_3 \rangle\big)}{2}\,,\quad
|e_{xz}\rangle = \frac{\big(|e_1 \rangle - |e_2 \rangle\big)}{2}\,.
\end{aligned}
\tag{9.17}
\end{equation}\]</span>
Matome, kad aplinkos ir kubito sistema tampa supintąja. Pirmoji
superpozicijoje būsena
<span class="math inline">\(I|\psi\rangle\otimes|e_I \rangle\)</span>
įvardija nepakitusią kubito pradinę būseną. Kubito apvertimo klaida yra
nusakoma nariu
<span class="math inline">\(X|\psi\rangle\otimes|e_x \rangle\)</span>,
o štai fazės klaida, taip pat fazės ir kubito apvertimo klaidų
kombinacija nusako būsenas
<span class="math inline">\(Z|\psi \rangle\otimes|e_z \rangle\)</span>
ir
<span class="math inline">\(XZ|\psi \rangle\otimes|e_xz \rangle\)</span>,
atitinkamai. Tai neturėtų būti stebinantis rezultatas, kadangi visos
<span class="math inline">\((2 \times 2)\)</span> dydžio unitariosios matricos, nusakančios visas įmanomas
1 kubito būsenų transformacijas, gali būti išreikštos Pauli matricų
<span class="math inline">\(\{I, X, Y, Z\}\)</span> tiesinėmis kombinacijomis.</p>
</div>
<div id="bito-apvertimo-klaidos-aptikimas-ir-taisymas" class="section level2 hasAnchor" number="9.3">
<h2><span class="header-section-number">9.3</span> Bito apvertimo klaidos aptikimas ir taisymas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bito-apvertimo-klaidos-aptikimas-ir-taisymas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Darome prielaidą, kad klaidos atsiranda kiekviename registro kubite
atskirai nuo kitų kubitų. Tai yra vadinamosios nekoreliuotos triukšmo
pobūdžio klaidos. Formaliai sakysime, kad klaidos atsiranda siunčiant
kvantines būsenas per <strong>triukšmingą kvantinį kanalą</strong> (angl. <em>noisy
quantum channel</em>). Tai gali įvardyti kubitų siuntimą kvantiniais ryšiais
arba kubitų laiko evoliuciją tam tikru laiko intervalu kvantiniame
kompiuteryje. Kubitas nukeliauja kanalą nepaveiktas su tikimybe <span class="math inline">\(1 - p\)</span>
ir patiria klaidą su tikimybe <span class="math inline">\(p\)</span>. Šioje stadijoje taip pat darome
prielaidą, kad loginiai vartai veikia idealiai, be netikslumų. Dinaminę
klaidų taisymo metodologiją, apimančią dekoherencijos ir loginių vartų
efektus kartu, aptariame šio skyriaus pabaigoje.</p>
<p>Kvantinių klaidų taisymo algoritmai yra dažnai pristatomi pradedant nuo
3 kubitų kodų, skirtų taisyti bito apvertimo arba fazės apvertimo
klaidas. Pavieniui jie nėra pilnieji kodai, galintys ištaisyti visas
klaidų kombinacijas, tačiau leidžia pamatyti esminius klaidų aptikimo ir
taisymo principus. Šių dviejų kodų sujungimu <strong>konkatenacijos būdu</strong>
(angl. <em>concatenation</em>) yra pagrįstas Šoro 9 kubitų kodas – vienas iš
pirmųjų gebantis ištaisyti bendrojo tipo klaidas.</p>
<p>Kaip ir klasikiniame bito apvertimo klaidos pavyzdyje, loginis kubitas
yra sudaromas iš trijų fizinių kubitų. Vieno kubito būsena
<span class="math inline">\(|\psi\rangle\)</span> yra perteikiama loginiu kubitu
<span class="math inline">\(|\psi\rangle_L\)</span> taip:
<span class="math display" id="eq:loginis-kubitas-is-fiziniu">\[\begin{equation}
|\psi\rangle = a|0\rangle + b|1\rangle
\rightarrow |\psi\rangle_L = a|0\rangle_L + b|1\rangle_L
= a|000\rangle + b|111\rangle\,.
\tag{9.18}
\end{equation}\]</span>
Būsenos yra normuotosios,
<span class="math inline">\(|a|^2 + |b|^2 = 1\)</span>, o 1 kubito baziniai vektoriai koduojami
<span class="math inline">\(|0\rangle\rightarrow |000\rangle\)</span>,
<span class="math inline">\(|1\rangle \rightarrow |111\rangle\)</span>.
Atkreipiame dėmesį, kad loginiame kubite
<span class="math inline">\(|\psi\rangle_L\)</span> baziniai vektoriai yra
„patrigubinami”, tačiau <span class="math inline">\(|\psi\rangle\)</span> būsena nėra
nukopijuojama tris kartus,
<span class="math inline">\(|\psi\rangle\otimes|\psi\rangle\otimes|\psi\rangle\)</span>,
ir todėl neprieštarauja uždraustojo kopijavimo teoremai. Loginis kubitas
<span class="math inline">\(|\psi\rangle_L\)</span> nusako supintąją trijų fizinių kubitų
kvantinę būseną, kurią galima sukurti pradedant nuo kubito
<span class="math inline">\(|\psi\rangle\)</span> būsenoje ir dviejų papildomų kubitų
<span class="math inline">\(|00\rangle\)</span> būsenoje atliekant dvejus <span class="math inline">\(CNOT\)</span> loginius
vartus.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:loginio-kubito-paruosimas"></span>
<img src="media/image9_1.svg" alt="Loginio kubito būsenos $|\psi\rangle_L$ paruošimas naudojant 3 fizinius kubitus" width="40%" />
<p class="caption">
9.1 pav. Loginio kubito būsenos <span class="math inline">\(|\psi\rangle_L\)</span> paruošimas naudojant 3 fizinius kubitus
</p>
</div>
<p>Visi trys fiziniai kubitai, formuojantys loginį kubitą, gali būti
paveikti triukšmo; tad šis kodas bus veiksmingas, jeigu bito apvertimo
klaida atsiranda ne daugiau nei viename iš trijų kubitų. Toliau
pažiūrėkime, kaip aptikti atsirandančią bito apvertimo klaidą loginiame
kubite.</p>
<p>Tiesioginiai 3 kubitų būsenų matavimai nėra išeitis aptikti ir taisyti
klaidas. Sakykime, kad atsiranda klaida pirmajame kubite, kuri pakeičia
<span class="math inline">\(|\psi\rangle_L\)</span> būseną taip:
<span class="math display" id="eq:bito-apvertimo-klaida-loginiame-kubite">\[\begin{equation}
|\psi\rangle_L \rightarrow a|100\rangle + b|011\rangle\,.
\tag{9.19}
\end{equation}\]</span>
Atlikę Pauli-<span class="math inline">\(Z\)</span> matavimus su visais 3 kubitais rastume
<span class="math inline">\(|100\rangle\)</span> arba <span class="math inline">\(|011\rangle\)</span> būsenas
su <span class="math inline">\(|a|^2\)</span> ir <span class="math inline">\(|b|^2\)</span> tikimybėmis, atitinkamai. Tai užtikrintų
klaidos aptikimą, tačiau superpozicija bus sugriauta, o negalėdami
sužinoti <span class="math inline">\(a\)</span> ir <span class="math inline">\(b\)</span> amplitudžių šios būsenos nebeatstatysime. Aptikti
klaidas 3 kubitų kode galima pritaikius vadinamąjį nelokalų matavimą,
pasitelkiant papildomus ancila kubitus. Atkreipiame dėmesį, kad abu
kodai <span class="math inline">\(|0\rangle_L\)</span> ir <span class="math inline">\(|1\rangle_L\)</span>
yra <span class="math inline">\(Z\otimes Z\otimes I\)</span>, <span class="math inline">\(Z\otimes I\otimes Z\)</span> ir
<span class="math inline">\(I\otimes Z\otimes Z\)</span> operatorių tikriniai vektoriai su vienodomis
tikrinėmis vertėmis <span class="math inline">\(\lambda = 1\)</span>. Pavyzdžiui,
<span class="math inline">\(Z\otimes Z\otimes I|0 \rangle_L = |0\rangle_L\)</span>
ir
<span class="math inline">\(Z\otimes Z\otimes I|1\rangle_L = |1\rangle_L\)</span>.
Tokį dėsningumą matome iš to, kad Pauli-<span class="math inline">\(Z\)</span> operatoriai tenzorinėje
operatorių sandaugoje, veikdami pavienių kubitų būsenas
<span class="math inline">\(|0\rangle\)</span> ir <span class="math inline">\(|1\rangle\)</span> jas sudaugina
su <span class="math inline">\(\lambda = 1\)</span> ir <span class="math inline">\(\lambda = -1\)</span> tikrinėmis vertėmis, atitinkamai.
Tad <span class="math inline">\(Z\otimes Z\otimes I\)</span> veikdamas pirmąjį ir antrąjį kubitus
<span class="math inline">\(|000\rangle\)</span> ir <span class="math inline">\(|111\rangle\)</span> būsenose,
arba jų superpozicijoje, sudaugina bendrą būseną su
<span class="math inline">\(\lambda_1 \lambda_2 = 1\)</span>. Tačiau, jeigu vienas iš šių dviejų kubitų
patyrė bito apvertimo klaidą, tada jų būsenos skirsis, o tikrinių verčių
sandauga taps <span class="math inline">\(\lambda_1 \lambda_2 = -1\)</span>. Siekiant nustatyti,
kuriame iš trijų kubitų įvyko klaida, pakanka atlikti du matavimus
<span class="math inline">\(Z\otimes Z\otimes I\)</span> ir <span class="math inline">\(Z\otimes I\otimes Z\)</span>, arba bet
kurią iš kitų dviejų porų kombinacijos. Pavyzdžiui, jeigu
<span class="math inline">\(Z\otimes Z\otimes I\)</span> ir <span class="math inline">\(Z\otimes I\otimes Z\)</span> matavimų
tikrinės vertės yra abi
<span class="math inline">\(\lambda_1 \lambda_2 = \lambda_1 \lambda_3 = -1\)</span>, galime
unikaliai konstatuoti, kad įvyko klaida pirmajame kubite. Kitos dvi
galimybės <span class="math inline">\(\lambda_1 \lambda_2 = -1\)</span> ir <span class="math inline">\(\lambda_1 \lambda_3 = 1\)</span>
bei <span class="math inline">\(\lambda_1 \lambda_2 = 1\)</span> ir <span class="math inline">\(\lambda_1 \lambda_3 = -1\)</span>
indikuoja klaidą antrajame ir trečiajame kubite, atitinkamai. Kvantinė
grandinė <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:bito-apvertimo-taisymo-grandine">9.2</a> pav. iliustruoja bito
apvertimo klaidos aptikimą ir taisymą.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:bito-apvertimo-taisymo-grandine"></span>
<img src="media/image9_2.svg" alt="Bito apvertimo klaidos aptikimą ir taisymą atliekanti grandinė" width="81%" />
<p class="caption">
9.2 pav. Bito apvertimo klaidos aptikimą ir taisymą atliekanti grandinė
</p>
</div>
<p>Siekdami atlikti <span class="math inline">\(Z\otimes Z\otimes I\)</span> ir
<span class="math inline">\(Z\otimes I\otimes Z\)</span> operatorių matavimus panaudojame papildomus
ancila kubitus, inicializuotus pradinėje <span class="math inline">\(|00\rangle\)</span>
būsenoje. Keturi <span class="math inline">\(CNOT\)</span> vartai su ancila adresatiniais kubitais nusako
aptikimo stadiją, kuri yra pagrįsta dviejų kubitų lyginumo nustatymu.
Matome, kad <span class="math inline">\(Z\otimes Z\otimes I\)</span> matavimas realizuojamas keičiant
pirmosios ancilos <span class="math inline">\(a_1\)</span> būseną. Esant skirtingoms kubitų <span class="math inline">\(k_1\)</span> ir
<span class="math inline">\(k_2\)</span> būsenoms, ji tampa
<span class="math inline">\(|a_1 \rangle = |k_1\oplus k_2 \rangle\)</span>;
čia <span class="math inline">\(\oplus\)</span> yra <span class="math inline">\(\mod(2)\)</span> bitų sudėtis. Tad, jeigu
<span class="math inline">\(|k_1 \rangle = |k_2 \rangle\)</span>, tada
<span class="math inline">\(|a_1 \rangle = |0 \rangle\)</span>, ir tai
atitinka tikrinę vertę <span class="math inline">\(\lambda_1 \lambda_2 = 1\)</span>, indikuojančią
lyginį lyginumą. Jeigu <span class="math inline">\(|k_1 \rangle\neq |k_2 \rangle\)</span>, tada
<span class="math inline">\(|a_1 \rangle = |1\rangle\)</span>, ir tai
nusako tikrinę vertę <span class="math inline">\(\lambda_1 \lambda_2 = -1\)</span> bei nelyginį
lyginumą. Operatoriaus <span class="math inline">\(Z\otimes I\otimes Z\)</span> matavimas yra
analogiškai užrašomas keičiant antrosios ancilos būseną
<span class="math inline">\(|a_2 \rangle = |k_1\oplus k_3 \rangle\)</span>.
Užbaigiant aptikimo stadiją, bendra loginio kubito ir ancilų su klaida
pirmajame fiziniame kubite būsena tampa:
<span class="math display" id="eq:bendra-loginio-ancilos-busena">\[\begin{equation}
|\psi\rangle_L \rightarrow \big(a|100\rangle + b|011\rangle\big)\otimes|11\rangle\,.
\tag{9.20}
\end{equation}\]</span>
Atkreipiame dėmesį, kad ancilos ir loginio kubito būsena yra
faktorizuojamoji, todėl ancilų kubitų matavimo procesas neturi įtakos
loginio kubito būsenai. Ancilų kubitų būsenos yra išmatuojamos, ir tai
leidžia aptikti įvykusią klaidą. Čia svarbu atkreipti dėmesį, kad kode
atlikti nelokalūs matavimai suteikia informaciją apie koreliacijas tarp
dviejų būsenų, nusakančią, ar jos vienodos, ar skirtingos (lyginumas).
Šios informacijos pakanka klaidų nustatymui neatskleidžiant loginio
kubito būsenos amplitudžių <span class="math inline">\(a\)</span> ir <span class="math inline">\(b\)</span>. Jų atskleidimas sugriautų
superpoziciją ir joje laikomą informaciją.</p>
<table>
<caption><span id="tab:klaidos-sindromai">9.1 lentelė.</span> Faktorizuojamosios loginio kubito ir 2-jų ancilų kubitų būsenos, kurios indikuoja klaidos sindromą loginiame kubite. Tikimybės dešinėje nurodo rasti atitinkamas būsenas naudojant 3 kubitų bito apvertimo klaidos taisymo kodą. Pirma būsena lentelėje atitinka nepaveiktą, kitos trys nusako bito klaidą viename iš trijų fizinių kubitų. Dar kitos trys būsenos nusako būsenas su dviem bito klaidomis skirtinguose kubituose, paskutinioji – su bito klaidomis visuose trijuose.</caption>
<thead>
<tr class="header">
<th align="left">Būsena po klaidos sindromo nustatymo</th>
<th>Tikimybė rasti šią būseną</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\big(a|000\rangle+b|111\rangle\big)\otimes|00\rangle\)</span></td>
<td><span class="math inline">\((1-p)^3\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\big(a|100\rangle+b|011\rangle\big)\otimes|11\rangle\)</span></td>
<td><span class="math inline">\(p(1-p)^2\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\big(a|010\rangle+b|101\rangle\big)\otimes|10\rangle\)</span></td>
<td><span class="math inline">\(p(1-p)^2\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\big(a|001\rangle+b|110\rangle\big)\otimes|01\rangle\)</span></td>
<td><span class="math inline">\(p(1-p)^2\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\big(a|110\rangle+b|001\rangle\big)\otimes|01\rangle\)</span></td>
<td><span class="math inline">\(p^2(1-p)\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\big(a|101\rangle+b|010\rangle\big)\otimes|10\rangle\)</span></td>
<td><span class="math inline">\(p^2(1-p)\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\big(a|011\rangle+b|100\rangle\big)\otimes|11\rangle\)</span></td>
<td><span class="math inline">\(p^2(1-p)\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\big(a|111\rangle+b|000\rangle\big)\otimes|00\rangle\)</span></td>
<td><span class="math inline">\(p^3\)</span></td>
</tr>
</tbody>
</table>
<p>Visos įmanomos ancilų kubitų būsenos, šiuo
atveju keturios skirtingos, yra vadinamos <strong>klaidos sindromais</strong>
(angl. <em>error syndrome</em>). <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#tab:klaidos-sindromai">9.1</a> lentelė nusako visas apvertimo
klaidas kartu su atitinkamomis būsenomis ir tikimybėmis šią būseną
rasti.</p>
<p>Pagal sindromo būseną, yra pritaikomi Pauli-<span class="math inline">\(X\)</span> loginiai vartai
pažeistam kubitui ir taip ištaisoma bito apvertimo klaida:
<span class="math inline">\(|11\rangle\rightarrow X\otimes I\otimes I\)</span>,
<span class="math inline">\(|10\rangle\rightarrow I\otimes X\otimes I\)</span>,
<span class="math inline">\(|01\rangle\rightarrow I\otimes I\otimes X\)</span>,
tačiau nieko nedaroma radus
<span class="math inline">\(|00\rangle\rightarrow I\otimes I\otimes I\)</span>. Tai
atliekama naudojant parodytus klasiškai kontroliuojamus loginius vartus,
pritaikytus pažeistam kubitui. Šio algoritmo pabaigoje, pagal
skaičiavimų paskirtį, galima atlikti dekodavimo žingsnį
<span class="math inline">\(|\psi\rangle_L \rightarrow |\psi\rangle\otimes|00\rangle\)</span>,
kuris panaikina loginį kubitą ir palieka vieną fizinį kubitą
<span class="math inline">\(|\psi\rangle\)</span> būsenoje. Tai yra atliekama naudojant
kodavimo loginių vartų seką atvirkštine tvarka. Toliau panagrinėkime šio
3 kubitų kodo efektyvumą.</p>
<p>Tikimybė, kad trys pavieniai kubitai, nusiųsti per triukšmingą kvantinį
kanalą, neįgaus klaidos, yra <span class="math inline">\((1 - p)^3\)</span>. O štai kiekviena iš
būsenų, turinčių vieną klaidą, yra randama su tikimybe <span class="math inline">\(p(1 - p)^2\)</span>,
būsenos su dviem klaidomis yra <span class="math inline">\(p^2(1 - p)\)</span>, ir <span class="math inline">\(p^3\)</span> su trimis.
Sindromą nusakančios būsenos pradeda kartotis atsiradus dviem ir daugiau
klaidų. Tačiau dviejų ir trijų klaidų tikimybė yra daug mažesnė, jeigu
<span class="math inline">\(p\)</span> yra itin mažas. Bendra tikimybė, kad pateiktas trijų kubitų kodas
neveiks, yra visų kubitų dviejų ir trijų klaidų tikimybių suma
<span class="math inline">\(3p^2(1 - p) + p^3\)</span>, ir tai galima palyginti su tikimybe <span class="math inline">\(p\)</span>, kai
nėra naudojamas klaidų taisymo kodas. Pavyzdžiui, kai <span class="math inline">\(p = 0.1\)</span>,
nepataisomos klaidos tikimybė trijų kubitų kode yra <span class="math inline">\(10^2\)</span> kartų mažesnė,
o kai <span class="math inline">\(p = 0.01\)</span>, ji yra <span class="math inline">\(10^4\)</span> mažesnė. Šios tikimybės susilygina
kai <span class="math inline">\(p = 0.5\)</span>, todėl, kaip ir klasikiniame pavyzdyje, trijų kubitų
taisymo metodas suteiks pranašumo prieš pavienio kubito siuntimą
triukšmingu kanalu, jeigu <span class="math inline">\(p &lt; 0.5\)</span>.</p>
</div>
<div id="fazės-apvertimo-klaidos-aptikimas-ir-taisymas" class="section level2 hasAnchor" number="9.4">
<h2><span class="header-section-number">9.4</span> Fazės apvertimo klaidos aptikimas ir taisymas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fazės-apvertimo-klaidos-aptikimas-ir-taisymas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Bito ir fazės klaidų aptikimas ir taisymas yra glaudžiai susijęs.
Surinksime visą informaciją siekdami tai pademonstruoti.
<a href="kvantiniai-loginiai-vartai-grandines.html#kvantiniai-loginiai-vartai-grandines">4</a> skyriuje
matėme, kad Pauli-<span class="math inline">\(Z\)</span> loginius vartus galima išreikšti dviejų Hadamardo
ir Pauli-<span class="math inline">\(X\)</span> vartų sandauga, <span class="math inline">\(Z = HXH\)</span> bei <span class="math inline">\(X = HZH\)</span>. Hadamardo vartai,
veikdami Pauli-<span class="math inline">\(Z\)</span> bazinius vektorius transformuoja juos į Pauli-<span class="math inline">\(X\)</span>
bazinius vektorius:
<span class="math inline">\(H|0\rangle = |0_x \rangle\)</span>,
<span class="math inline">\(H|1\rangle = |1_x \rangle\)</span>. O pritaikę
šiems Pauli-<span class="math inline">\(Z\)</span> vartus randame:
<span class="math display" id="eq:pauli-z-ant-x-busenu">\[\begin{equation}
Z|0_x \rangle = |1_x \rangle\,,\quad Z|1_x \rangle = |0_x \rangle\,.
\tag{9.21}
\end{equation}\]</span>
Kitaip tariant, fazės apvertimo klaida
<span class="math inline">\(\{|0\rangle , |1\rangle\}\)</span> baziniuose
vektoriuose yra ne kas kita, kaip bito apvertimo klaida
<span class="math inline">\(\{|0_x \rangle , |1_x \rangle\}\)</span>
baziniuose vektoriuose. Tai reiškia, kad atitinkamai transformavę
3 kubitų bito apvertimo kodą galime jį panaudoti norėdami aptikti ir
taisyti fazės klaidas.</p>
<p>Siųsdami kubitus per triukšmingą kvantinį kanalą, kuriame atsiranda
fazės klaidos, kubito būseną <span class="math inline">\(|\psi\rangle\)</span> koduojame
dviem žingsniais. Pirmiausia, vėl „patrigubiname” bazinius vektorius:
<span class="math display" id="eq:baziniu-vektoriu-trigubinimas">\[\begin{equation}
|\psi\rangle = a|0\rangle + b|1\rangle \rightarrow a|000\rangle + b|111\rangle\,.
\tag{9.22}
\end{equation}\]</span>
Tolesniame žingsnyje pritaikome Hadamardo transformacijas kiekvienam iš
trijų kubitų:
<span class="math display" id="eq:h-kiekvienam-is-3">\[\begin{equation}
|\psi\rangle_L = H^{\otimes 3}\big(a|000\rangle + b|111\rangle\big)
= a|0_x 0_x 0_x \rangle + b|1_x 1_x 1_x \rangle\,.
\tag{9.23}
\end{equation}\]</span>
<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:grandine-loginio-paruosimui">9.3</a> pav. pateikiame grandinę,
iliustruojančią šio loginio kubito paruošimą.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:grandine-loginio-paruosimui"></span>
<img src="media/image9_4.svg" alt="Loginė grandinė, paruošianti loginį kubitą, skirtą taisyti fazės klaidai" width="31%" />
<p class="caption">
9.3 pav. Loginė grandinė, paruošianti loginį kubitą, skirtą taisyti fazės klaidai
</p>
</div>
<p>Atsiradusi fazės klaida, pavyzdžiui, pirmajame kodo kubite, pakeis
loginę būseną taip:
<span class="math display" id="eq:fazes-klaida-loginiame-kubite-1">\[\begin{equation}
|\psi\rangle_L \rightarrow a|1_x 0_x 0_x \rangle + b|0_x 1_x 1_x \rangle\,.
\tag{9.24}
\end{equation}\]</span>
Norėdami pritaikyti bito apvertimo klaidos aptikimo ir taisymo
algoritmą, turime pirmiausiai šią būseną transformuoti atgal į
<span class="math inline">\(\{|0\rangle , |1\rangle\}\)</span> bazinius
vektorius. Atlikę Hadamardo transformacijas pažeistai būsenai randame:
<span class="math display" id="eq:h-pazeistai-busenai">\[\begin{equation}
H^{\otimes 3}\big(a|1_x 0_x 0_x \rangle + b|0_x 1_x 1_x \rangle\big)
= a|100\rangle + b|011\rangle\,.
\tag{9.25}
\end{equation}\]</span>
Akivaizdu, kad šis fazės klaidų taisymo kodas turi identiškas
charakteristikas bito apvertimo kodui, tad anksčiau pateikta analizė
tinka ir čia.</p>
</div>
<div id="tolydžiosios-klaidos" class="section level2 hasAnchor" number="9.5">
<h2><span class="header-section-number">9.5</span> Tolydžiosios klaidos<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#tolydžiosios-klaidos" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Bendroje situacijoje 1 kubito klaidos gali kisti tolydžiai ir yra
nusakomos Blocho vektoriaus posūkio operatoriais <span class="math inline">\(R_x(\theta)\)</span>,
<span class="math inline">\(R_y(\theta)\)</span> ir <span class="math inline">\(R_z(\theta)\)</span> aplink <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> ir <span class="math inline">\(z\)</span> ašis kampu
<span class="math inline">\(\theta\)</span>. Pritaikykime tolydžiąją bito apvertimo klaidą
<span class="math inline">\(R_x(\theta)\otimes I\otimes I\)</span> pirmajam kubitui
<span class="math inline">\(|\psi\rangle_L\)</span> būsenoje 3 kubitų bito apvertimo
taisymo kode:
<span class="math display" id="eq:tolydi-bito-apvertimo-klaida">\[\begin{equation}
R_{x}(\theta)\otimes I\otimes I|\psi \rangle_L
= \cos(\theta/2)\big(a|000\rangle + b|111\rangle)
- \mathrm{i}\sin(\theta/2)\big(a|100\rangle + b|011\rangle\big)\,.
\tag{9.26}
\end{equation}\]</span>
Matome loginio kubito būseną, kuri yra klaidos nepaveiktos ir paveiktos
būsenos superpozicijoje. Kad aptiktume klaidą, vėl galime taikyti
<span class="math inline">\(Z\otimes Z\otimes I\)</span> ir <span class="math inline">\(Z\otimes I\otimes Z\)</span> operatorių
matavimus naudodami identišką grandinę su dviem ancila kubitais. Tai
atlikę randame:
<span class="math display" id="eq:tolydzios-klaidos-aptikimo-matavimas">\[\begin{equation}
\cos(\theta/2)\big(a|000\rangle + b|111\rangle\big)\otimes|00\rangle
- \mathrm{i}\sin(\theta/2)\big(a|100\rangle + b|011\rangle\big)\otimes|11\rangle\,.
\tag{9.27}
\end{equation}\]</span>
Ancilų nusakyta sindromo būsena <span class="math inline">\(|00 \rangle\)</span> yra supinta
su loginio kubito būsena, kuriai neįvyko klaida. O štai
<span class="math inline">\(|11\rangle\)</span> sindromo būsena yra supinta su kubitų
būsena, kuriai įvyko bito apvertimo klaida. Kaip ir anksčiau, darome
prielaidą, kad fizinis kubitas paveikiamas <span class="math inline">\(R_x(\theta)\)</span> klaidos
nepriklausomai nuo kitų kubitų su tikimybe <span class="math inline">\(p\)</span>. Atlikę ancilų kubitų
būsenų matavimą galime rasti sindromą <span class="math inline">\(|00\rangle\)</span> su
tikimybe <span class="math inline">\(p\cos^2(\theta/2)\)</span>, dėl kurio loginio kubito būsena lieka
nepažeista
<span class="math inline">\(|\psi \rangle_L = a|000\rangle + b|111\rangle\)</span>.
Sindromo būsena <span class="math inline">\(|11\rangle\)</span> randama su tikimybe
<span class="math inline">\(p\sin^2(\theta/2)\)</span>, o po matavimo loginio kubito būsena tampa
<span class="math inline">\(X\otimes I\otimes I|\psi\rangle_L = a|100\rangle + b|011\rangle\)</span>;
tai nusako bito apvertimo klaidą.</p>
<p>Klaidų tolydumą nusakantis faktorius <span class="math inline">\(\theta\)</span> atsiranda šalia
amplitudžių ir paveikia tik tikimybes rasti pažeistą ir nepažeistą
būsenas. Šiuo atveju, tikimybė rasti pažeistą būseną tampa
<span class="math inline">\(p \rightarrow p\sin^2(\theta/2)\)</span>. Atlikus ancilų kubitų matavimus <span class="math inline">\(\theta\)</span>
faktorius iškrinta, o bendra loginių kubitų ir ancilų būsena lieka
faktorizuojamoji. Radus
<span class="math inline">\(|a_1 a_2 \rangle = |00\rangle\)</span>
sindromą imtis veiksmų nereikia, o štai radus
<span class="math inline">\(|a_1 a_2 \rangle = |11\rangle\)</span>
pritaikomi <span class="math inline">\(X\otimes I\otimes I\)</span> loginiai vartai, ištaisantys
klaidą pirmame kubite
<span class="math inline">\((X\otimes I\otimes I)(X\otimes I\otimes I)|\psi\rangle_L \otimes|11\rangle = |\psi\rangle_L \otimes|11\rangle\)</span>.</p>
<p>Tai savo ruožtu demonstruoja itin svarbų teiginį, kad kvantinės klaidos
gali būti efektyviai diskretizuojamos, nors pačios būsenos gali kisti ir
tolydžiai. Tie patys metodai, taikomi taisyti diskrečiosioms kvantinėms
klaidoms, kurių yra tik trys rūšys {<span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span>, <span class="math inline">\(Z\)</span>}, kartu ištaiso ir
tolydžias klaidas.</p>
</div>
<div id="bendrieji-klaidų-taisymo-principai" class="section level2 hasAnchor" number="9.6">
<h2><span class="header-section-number">9.6</span> Bendrieji klaidų taisymo principai<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bendrieji-klaidų-taisymo-principai" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Šiame poskyryje pateikiame bendruosius principus, kurie įvardija, kokias
klaidas kodai gali ištaisyti, ir bendrą taisymo proceso principą.
Vadinkime kubitų klaidas nusakantį unitarųjį operatorių <span class="math inline">\(E\)</span>. Klaidų
operatorius, veikiantis <span class="math inline">\(n\)</span>-kubitų registrą, yra sudarytas iš
<span class="math inline">\(n\)</span> tenzorinių Pauli operatorių sandaugų sekos
<span class="math inline">\({E \in \{I,X,Y,Z\}}^{\otimes n}\)</span>. Kubitų bazinius vektorius
koduojančias būsenas vadinkime <span class="math inline">\(|i\rangle_L\)</span>. Pirma
būtina sąlyga, norint užtikrinti klaidų taisymą, reikalauja, kad klaidų
operatoriai, veikiantys skirtingas kodų būsenas, pakeistų jas į kitas,
ortogonaliąsias, klaidų būsenas. Tai galime užrašyti glaustai:
<span class="math display" id="eq:klaidu-busenu-ortogonalumas">\[\begin{equation}
\langle i| E_a^{\dagger} E_b |j\rangle_L = 0\,,\,\mathrm{jeigu}\, i \neq j\,.
\tag{9.28}
\end{equation}\]</span>
Jeigu skirtingų kodų būsenos <span class="math inline">\(|i\rangle_L\)</span> ir
<span class="math inline">\(|j\rangle_L\)</span> klaidų operatoriais yra pakeičiamos į
klaidų būsenas, kurios nėra ortogonalios kodų būsenoms ir kitoms klaidų
būsenoms, jos nebegali būti patikimai atskirtos, ir todėl taisymas tampa
neįmanomas. Šiuo atžvilgiu, klaidų operatoriai <span class="math inline">\(E\)</span> transformuoja kodo
būsenas iš kodo erdvės į vieną iš kodo erdvei ortogonalių klaidų būsenų
poerdvių.</p>
<p>Antroji sąlyga nusako, kad atliekant matavimą sindromui nustatyti gauta
informacija negali atskleisti koduojamos kubitų būsenos. Informacijos
atskleidimas bendrai paveikia kvantines būsenas ir atsitiktiniu būdu jas
negrąžinamai pakeičia. Šią sąlygą galima glaustai užrašyti:
<span class="math display" id="eq:informacijos-neatskleidimo-salyga">\[\begin{equation}
\langle i|E_a^{\dagger} E_b |i\rangle_L = c_{ab}\,.
\tag{9.29}
\end{equation}\]</span>
Vertė <span class="math inline">\(c_{ab}\)</span> negali priklausyti nuo būsenos
<span class="math inline">\(|i\rangle_L\)</span>, nes tai atskleistų apie ją informaciją.
Matavimo rezultatas gali priklausyti tik nuo klaidų operatorių <span class="math inline">\(E_a\)</span>
ir <span class="math inline">\(E_b\)</span>. Kubito apvertimo ir fazės klaidų aptikimo stadijoje matėme,
kad <span class="math inline">\(Z\otimes Z\otimes I\)</span> ir <span class="math inline">\(Z\otimes I\otimes Z\)</span>
operatorių matavimai leidžia identifikuoti kubitų būsenų lyginumą,
tačiau neatskleidžia informacijos, kokios tai būsenos, tai yra jų
amplitudžių. Jeigu minėtos dvi sąlygos yra užtikrintos, tada <span class="math inline">\(E_a\)</span> ir
<span class="math inline">\(E_b\)</span> priklauso ištaisomų klaidų operatorių rinkiniui,
<span class="math inline">\(\varepsilon \subseteq \{ I,X,Y,Z\}^{\otimes n}\)</span>.</p>
<p>Siekdami iliustruoti bendrą klaidų taisymo principą, imkime išplėstinę
sistemą, sudarytą iš <span class="math inline">\(n\)</span> kubitų registro <span class="math inline">\(|\psi\rangle\)</span>,
aplinkos sistemos būsenų <span class="math inline">\(|e\rangle\)</span> ir pradinio
ancilos kubito būsenoje <span class="math inline">\(|0\rangle\)</span>:
<span class="math display" id="eq:isplestines-sistemos-busena">\[\begin{equation}
|\Psi\rangle = |\psi\rangle\otimes|e\rangle\otimes|0\rangle\,.
\tag{9.30}
\end{equation}\]</span>
Šioje stadijoje kubitų registras yra veikiamas klaidų operatoriaus
<span class="math inline">\(E_i\)</span> ir supinamas su aplinkos būsenomis. Toliau atliekame unitariąją
transformaciją <span class="math inline">\(U\)</span>, supinančią ir ancilos kubitą:
<span class="math display" id="eq:registro-aplinkos-ancilos-supynimas">\[\begin{equation}
U|\Psi\rangle = \sum_{E_i \in \varepsilon} E_i|\psi\rangle\otimes|e_i \rangle\otimes|a_i \rangle\,.
\tag{9.31}
\end{equation}\]</span>
Siekiant identifikuoti ir atstatyti kodą, yra atliekama
<span class="math inline">\(U|\Psi\rangle\)</span> būsenos projekcija į vieną iš
ortogonaliųjų klaidų poerdvių. Tai matėme bito ir fazės apvertimo klaidų
taisyme, kuriuose ancilos kubitai yra supinami su klaidų būsenomis ir
atliekamas projekcinis matavimas. Dėl tokios priežasties superpozicija
yra sugriaunama ir ši būsena, su tam tikra tikimybe, pasikeičia į vieną
iš galimų:
<span class="math display" id="eq:galima-busena-po-matavimo">\[\begin{equation}
E_i|\psi\rangle\otimes|e_i \rangle\otimes|a_i \rangle\,.
\tag{9.32}
\end{equation}\]</span>
Atkreipiame dėmesį, kad šioje stadijoje kubitų registro būsena
<span class="math inline">\(E_i|\psi\rangle\)</span> yra nebesupinta nei su aplinkos, nei
su ancilų sistemų būsenomis. Tad norint atstatyti koduotą būseną yra
pritaikomas atvirkštinis klaidos operatorius <span class="math inline">\(E_i^{\dagger}\)</span>, nes
<span class="math inline">\(E_i^{\dagger}E_i|\psi\rangle = |\psi\rangle\)</span>.</p>
</div>
<div id="kvantinė-hamingo-riba" class="section level2 hasAnchor" number="9.7">
<h2><span class="header-section-number">9.7</span> Kvantinė Hamingo riba<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinė-hamingo-riba" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Siekdami ištaisyti vieno tipo klaidą 1 kubito registre naudojome
3 kubitų kodą. Kyla natūralus klausimas, ar galima rasti kriterijų,
pasakantį, kiek minimaliai reikia fizinių kubitų siekiant ištaisyti
<span class="math inline">\(n\)</span> kubitų dydžio registrą, kuriame atsiranda daugiausia <span class="math inline">\(t\)</span> skaičius
klaidų. Tai iš principo leistų ieškoti optimalaus kodo dydžio,
neeikvojančio papildomų fizinių kubitų.</p>
<p><strong>Kvantinė Hamingo riba</strong> (angl. <em>quantum Hamming bound</em>) suteikia būdą
tai įvertinti klasei kodų, kurie yra lietuviškai vadinami
<strong>neišsigimusiais</strong> (angl.<em> non-degenerate</em>). Neišsigimusiuose koduose
su kiekvienu skirtingu sindromu galima susieti unikalų kubitą, kuriame
įvyko klaida, ir nusakyti klaidos tipą. Klasikiniuose koduose visos
klaidos yra neišsigimusios, išsigimusios atsiranda išskirtinai
kvantinėje terpėje. Platesnės analizės, apimančios išsigimusius kodus,
šios knygos rašymo metu dar nėra, ir lieka išsiaiškinti, ar
išsigimusieji kodai gali būti efektyvesni negu neišsigimusieji ir
įveikti kvantinę Hamingo ribą.</p>
<p>Siekdami išvesti Hamingo ribą pirmiausia įvertinsime, kiek dominančio
kodo dydyje egzistuoja skirtingų klaidų. Pirmiausiai, egzistuoja
<span class="math inline">\(\binom{n}{j}\)</span> skirtingų konfigūracijų, nusakančių, kuriuose
<span class="math inline">\(j\)</span> skaičiuje kubitų iš esamų <span class="math inline">\(n\)</span> kubitų įvyko klaida. Čia
<span class="math inline">\(\binom{n}{j} = n!/j!(n - j)!\)</span> yra kombinatorinis skaičius. Kiekvienam
kubitui yra galimos trys skirtingos klaidos, nusakomos {<span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span>, <span class="math inline">\(Z\)</span>}
operatoriais, tad skaičius <span class="math inline">\(N(t)\)</span> klaidų iš viso yra:
<span class="math display" id="eq:bendras-klaidu-skaicius">\[\begin{equation}
N(t) = \sum_{j = 0}^t 3^j\binom{n}{j}\,.
\tag{9.33}
\end{equation}\]</span>
Suma indeksuojama skaičiais <span class="math inline">\(j\)</span> ir kinta nuo 0 (nėra klaidų) iki
didžiausio skaičiaus klaidų <span class="math inline">\(t\)</span>, kai <span class="math inline">\(t &lt; n\)</span>. Pavyzdžiui,
<span class="math inline">\(\binom{3}{2}\)</span> nusako, kad trijuose kubituose galimos dvi klaidos.
Dviejų klaidų išsidėstymo skaičius tarp trijų kubitų, neskaičiuojant
skirtingo tipo klaidų, yra iš viso trys (<span class="math inline">\(k_1{-}k_2\)</span>, <span class="math inline">\(k_1{-}k_3\)</span>,
<span class="math inline">\(k_2{-}k_3\)</span>). Atsižvelgdami į tai, kad kiekviename iš kubitų gali būti
viena iš trijų skirtingų klaidų, randame <span class="math inline">\(N(2) = 3^2\times 3 = 27\)</span> galimų
klaidų konfigūracijų.</p>
<p>Sakykime, kad turime <span class="math inline">\(k\)</span> skaičių loginių kubitų, kurie yra koduojami
naudojant <span class="math inline">\(n\)</span> skaičių fizinių kubitų. Loginiai kubitai dengia
<span class="math inline">\(2^k\)</span> dimensijų vektorių erdvę, ir visos jos būsenos gali būti
išreikštos <span class="math inline">\(2^k\)</span> baziniais kodo vektoriais
<span class="math inline">\(|i\rangle_L\)</span>. Pavyzdžiui, vieno loginio kubito
Hilberto erdvė yra 2 dimensijų ir dengiama
<span class="math inline">\(|0\rangle_L\)</span> bei <span class="math inline">\(|1\rangle_L\)</span>.
Ankstesniame poskyryje minėjome, kad taisytinų klaidų pirmoji sąlyga
reikalauja, jog klaidų operatoriai, veikdami kodo būsenas, pakeistų jas
į viena kitai ortogonalias klaidų būsenas. Taip pat kodo būsenos,
paveiktos skirtingo klaidų operatoriaus, <span class="math inline">\(E_a\)</span>, turi būti ortogonalios
toms paveiktoms <span class="math inline">\(E_b\)</span>. Tad kiekvienai skirtingai klaidai turi būti
priskiriamas <span class="math inline">\(2^k\)</span> dimensijų poerdvis. Kadangi yra <span class="math inline">\(N(t)\)</span> skaičius
skirtingų klaidų konfigūracijų (ir todėl toks pat skaičius klaidų
operatorių), erdvės dimensija, talpinanti visas ortogonaliąsias klaidų
būsenas (įskaitant klaidų nepažeistą būseną), turi būti bent <span class="math inline">\(N(t)2^{k}\)</span>
dydžio. Tai nusako minimalų <span class="math inline">\(n\)</span> fizinių kubitų, koduojančių <span class="math inline">\(k\)</span> loginius
kubitus, dimensijos dydį <span class="math inline">\(2^n\)</span>. Hamingo riba randama:
<span class="math display" id="eq:hamingo-riba">\[\begin{equation}
\sum_{j = 0}^t 3^j \binom{n}{j}2^k \leq 2^n\,.
\tag{9.34}
\end{equation}\]</span>
Pavyzdžiui, <span class="math inline">\(k\)</span> loginių kubitų, kuriems leidžiama tik viena
(<span class="math inline">\(t = 1\)</span>) bendrojo tipo kvantinė klaida, ši nelygybė yra:
<span class="math display" id="eq:hamingo-riba-vienai-klaidai">\[\begin{equation}
(1 + 3n)2^k \leq 2^n\,.
\tag{9.35}
\end{equation}\]</span>
Galima patikrinti, kiek reikia minimaliai fizinių kubitų siekiant
koduoti 1 loginį kubitą, kuriam leidžiama viena bendrojo tipo klaida.
Šiuo atveju <span class="math inline">\(k = t = 1\)</span> ir Hamingo riba nusako, kad <span class="math inline">\(n = 5\)</span> suteikia
lygybę. Tad neegzistuoja neišsigimusis kodas, kuris, koduodamas vieną
loginį kubitą mažiau nei penkiuose fiziniuose kubituose, galėtų
apsaugoti nuo visų galimų klaidų viename kubite.</p>
<p>Kadangi ne visi kodai yra neišsigimusieji, kvantinę Hamingo ribą galima
taikyti veikiau kaip pirminį įvertinimą. Egzistuoja ir kitų kvantinių
kodų ribų apibrėžimų, pavyzdžiui, kvantinė Singltono riba
(angl. <em>quantum Singleton bound</em>) tinka abejoms kodų klasėms. Jos
įrodymo čia nepateiksime, tačiau nelygybė yra:
<span class="math display" id="eq:singleton-riba">\[\begin{equation}
n - k \geq 4t\,.
\tag{9.36}
\end{equation}\]</span>
Simboliai <span class="math inline">\(n\)</span> ir <span class="math inline">\(k\)</span> nusako fizinių ir loginių kubitų skaičių,
atitinkamai, taip pat didžiausią klaidų paveiktų kubitų skaičių <span class="math inline">\(t\)</span>.
Matome, kad mažiausias kubitų skaičius, kai <span class="math inline">\(k = t = 1\)</span>, yra <span class="math inline">\(n = 5\)</span> ir
atitinka Hamingo ribą neišsigimusiems kodams. Šis optimalus kodas gali
būti užrašomas <span class="math inline">\([n, k, t] = [5, 1, 1]\)</span>.</p>
</div>
<div id="šoro-9-kubitų-kodas" class="section level2 hasAnchor" number="9.8">
<h2><span class="header-section-number">9.8</span> Šoro 9 kubitų kodas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#šoro-9-kubitų-kodas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Šoro 9 kubitų kodas yra vienas iš pirmųjų atrastų kodų, leidžiančių
ištaisyti bet kuriame iš 9 kubitų vieną bendriausio tipo kvantinę
klaidą. Taikant viršuje minėtą susitarimą, tai formaliai yra
<span class="math inline">\([n, k, t] = [9, 1, 1]\)</span> kodas. Šoro kodas naudoja dviejų lygių
konkatenaciją. Pirmajame žingsnyje įvykdomas 3 kubitų kodavimas,
naudojamas apsaugoti kubitus nuo fazės apvertimo klaidos,
<span class="math inline">\(|0\rangle \rightarrow |0_x 0_x 0_x \rangle\)</span>,
<span class="math inline">\(|1\rangle \rightarrow |1_x 1_x 1_x \rangle\)</span>.
Antrajame žingsnyje kiekvienas iš šių 3 kubitų yra toliau koduojamas dar
3 kubitais, apsaugant juos nuo bito apvertimo klaidos:
<span class="math display" id="eq:antras-soro-zingsnis">\[\begin{equation}
|0_x \rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}} \rightarrow \frac{|000\rangle + |111\rangle}{\sqrt{2}}\,;\quad
|1_x \rangle = \frac{|0\rangle - |1\rangle}{\sqrt{2}} \rightarrow \frac{|000\rangle - |111\rangle}{\sqrt{2}}\,.
\tag{9.37}
\end{equation}\]</span>
Bendroje loginio kubito būsenoje
<span class="math inline">\(|\psi\rangle_L = a|0\rangle_L + b|1\rangle_L\)</span>
baziniai vektoriai yra:
<span class="math display" id="eq:shoro-loginis-1" id="eq:shoro-loginis-0">\[\begin{align}
|0\rangle_L = &amp; \frac{1}{\sqrt{8}}\big(|000\rangle + |111\rangle\big)
\otimes\big(|000\rangle + |111\rangle\big)
\otimes\big(|000\rangle + |111\rangle\big)\nonumber\\
\equiv &amp; |+\rangle\otimes|+\rangle\otimes|+\rangle\,;\tag{9.38}\\
|1\rangle_L = &amp; \frac{1}{\sqrt{8}}\big(|000\rangle - |111\rangle\big)
\otimes\big(|000\rangle - |111\rangle\big)
\otimes\big(|000\rangle - |111\rangle\big)\nonumber\\
\equiv &amp; |-\rangle\otimes|-\rangle\otimes|-\rangle\,.\tag{9.39}
\end{align}\]</span>
Kubitus sugrupavome į tris blokus ir, siekdami supaprastinti simboliką,
blokus pervadinome atitinkamai <span class="math inline">\(|+\rangle\)</span> ir
<span class="math inline">\(|-\rangle\)</span>. Grandinė atliekanti kodo paruošimą pateikta
<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:grandine-shoro-loginiam-kubitui">9.4</a> pav.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:grandine-shoro-loginiam-kubitui"></span>
<img src="media/image9_5.svg" alt="Šoro 9 kubitų kodo loginio kubito paruošimas" width="58%" />
<p class="caption">
9.4 pav. Šoro 9 kubitų kodo loginio kubito paruošimas
</p>
</div>
<p>Kaip ir 3 kubitų kode, aptikti atsirandančioms bito apvertimo klaidoms
pasitelkiami nelokalūs matavimai. Sakykime, kad atsiranda bito apvertimo
klaida pirmojo bloko pirmame kubite,
<span class="math inline">\(|+\rangle \rightarrow \big(|100\rangle + |011\rangle\big)\)</span>.
Klaidos aptikimui pirmajame bloke taikome <span class="math inline">\(Z_1\otimes Z_2\)</span> ir
<span class="math inline">\(Z_1\otimes Z_3\)</span> matavimus pasitelkdami du ancilų kubitus. Čia,
supaprastindami simboliką, praleidome vienetinių operatorių <span class="math inline">\(I\)</span> rašymą,
tad
<span class="math inline">\(Z_1\otimes Z_2 = Z\otimes Z\otimes I\otimes I\otimes I\otimes I\otimes I\otimes I\otimes I\)</span>
ir
<span class="math inline">\(Z_1\otimes Z_3 = Z\otimes I\otimes Z\otimes I\otimes I\otimes I\otimes I\otimes I\otimes I\)</span>.
Antrajame ir trečiajame bloke klaidos aptikimui analogiškai naudojamos
<span class="math inline">\(Z_4\otimes Z_5\)</span> ir <span class="math inline">\(Z_4\otimes Z_6\)</span>, taip pat
<span class="math inline">\(Z_7\otimes Z_8\)</span> ir <span class="math inline">\(Z_7\otimes Z_9\)</span> operatorių poros,
kurių vertės įrašomos į dar dvi poras ancilų kubitų. Tai leidžia
unikaliai nustatyti, kuriame iš 9 kubitų įvyko bito apvertimo klaida, ir
ją ištaisyti pritaikius atitinkamam kubitui Pauli-<span class="math inline">\(X\)</span> loginius vartus.</p>
<p>Jeigu atsiranda fazės klaida, pavyzdžiui, pirmojo bloko viename iš
kubitų, šio bloko būsena pakinta taip:
<span class="math display" id="eq:fazes-klaida-shoro-1" id="eq:fazes-klaida-shoro-0">\[\begin{align}
|0\rangle_L : &amp; \quad |000\rangle + |111\rangle\rightarrow |000\rangle - |111\rangle\,;\tag{9.40}\\
|1\rangle_L : &amp; \quad |000\rangle - |111\rangle\rightarrow |000\rangle + |111\rangle\,.\tag{9.41}
\end{align}\]</span>
Atkreipiame dėmesį, kad nesvarbu, kuris iš trijų kubitų bloke patiria
fazės klaidą, to bloko būsena pasikeičia lygiai taip pat. Tad
identifikuoti, kuris kubitas patyrė fazės klaidą, neįmanoma, ir dėl to
Šoro kodas yra formaliai išsigimęs. Įvykus klaidai pradinė būsena
<span class="math inline">\(|\psi\rangle_L\)</span> pasikeičia taip:
<span class="math display" id="eq:logine-busena-ivykus-klaidai">\[\begin{equation}
|\psi\rangle_L \rightarrow a|-\rangle\otimes|+\rangle\otimes|+\rangle
+ b|+\rangle\otimes|-\rangle\otimes|-\rangle\,.
\tag{9.42}
\end{equation}\]</span>
Vietoj pavienių kubitų bloke palyginimo, kaip daroma aptinkant bito
apvertimo klaidą, fazės apvertimo klaidos aptikimui tarpusavyje
palyginami patys blokai. Tam atlikti pasitelkiame irgi du ancilų
kubitus, į kuriuos užrašomi, šiuo atveju,
<span class="math inline">\(X_1\otimes X_2\otimes X_3\otimes X_4\otimes X_5\otimes X_6\)</span>
ir
<span class="math inline">\(X_1\otimes X_2\otimes X_3\otimes X_7\otimes X_8\otimes X_9\)</span>
operatorių matavimų rezultatai (praleidžiame vienetinių operatorių <span class="math inline">\(I\)</span>
rašymą likusiems kubitams). Kad tai būtų lengviau suprasti, atkreipiame
dėmesį, jog Šoro kodo būsenos
<span class="math inline">\(|+\rangle\otimes|+\rangle\otimes|+\rangle\)</span>
ir
<span class="math inline">\(|-\rangle\otimes|-\rangle\otimes|-\rangle\)</span>
yra šių operatorių tikriniai vektoriai su tikrinėmis vertėmis +1. Galime
išskaidyti šias tikrines vertes į dviejų pavienių blokų tikrinių verčių
sandaugas. Naudodami pirmąjį bloką kaip pavyzdį matome, kad individualių
blokų būsenos <span class="math inline">\(|+\rangle\)</span> ir
<span class="math inline">\(|-\rangle\)</span> yra trijų Pauli-<span class="math inline">\(X\)</span> tenzorių sandaugos
operatorių tikriniai vektoriai su tikrinėmis vertėmis <span class="math inline">\(\lambda = 1\)</span> ir
<span class="math inline">\(\lambda = -1\)</span>, atitinkamai:
<span class="math display" id="eq:bloko-busena-m1" id="eq:bloko-busena-p1">\[\begin{align}
X_1\otimes X_2\otimes X_3\big(|000\rangle + |111\rangle\big )
= &amp; |000\rangle + |111\rangle = |+\rangle\,;\tag{9.43}\\
X_1\otimes X_2\otimes X_3\big(|000\rangle - |111\rangle\big )
= &amp; -\big(|000\rangle - |111\rangle) = - |-\rangle\,.\tag{9.44}
\end{align}\]</span>
Tad bet kurių dviejų blokų būsenų, nepaveiktų klaidos, tikrinių verčių
sandauga yra visada +1.</p>
<p>Klaidų aptikimo procese, vadindami
<span class="math inline">\(X_1\otimes X_2\otimes X_3\)</span>,
<span class="math inline">\(X_4\otimes X_5\otimes X_6\)</span> ir
<span class="math inline">\(X_7\otimes X_8\otimes X_9\)</span> operatorių, veikiančių kiekvieną
iš trijų kubitų blokų, tikrines vertes atitinkamai <span class="math inline">\(\lambda_1\)</span>,
<span class="math inline">\(\lambda_2\)</span>, <span class="math inline">\(\lambda_3\)</span>, užrašysime jų porų sandaugas
<span class="math inline">\(\lambda_1 \lambda_2\)</span> ir <span class="math inline">\(\lambda_1 \lambda_3\)</span> į du ancilų
kubitus. Pirmasis minėtas operatorius patikrina pirmą ir antrą blokus, o
antrasis – pirmą ir trečią blokus. Jeigu viename iš blokų įvyksta fazės
klaida, tikrinė vertė pasikeičia į -1 ir todėl tikrinių verčių poros
sandauga tampa -1.</p>
<p>Norėdami realizuoti klaidų aptikimo procesą kvantinėje grandinėje,
pirmiausiai Pauli-<span class="math inline">\(X\)</span> operatorius perrašysime <span class="math inline">\(X = HZH\)</span>. Kad įvykdytume
<span class="math inline">\(X\)</span> operatorių matavimus, kiekvienam kubitui atliekame Hadamardo
transformacijas <span class="math inline">\(H^{\otimes 9}\)</span> ir Pauli-<span class="math inline">\(Z\)</span> matavimus, pasitelkdami
<span class="math inline">\(CNOT\)</span> vartus ir ancilos kubitą. Pirmų dviejų blokų palyginimui
matavimas
<span class="math inline">\(Z_1\otimes Z_2\otimes Z_3\otimes Z_4\otimes Z_5\otimes Z_6\)</span>
užrašomas ancilos būsenoje
<span class="math inline">\(|a_1 \rangle = |k_1\oplus k_2\oplus k_3\otimes k_4\oplus k_5\oplus k_6 \rangle\)</span>
naudojant <span class="math inline">\(\mod(2)\)</span> bitų sudėtį. Taip randame
<span class="math inline">\(|a_1 \rangle = |0\rangle\)</span>, jeigu
dviejų blokų būsenos yra vienodos, ir
<span class="math inline">\(|a_1 \rangle = |1\rangle\)</span>, jeigu jos
skiriasi. Tai savo ruožtu atspindi
<span class="math inline">\(X_1\otimes X_2\otimes X_3\otimes X_4\otimes X_5\otimes X_6\)</span>
operatoriaus <span class="math inline">\(\pm 1\)</span> tikrines vertes. Tas pats procesas atliekamas su
pirmojo ir trečiojo bloko matavimais naudojant
<span class="math inline">\(Z_1\otimes Z_2\otimes Z_3\otimes Z_7\otimes Z_8\otimes Z_9\)</span>.
Abiejų matavimų rezultatas užrašomas į dviejų ancilų kubitų būsenas
<span class="math inline">\(|a_1 a_2 \rangle\)</span>, o standartinis Pauli-<span class="math inline">\(Z\)</span> matavimas
leidžia unikaliai nusakyti, kuriame bloke įvyko fazės klaida.
Pavyzdžiui, fazės klaida loginio kubito pirmame bloke bus nusakyta šia
bendra būsena:
<span class="math display" id="eq:fazes-klaida-loginiame-kubite">\[\begin{equation}
\big(a|-\rangle\otimes|+\rangle\otimes|+\rangle
+ b|+\rangle\otimes|-\rangle\otimes|-\rangle\big)\otimes|11\rangle\,.
\tag{9.45}
\end{equation}\]</span>
Fazės klaida pirmajame bloke ištaisoma pritaikius
<span class="math inline">\(Z_1\otimes Z_2\otimes Z_3\)</span> loginius vartus. Galiausiai
atliekami dar vieni Hadamardo vartai <span class="math inline">\(H^{\otimes 9}\)</span> visiems kubitams
siekiant atstatyti būsenas į <span class="math inline">\(|+\rangle\)</span> ir
<span class="math inline">\(|-\rangle\)</span> kodų formą, o ancilos grąžinamos į
<span class="math inline">\(|00 \rangle\)</span>.</p>
<p>Šoro kodas gali ištaisyti bendriausio tipo klaidą. Tai išplaukia iš šio
skyriaus <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#supynimas-ir-klaidu-atsiradimas">9.2</a> poskyryje
pateikto įrodymo, kad visas klaidas galima
išreikšti Pauli operatorių <span class="math inline">\(\{I, X, Y, Z\}\)</span> ir jų tenzorinių sandaugų
tiesinėmis kombinacijomis. Todėl gebant taisyti <span class="math inline">\(X\)</span> (bito apvertimo) ir
<span class="math inline">\(Z\)</span> (fazės apvertimo) klaidas, Šoro kode automatiškai galima taisyti ir
šių dviejų klaidų kombinaciją, <span class="math inline">\(XZ = -\mathrm{i}Y.\)</span> Šoro kodas bus efektyvus,
jeigu atsiranda ne daugiau nei viena klaida 9 kubituose. Tikimybė, kad
siunčiant loginį kubitą per triukšmingą kanalą nė vienas fizinis kubitas
nebus pažeistas, yra <span class="math inline">\((1 - p)^9\)</span>. Čia <span class="math inline">\(p\)</span> nusako tikimybę, kad
fizinis kubitas patirs klaidą. Tikimybė, kad Šoro kode įvyks viena
klaida, yra <span class="math inline">\(9p(1 - p)^8\)</span>, ir kodas leidžia ją ištaisyti. Tad dvi ar
daugiau klaidų atsitiks su tikimybe
<span class="math inline">\(1 - 9p(1 - p)^8 - (1 - p)^9 \approx 36p^2\)</span>, jeigu <span class="math inline">\(p\)</span> yra
itin mažas. Palyginus su pavieniu fizinio kubito siuntimu, nepataisomų
klaidų tikimybės susilygina, kai <span class="math inline">\(p \approx 0.032,\)</span> ir Šoro kodas
suteikia didėjantį pranašumą toliau mažėjant <span class="math inline">\(p\)</span>.</p>
</div>
<div id="kodu-stabilizatoriai-poskyris" class="section level2 hasAnchor" number="9.9">
<h2><span class="header-section-number">9.9</span> Kodų stabilizatoriai<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kodu-stabilizatoriai-poskyris" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Iki šiol analizavome klaidų taisymo kodus pradėdami nuo kodų būsenų.
Idealiai, norėtume turėti sisteminį receptą, leidžiantį sugeneruoti kodą
su mus dominančiomis savybėmis – fizinių ir loginių kubitų skaičiumi,
ištaisomų klaidų skaičiumi ir juose naudojamais operatoriais aptikti ir
taisyti klaidas. <strong>Kodų stabilizatorių</strong> (angl. <em>code stabilizers</em>)
formalizmas atlieka šią funkciją ir yra plačiai taikomas kvantinėje
kompiuterijoje. Egzistuoja taisyklės, kaip stabilizatorių kodams
konstruoti kvantines grandines, paruošiančias kodų būsenas, aptinkančias
ir taisančias klaidas, taip pat leidžiančias lengviau formuluoti
klaidoms atsparius skaičiavimus. Kodų stabilizatorių algoritmai gali
būti realizuojami vien tik Klifordo grupės loginiais vartais {<span class="math inline">\(H\)</span>, <span class="math inline">\(S\)</span>,
<span class="math inline">\(cX\)</span>}, todėl jų veikimą galima efektyviai modeliuoti ir testuoti
klasikiniais kompiuteriais. Toliau glaustai pristatome šios plačios kodų
grupės įvadinius principus.</p>
<p>Kodų stabilizatorių formalizmas yra pagrįstas ne kvantinių būsenų, o
unitariųjų operatorių analize pasitelkiant <strong>grupių teoriją</strong>
(angl. <em>group theory</em>). Sakoma, kad būsena
<span class="math inline">\(|\psi\rangle\)</span> yra stabilizuojama operatoriaus <span class="math inline">\(K\)</span>,
jeigu ji yra šio operatoriaus tikrinis vektorius su +1 tikrine verte:
<span class="math display" id="eq:busena-stabilizuojama-op-K">\[\begin{equation}
K|\psi \rangle = |\psi\rangle\,.
\tag{9.46}
\end{equation}\]</span>
Pavyzdžiui, 1 kubito būsena <span class="math inline">\(|0\rangle\)</span> yra
stabilizuojama Pauli-<span class="math inline">\(Z\)</span> operatoriaus, nes
<span class="math inline">\(Z|0\rangle = |0\rangle\)</span>. Šoro 9 kubitų
kodas yra taip pat stabilizatorių klasės kodas. Aštuoni operatoriai
<span class="math inline">\(Z_1\otimes Z_2\)</span>, <span class="math inline">\(Z_1\otimes Z_3\)</span>,
<span class="math inline">\(Z_4\otimes Z_5\)</span>, <span class="math inline">\(Z_4\otimes Z_6\)</span>,
<span class="math inline">\(Z_7\otimes Z_8\)</span>, <span class="math inline">\(Z_7\otimes Z_9\)</span> bei
<span class="math inline">\(X_1\otimes X_2\otimes X_3\otimes X_4\otimes X_5\otimes X_6\)</span>
ir
<span class="math inline">\(X_1\otimes X_2\otimes X_3\otimes X_7\otimes X_8\otimes X_9\)</span>
yra jo stabilizatoriai.</p>
<p>Apžvelgdami operatorių savybes stabilizuojančių <span class="math inline">\(n\)</span>-kubitų būsenas,
pirmiausiai apibūdiname 1 kubito Pauli grupę <span class="math inline">\(\mathcal{P}\)</span>, kuri yra
sudaryta iš Pauli operatorių:
<span class="math display" id="eq:pauli-grupe">\[\begin{equation}
\mathcal{P} = \{\pm I\,, \pm \mathrm{i}I\,, \pm X\,, \pm \mathrm{i}X\,, \pm Y, \pm \mathrm{i}Y\,, \pm Z, \pm \mathrm{i}Z\, \}\,.
\tag{9.47}
\end{equation}\]</span>
Pauli elementų rinkinys (Pauli operatoriai kartu su juos dauginančiais
skaičiais {<span class="math inline">\(\pm 1\)</span>, <span class="math inline">\(\pm \mathrm{i}\)</span>}) formuoja grupę operatorių sandaugos
operacijų atžvilgiu. Pauli grupė pratesiama <span class="math inline">\(n\)</span> kubitų sistemoms
naudojant jos elementų <span class="math inline">\(n\)</span> tenzorių sandaugą,
<span class="math inline">\(\mathcal{P}^{\otimes n}\)</span>. Galima parodyti, kad visi Pauli grupės
elementai yra tarpusavyje arba komutatyvūs, arba antikomutatyvūs.
Primename, kad du komutatyvūs operatoriai <span class="math inline">\(A\)</span> ir <span class="math inline">\(B\)</span> tenkina <span class="math inline">\(AB=BA\)</span>, ir
tai standartiškai užrašoma <span class="math inline">\(\lbrack A,B\rbrack = 0\)</span>. Tačiau <span class="math inline">\(A\)</span> ir <span class="math inline">\(B\)</span>
yra antikomutatyvūs, jeigu sandaugoje sukeitus jų vietas atsiranda
minuso ženklas, <span class="math inline">\(AB = -BA\)</span>. Tai išreiškiama
<span class="math inline">\(\{A, B\} = AB + BA = 0\)</span>. <span class="math inline">\(N\)</span> kubitų stabilizatorių būsena
<span class="math inline">\(|\psi\rangle\)</span> yra nusakoma Pauli grupės
<span class="math inline">\(\mathcal{P}^{\otimes n}\)</span> operatorių pogrupe
<span class="math inline">\(\mathcal{G}^{\otimes n}\)</span>, kurios visi elementai, vadinkime juos
<span class="math inline">\(K_i\)</span>, yra tarpusavyje komutatyvūs. Operatorių pogrupės
<span class="math inline">\(\mathcal{G}^{\otimes n}\)</span> savybes galima glaustai užrašyti taip:
<span class="math display" id="eq:op-pogrupio-savybes">\[\begin{equation}
\mathcal{G}^{\otimes n} = \big\{K_i|\psi\rangle = |\psi\rangle\,,
\lbrack K_i,K_j \rbrack = 0\,, \forall(i,j)\big\} \subset \mathcal{P}^{\otimes n}\,.
\tag{9.48}
\end{equation}\]</span>
Stabilizatorių tarpusavio komutatyvumas užtikrina, kad ir jų sandauga
<span class="math inline">\(K_1 K_2 K_3\cdots\)</span> taip pat stabilizuoja
<span class="math inline">\(|\psi\rangle\)</span>. Praktiškai taip pat reikalaujame, kad
stabilizatorių rinkinyje visi operatoriai būtų tiesiškai
nepriklausomi – negali būti išreikšti kitų rinkinio stabilizatorių
sandauga.</p>
<p>Stabilizatoriai <span class="math inline">\(K_i\)</span> efektyviai užfiksuoja dalį <span class="math inline">\(n\)</span> kubitų
<span class="math inline">\(2^n\)</span> dimensijų vektorių erdvės, kitaip tariant, jos poerdvį, kuriame
atliekamas būsenų kodavimas. Imkime 2 kubitų pavyzdį, kai naudojamas
Belo bazinių vektorių rinkinys {<span class="math inline">\(|\chi^{+}\rangle\)</span>,
<span class="math inline">\(|\chi^{-}\rangle\)</span>, <span class="math inline">\(|\eta^{+}\rangle\)</span>,
<span class="math inline">\(|\eta^{-}\rangle\)</span>}. Galima lengvai patikrinti, kad
operatorius <span class="math inline">\(X\otimes X\)</span> unikaliai stabilizuoja
<span class="math inline">\(|\chi^{+}\rangle\)</span> ir <span class="math inline">\(|\eta^{+}\rangle\)</span>
būsenas. Tad, jeigu naudosime poerdvį, stabilizuotą <span class="math inline">\(X\otimes X\)</span>,
šias dvi 2 kubitų ortogonaliąsias būsenas galime naudoti formuodami
vieną loginį kubitą:
<span class="math display" id="eq:poerdvis-stabilizuotas-x-x">\[\begin{equation}
|0\rangle_L = \frac{1}{\sqrt{2}}\big(|00\rangle + |11\rangle\big)\quad
\mathrm{ir}\quad
|1\rangle_L = \frac{1}{\sqrt{2}}\big(|01\rangle + |10\rangle\big)\,.
\tag{9.49}
\end{equation}\]</span>
Taip 4 dimensijų erdvę sumažinome iki 2 dimensijų, kuri nusako vieno
kubito būsenas. Šioje erdvėje operatorius <span class="math inline">\(Z\otimes Z\)</span> leidžia
atskirti <span class="math inline">\(|0\rangle_L\)</span> ir
<span class="math inline">\(|1\rangle_L\)</span> vieną nuo kitos, nes
<span class="math inline">\(Z\otimes Z|0\rangle_L = |0\rangle_L\)</span>
ir
<span class="math inline">\(Z\otimes Z|1\rangle_L = -|1\rangle_L\)</span>.
Jis atlieka loginio Pauli-<span class="math inline">\(Z\)</span> rolę, žymimą su brūkšniu,
<span class="math inline">\(\bar{Z} = Z\otimes Z\)</span>. Žinoma, galėtume pasirinkti ir
<span class="math inline">\(Z\otimes Z\)</span> operatorių, stabilizuojantį
<span class="math inline">\(|\chi^{+}\rangle\)</span> ir <span class="math inline">\(|\chi^{-}\rangle\)</span>
būsenas, ir naudoti jas formuodami loginį kubitą. Tada loginis Pauli-<span class="math inline">\(Z\)</span>
būtų <span class="math inline">\(\bar{Z} = X\otimes X\)</span> ir leistų atskirti šio loginio
kubito <span class="math inline">\(|0\rangle_L\)</span> ir
<span class="math inline">\(|1\rangle_L\)</span> būsenas. Bendrai, jeigu <span class="math inline">\(n\)</span> kubitų koduoja <span class="math inline">\(k\)</span> loginių kubitų,
tada yra <span class="math inline">\(k\)</span> loginių Pauli-<span class="math inline">\(Z\)</span>, <span class="math inline">\(n - k\)</span> stabilizatorių, o loginių kubitų vektorių
erdvės dimensija <span class="math inline">\(2^{n - k}\)</span>. Toks stabilizatorių kodas yra glaustai
indikuojamas skliausteliuose <span class="math inline">\([n, k]\)</span>.</p>
<p>Kiekvienas stabilizatorius <span class="math inline">\(K_i\)</span> yra ermitinis ir tuo pačiu unitarusis
operatorius, todėl gali turėti dvi tikrines vertes, <span class="math inline">\(\lambda = 1\)</span> ir
<span class="math inline">\(\lambda = -1\)</span>. Klaidų operatoriai <span class="math inline">\(\{E_i\}\)</span> taip pat priklauso Pauli
grupės operatoriams, <span class="math inline">\(\mathcal{P}^{\otimes n}\)</span>. Todėl bet kuris <span class="math inline">\(E\)</span>
gali būti komutatyvusis arba antikomutatyvusis su tam tikru
stabilizatoriumi <span class="math inline">\(K\)</span> dominančioje <span class="math inline">\(n\)</span> kubitų erdvėje. Jeigu <span class="math inline">\(E\)</span> ir <span class="math inline">\(K\)</span>
yra komutatyvieji, tada:
<span class="math display" id="eq:e-komutuoja-su-k">\[\begin{equation}
KE|\psi\rangle = EK|\psi\rangle = E|\psi\rangle\,.
\tag{9.50}
\end{equation}\]</span>
Tad klaidos operatorius išsaugo <span class="math inline">\(K\)</span> stabilizatoriaus +1 tikrinę vertę.
Tačiau, jeigu <span class="math inline">\(E\)</span> ir <span class="math inline">\(K\)</span> yra antikomutatyvieji:
<span class="math display" id="eq:e-antikomutuoja-su-k">\[\begin{equation}
KE|\psi\rangle = - EK|\psi\rangle = - E|\psi\rangle\,.
\tag{9.51}
\end{equation}\]</span>
Tai galime interpretuoti kaip stabilizatorių <span class="math inline">\(K\)</span>, veikiantį klaidos
paveiktą
<span class="math inline">\(E|\psi\rangle = |\psi\rangle_E\)</span> kodo
būseną,
<span class="math inline">\(K|\psi\rangle_E = - |\psi\rangle_E\)</span>;
tai galiausiai pakeičia stabilizatoriaus tikrinę vertę į -1. Ši tikrinė
vertė gali būti aptikta atlikus stabilizatoriaus matavimą siekiant
taisyti klaidas. Kaip matėme Šoro 9 kubitų kode, jo stabilizatorių porų
kombinacijų matavimas ir rastų tikrinių verčių kombinacijos
<span class="math inline">\(\{ \pm 1, \pm 1 \}\)</span> leidžia identifikuoti klaidą. Mat dalis kodo
stabilizatorių yra antikomutatyvieji su specifiniais klaidų
operatoriais, ir jų unikali kombinacija leidžia nustatyti, kokie klaidų
operatoriai veikė kodo būsenas.</p>
<p>Formaliai <span class="math inline">\(h\)</span> stabilizatorių turi <span class="math inline">\(2^h\)</span> skirtingas
<span class="math inline">\(\{\lambda_i, \lambda_j\}\)</span> kombinacijas ir todėl gali identifikuoti
tokį skaičių skirtingų klaidų būsenų (įskaitant nepažeistą būseną).
Pavyzdžiui, 1 loginio kubito, apsaugoto nuo vienos bendriausios klaidos
5 kubitų kode <span class="math inline">\([5,1,1]\)</span>, Hamingo riba yra <span class="math inline">\(1 + 3 \cdot 5 \geq 2^4\)</span>.
Keturi stabilizatoriai identifikuoja <span class="math inline">\(2^4= 16\)</span> ortogonaliuosius
2 dimensijų klaidų būsenų poerdvius ir todėl suteikia lygybę Hamingo
riboje. Šio optimalaus 5 kubitų kodo stabilizatoriai yra:
<span class="math display" id="eq:5-kubitu-stabilizatoriai-4" id="eq:5-kubitu-stabilizatoriai-3" id="eq:5-kubitu-stabilizatoriai-2" id="eq:5-kubitu-stabilizatoriai-1">\[\begin{align}
K_1 = &amp; X\otimes Z\otimes Z\otimes X\otimes I\,;\tag{9.52} \\
K_2 = &amp; I\otimes X\otimes Z\otimes Z\otimes X\,;\tag{9.53} \\
K_3 = &amp; X\otimes I\otimes X\otimes Z\otimes Z\,;\tag{9.54} \\
K_4 = &amp; Z\otimes X\otimes I\otimes X\otimes Z\,.\tag{9.55}
\end{align}\]</span>
Atkreipiame dėmesį, kad cikliškai pakeistas operatorius
<span class="math inline">\(K_5 = Z\otimes Z\otimes X\otimes I\otimes X\)</span> nėra
tiesiškai nepriklausomas, nes gali būti išreikštas sandauga,
<span class="math inline">\(K_5 = K_1 K_2 K_3 K_4\)</span>. Penktasis operatorius,
<span class="math inline">\(\bar{Z} = Z\otimes Z\otimes Z\otimes Z\otimes Z\)</span>, yra
komutatyvus su keturiais šio kodo stabilizatoriais ir atlieka loginio
Pauli-<span class="math inline">\(Z\)</span> vaidmenį. Taip pat yra apibūdinamas ir loginis Pauli-<span class="math inline">\(X\)</span>
operatorius,
<span class="math inline">\(\bar{X} = X\otimes X\otimes X\otimes X\otimes X\)</span>,
kuris konvertuoja logines būsenas vieną tarp kitos
<span class="math inline">\(\bar{X}|0\rangle_L = |1\rangle_L\)</span>,
<span class="math inline">\(\bar{X}|1\rangle_L = |0\rangle_L\)</span>.</p>
<p>Toliau panagrinėkime, kaip sugeneruoti kodo būsenas iš pateiktų
stabilizatorių rinkinio. Kodo stabilizatoriai bei loginiai Pauli-<span class="math inline">\(Z\)</span> yra
unitariniai ir kartu ermitiniai operatoriai, tad turi dvi tikrines
vertes, +1 ir -1. Taikant spektrinę dekompoziciją, tokį <span class="math inline">\(n\)</span> kubitų
būsenas veikiantį operatorių <span class="math inline">\(K\)</span> galima užrašyti:
<span class="math display" id="eq:k-op-dekompozicija">\[\begin{equation}
K = \sum_{\lambda} \lambda P(\lambda) = P(1) - P(-1)\,.
\tag{9.56}
\end{equation}\]</span>
Pasitelkdami projekcinius operatorius <span class="math inline">\(P(1)\)</span> ir <span class="math inline">\(P(-1)\)</span> į vektorių
poerdvius, asocijuotus su +1 ir -1 tikrinėmis vertėmis, atitinkamai, bei
jų pilnumo savybę <span class="math inline">\(P(1) + P(-1) = I\)</span>, randame:
<span class="math display" id="eq:projekciniu-op-israiska-k">\[\begin{equation}
P(1) = \frac{I + K}{2}\,,\quad P(-1) = \frac{I - K}{2}\,.
\tag{9.57}
\end{equation}\]</span>
Bet kokią <span class="math inline">\(n\)</span> kubitų būseną
<span class="math inline">\(|\psi\rangle\)</span> galima išreikšti jos projekcijų į <span class="math inline">\(\pm 1\)</span>
stabilizatoriaus <span class="math inline">\(K\)</span> poerdvių būsenas superpozicija:
<span class="math display" id="eq:busena-kaip-k-poerdviu-superpozicija">\[\begin{equation}
|\psi\rangle = P(1)|\psi\rangle + P(-1)|\psi\rangle\,.
\tag{9.58}
\end{equation}\]</span>
Norint paruošti stabilizatorių rinkinio kodo būseną
<span class="math inline">\(|0\rangle_L\)</span>, užduotis yra atlikti pradinės registro
būsenos, standartiškai <span class="math inline">\(|0\rangle^{\otimes n}\)</span>,
projekciją į <span class="math inline">\(h\)</span> skaičiaus stabilizatorių rinkinio bendrą +1 poerdvį bei +1 loginio
Pauli-<span class="math inline">\(Z\)</span>. Jeigu, sakykime, turime tris tarpusavyje komutatyvius
ermitinius operatorius <span class="math inline">\(K_1, K_2, K_3\)</span>, tada projekcinis operatorius
į jų bendrą +1 poerdvį, nusakytą <span class="math inline">\(P(1)\)</span>, bus atitinkamai trijų
projekcinių operatorių sandauga, <span class="math inline">\(P(1) = P_1(1)P_2(1)P_3(1)\)</span>.
Norint paruošti <span class="math inline">\(|1\rangle_L\)</span>, projekcija atliekama į
+1 stabilizatorių poerdvį bei loginio Pauli-<span class="math inline">\(Z\)</span> -1 poerdvį.</p>
<p>Optimalaus <span class="math inline">\([5, 1, 1]\)</span> kodo atveju pradedame nuo
<span class="math inline">\(|00000\rangle\)</span> ir <span class="math inline">\(|11111\rangle\)</span>
registro būsenų, kurios yra <span class="math inline">\(\bar{Z}\)</span> tikriniai vektoriai su
<span class="math inline">\(\pm 1\)</span> tikrinėmis vertėmis, atitinkamai. Kodo būsenas (normuotąsias)
randame atlikdami projekciją į bendrą keturių stabilizatorių +1 poerdvį:
<span class="math display" id="eq:5-1-1-kodo-busena-1" id="eq:5-1-1-kodo-busena-0">\[\begin{align}
|0\rangle_L = &amp; \frac{1}{4}(I + K_1)\otimes(I + K_2)\otimes(I + K_3)\otimes(I + K_4)|00000\rangle\,;\tag{9.59}\\
|1\rangle_L = &amp; \frac{1}{4}(I + K_1)\otimes(I + K_2)\otimes(I + K_3)\otimes(I + K_4)|11111\rangle\,.\tag{9.60}
\end{align}\]</span>
Hadamardo testo kvantinė grandinė (žr. <a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamard-testas-poskyris">6.7.1</a> poskyrį) gali atlikti norimą projekciją. Atkreipiame dėmesį, kad galutinė Hadamardo testo būsena
<span class="math inline">\(|\chi\rangle\)</span> turi ieškomąją formą:
<span class="math display" id="eq:galutine-hadamard-testo-busena-k">\[\begin{equation}
\begin{aligned}
|\chi\rangle = &amp; |0\rangle\otimes\left(\frac{I + K}{2}\right)|\psi\rangle
+ |1\rangle\otimes\left(\frac{I - K}{2}\right)|\psi\rangle \\
= &amp; |0\rangle\otimes P(1)|\psi\rangle + |1\rangle\otimes P(-1)|\psi\rangle\,.
\end{aligned}
\tag{9.61}
\end{equation}\]</span>
Atlikus ancilos kubito (pirmasis registras) Pauli-<span class="math inline">\(Z\)</span> matavimą, pagal
tai, ar bus rasta <span class="math inline">\(|0\rangle,\)</span> ar
<span class="math inline">\(|1\rangle\)</span> būsena, antrojo kubito būsenai
<span class="math inline">\(|\psi\rangle\)</span> bus atlikta projekcija į <span class="math inline">\(K\)</span> operatoriaus
+1 arba -1 tikrinių verčių poerdvį, atitinkamai. Šis metodas yra
elementariai praplečiamas <span class="math inline">\(n\)</span> kubitų sistemai pasitelkiant daugiau
ancilų kubitų, o <span class="math inline">\(K\)</span> gali nusakyti kodų stabilizatorių rinkinio bendrąjį
matavimą. Tad jeigu randama +1 ancilos tikrinė vertė, pradinė būsena yra
konvertuojama į norimo stabilizatorių kodo būseną. Radus -1 tikrinę
vertę, pasitelkus ancilų matavimus atliekama klaidų taisymo stadijai
identiška grandinė, konvertuojanti šią būseną į +1 tikrinės vertės
būseną. Taip paruošus, pavyzdžiui, loginį
<span class="math inline">\(|0\rangle_L\)</span>, kode apibrėžtu loginiu Pauli-<span class="math inline">\(X\)</span> galima
konvertuoti <span class="math inline">\(|0\rangle_L\)</span> į
<span class="math inline">\(|1\rangle_L\)</span>, <span class="math inline">\(\bar{X}|0\rangle_L = |1\rangle_L\)</span>.</p>
</div>
<div id="klaidoms-atsparus-skaičiavimas" class="section level2 hasAnchor" number="9.10">
<h2><span class="header-section-number">9.10</span> Klaidoms atsparus skaičiavimas<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klaidoms-atsparus-skaičiavimas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Iki šiol pristatytuose klaidų protokoluose darėme prielaidą, kad klaidos
atsiranda tik tada, kai nėra atliekami loginiai vartai ar kubitų
matavimai, ancilų kubitai patys nepatiria klaidų, ir kad loginiai vartai
yra absoliučiai tikslūs. Šios prielaidos nėra realistinės. Klaidoms
atsparus skaičiavimas yra
kvantinių grandinių dizaino metodologija, kuri kartu su klaidų taisymo
algoritmais leidžia sėkmingai įvykdyti skaičiavimus, kai visi
skaičiavimo elementai ir atmintyje laikomi kubitai gali patirti klaidas.</p>
<p>Klaidoms atsparus skaičiavimas yra pagrįstas klaidų sklidimo užkirtimu.
Galime įvardyti du pagrindinius šaltinius, kurie leidžia pasklisti
klaidoms kvantinėse grandinėse. Pirmasis – tai loginiai vartai.
Akivaizdu, kad loginiai vartai, veikiantys tik vieną kubitą, nesugeba
leisti klaidoms daugintis ir propaguoti neteisingą informaciją. Tačiau,
jeigu 2 kubitų <span class="math inline">\(cX\)</span> loginiuose vartuose kontrolinis kubitas patyrė
klaidą, tada ši klaida bus perteikta į adresatinį kubitą ir kaskados
principu gali sklisti toliau. Taip pat galimas ir grynai kvantinis
efektas klaidų sklidime dėl 6 skyriuje minėtos fazės atatrankos. Jeigu,
prieš atliekant <span class="math inline">\(cX\)</span> loginius vartus, įvyksta fazės klaida
adresatiniame kubite, tada ši klaida perneš fazės klaidą ir į kontrolinį
kubitą. Antrasis klaidų sklidimo šaltinis yra kubitų būsenų matavimo
procesas, kurio rezultatas naudojamas kaip sąlyga pritaikyti loginius
vartus kitiems kubitams. Pavyzdžiui, jeigu klaidų nustatymo procese
ancilos matavimas patiria klaidą, tada gali būti pritaikomi neteisingi
loginiai vartai taisyti loginiam kubitui.</p>
<p>Siekiant užkirsti kelią klaidų dauginimuisi ir sklidimui, kvantinės
grandinės loginiai elementai yra pakeičiami klaidoms atspariais
loginiais elementais. Imkime kaip
pavyzdį <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:klaidoms-neatspari-grandine">9.5</a> pav. parodytą kvantinę
grandinę, sudarytą iš klaidoms neatsparių loginių elementų, atliekančią
2 kubitų supynimą ir jų matavimus.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:klaidoms-neatspari-grandine"></span>
<img src="media/image9_6.svg" alt="Klaidoms neatspari loginė grandinė, atliekanti kubitų supynimą ir jų matavimą" width="49%" />
<p class="caption">
9.5 pav. Klaidoms neatspari loginė grandinė, atliekanti kubitų supynimą ir jų matavimą
</p>
</div>
<p><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:klaidoms-atsparus-loginiai-elementai">9.6</a> pav. pateikiame klaidoms atsparius
<span class="math inline">\(\overline{H}\)</span> ir <span class="math inline">\(\overline{cX}\)</span> loginius elementus (vėlgi žymime su
brūkšniuku) kodui, kuriame <span class="math inline">\(k_1\)</span> ir <span class="math inline">\(k_2\)</span> loginiai kubitai koduojami
3 fiziniais kubitais. Šiuos tris fizinius kubitus, priklausančius
<span class="math inline">\(k_1\)</span> arba <span class="math inline">\(k_2\)</span>, vadinkime kubitų blokais. Matome, kad jeigu vienam
iš fizinių kubitų <span class="math inline">\(k_1\)</span> bloke pritaikomi netikslūs <span class="math inline">\(H\)</span> loginiai
vartai, ši klaida gali paveikti tik šį kubitą <span class="math inline">\(k_1\)</span> bloke. Loginiai
vartai <span class="math inline">\(\overline{cX}\)</span>, veikiantys tarp atskirų kubitų kiekviename
bloke, užtikrina, kad <span class="math inline">\(H\)</span> vartų klaida <span class="math inline">\(k_1\)</span> bloke paveiks daugiausiai vieną
papildomą kubitą <span class="math inline">\(k_2\)</span> bloke. Tą patį galima pasakyti ir apie pačius
<span class="math inline">\(\overline{cX}\)</span>, kurių klaidingas atlikimas paveikia tik po vieną
kubitą kiekviename bloke. Loginiai vartai, veikiantys tarp fizinių
kubitų blokuose nepriklausomai nuo kitų kubitų, yra vadinami
<strong>skersiniais</strong> (angl. <em>transversal gates</em>). Klaidoms atspari loginė
operacija yra formaliai tokia, kurios metu vieno loginio komponento
klaidingas veikimas paveikia ne daugiau negu vieną kubitą kiekviename
bloke.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:klaidoms-atsparus-loginiai-elementai"></span>
<img src="media/image9_7.svg" alt="Kvantinė grandinė, dviem 3 kubitų kodo loginiams kubitams atliekanti klaidoms atsparius loginius vartus" width="73%" />
<p class="caption">
9.6 pav. Kvantinė grandinė, dviem 3 kubitų kodo loginiams kubitams atliekanti klaidoms atsparius loginius vartus
</p>
</div>
<p>Klaidoms atspari kvantinė grandinė
pakeičia loginius vartus <span class="math inline">\(H\)</span> ir <span class="math inline">\(cX\)</span>, taip pat matavimų operacijas
klaidoms atspariais loginiais elementais. Be to, loginių kubitų
paruošimas <span class="math inline">\(\overline{|0\rangle}_L\)</span> turi būti taip
pat atliekamas naudojant klaidoms atsparius loginius vartus, o kubitų
būsenos yra periodiškai patikrinamos ir prireikus ištaisomos.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:klaidoms-atspari-versija"></span>
<img src="media/image9_8.svg" alt="Iliustracijoje 9.5 pav. parodytos loginės grandinės klaidoms atspari versija. Du loginiai kubitai čia koduojami \(n\) kubitais, toliau patikrinama, ar koduojant neįvyko klaidų, ir atitinkamai atliekamas taisymas. Pirmam loginiam kubitui pritaikomi klaidoms atsparūs \(\overline{H}\); matomi dar du periodiškai atliekami klaidų nustatymai ir 2 loginių kubitų klaidoms atsparūs \(\overline{cX}\); galiausiai atliekami klaidoms atsparūs kubitų būsenos matavimai" width="88%" />
<p class="caption">
9.7 pav. Iliustracijoje <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:klaidoms-neatspari-grandine">9.5</a> pav. parodytos loginės grandinės klaidoms atspari versija. Du loginiai kubitai čia koduojami <span class="math inline">\(n\)</span> kubitais, toliau patikrinama, ar koduojant neįvyko klaidų, ir atitinkamai atliekamas taisymas. Pirmam loginiam kubitui pritaikomi klaidoms atsparūs <span class="math inline">\(\overline{H}\)</span>; matomi dar du periodiškai atliekami klaidų nustatymai ir 2 loginių kubitų klaidoms atsparūs <span class="math inline">\(\overline{cX}\)</span>; galiausiai atliekami klaidoms atsparūs kubitų būsenos matavimai
</p>
</div>

<p>Siekiant realizuoti klaidoms atsparų būsenų matavimą, vėlgi pasitelkiame Hadamardo testu pagrįstą metodą
(žr. <a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamard-testas-poskyris">6.7.1</a> poskyrį). Šiuo metodu galima atlikti
loginio Pauli-<span class="math inline">\(\overline{Z}\)</span> ar bet kokio kito <span class="math inline">\(n\)</span> kubitų ermitinio operatoriaus
<span class="math inline">\(U\)</span>, išreiškiamo skersiniais loginiais vartais, projekcinį matavimą į jo
+1 ir -1 poerdvius. Iliustracijai, čia jį pritaikome 3 kubitų būsenos
<span class="math inline">\(|\psi\rangle\)</span> matavimui. Tai atliekanti kvantinė grandinė
pateikta <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:klaidoms-atsparus-matavimai">9.8</a> pav.</p>
<p>Kiekvienam <span class="math inline">\(|\psi\rangle\)</span> būsenos kubitui yra
pasitelkiamas papildomas ancilos kubitas. Šiuo atveju, trys fiziniai
ancilų kubitai pradinėje būsenoje
<span class="math inline">\(|a_1 a_2 a_3 \rangle = |000\rangle\)</span>
yra paruošiami į superpoziciją
<span class="math inline">\(|\varphi\rangle = \big(|000\rangle + |111\rangle\big)1/\sqrt{2}\)</span>,
panašią į 3 kubitų loginį kubitą. Kodavimo žingsnis nėra klaidoms
atsparus, nes naudojami klaidoms neatsparūs <span class="math inline">\(H\)</span> ir <span class="math inline">\(cX\)</span> loginiai
vartai. Tačiau po kodo paruošimo kitais trim ancilų kubitais
<span class="math inline">\((a_4, a_5, a_6)\)</span> kodas yra patikrinamas (atliekama kodavimo
patikra). Patikra yra pagrįsta jau mums žinomu būsenų lyginumo matavimu.
Jeigu kodas teisingas, tada šie ancilų kubitai naudojami tolimesnėms
operacijoms. Kitu atveju kodavimas kartojamas iš naujo.</p>
<p>Tolesniame žingsnyje atliekamas skersinis sąlyginis <span class="math inline">\(cU\)</span>
(kontroliuojamas <span class="math inline">\(U\)</span>). Ancilų kubitų būsena
<span class="math inline">\(|\varphi\rangle\)</span> užtikrina, kad klaidos neplinta šioje
stadijoje. Galiausiai ancilų kubitai yra dekoduojami, o galutinė bendra
pirmo ancilos kubito ir <span class="math inline">\(|\psi\rangle\)</span> būsena lieka
supintoji
<span class="math inline">\(|0\rangle\otimes P(1)|\psi\rangle + |1\rangle\otimes P(-1)|\psi\rangle\)</span>.
Išmatavus ancilos kubito būseną bus rasta +1 arba -1 tikrinė vertė ir
atlikta <span class="math inline">\(|\psi\rangle\)</span> būsenos projekcija į atitinkamą
poerdvį. Siekiant sumažinti tikimybę, kad klaida dekodavimo stadijos
loginiuose vartuose suteiks klaidingą matavimo rezultatą, visa ši
matavimo procedūra kartojama tris kartus. Kai taikomas daugumos balso
principas nustatant galutinio matavimo rezultatą, klaidingo atsakymo
tikimybė sumažėja nuo <span class="math inline">\(p\)</span> iki <span class="math inline">\(O(p^2)\)</span>. Čia <span class="math inline">\(p\)</span> yra tikimybė, kad
atsiras klaida bet kuriame grandinės elemente.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:klaidoms-atsparus-matavimai"></span>
<img src="media/image9_9.svg" alt="Klaidoms atsparūs 3 kubitų kodo loginio kubito būsenos bendrojo tipo matavimai" width="97%" />
<p class="caption">
9.8 pav. Klaidoms atsparūs 3 kubitų kodo loginio kubito būsenos bendrojo tipo matavimai
</p>
</div>
<p>Galima parodyti, kad tikimybė, jog klaidoms atspariose grandinėse
atsiras daugiau nei viena klaida kubitų bloke, yra <span class="math inline">\(cp^2\)</span>. Čia
proporcingumo konstanta <span class="math inline">\(c\)</span> priklauso nuo loginės operacijos bei
kodavimo metodo ir bendrai nusako skaičių skirtingų vietų loginiame
žingsnyje, kuriose gali įvykti klaida. Tad loginės operacijos klaidoms
atsparioje kvantinėje grandinėje įvykdomos sėkmingai su tikimybe
<span class="math inline">\(1 - cp^2\)</span> ir toliau įgaunamas pranašumas mažėjant <span class="math inline">\(p\)</span>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:kodu-konkatenacijos-schema"></span>
<img src="media/image9_10.svg" alt="Kodų konkatenacijos schema. Nurodytos nepataisomos klaidos tikimybė kiekviename kodavimo lygyje" width="70%" />
<p class="caption">
9.9 pav. Kodų konkatenacijos schema. Nurodytos nepataisomos klaidos tikimybė kiekviename kodavimo lygyje
</p>
</div>
<p>Kodų konkatenacijos metodas, taikomas kartu su klaidoms
atspariomis loginėmis operacijomis, leidžia dar labiau sumažinti
atsirandančių klaidų poveikį skaičiavimams. Kodų konkatenacijoje yra
atliekamas aukštesnio lygio kodavimas taip sukuriant antro, trečio, ...
, <span class="math inline">\(k\)</span> lygio loginius kubitus (nebūtinai tuo pačiu kodu). Pavyzdžiui,
jeigu naudotume tris fizinius kubitus sukurti 1 lygio loginį kubitą,
tada kiekvieną iš šių kubitų koduodami dar trimis kubitais gautume
2 lygio loginį kubitą, iš viso panaudoję <span class="math inline">\(3^2\)</span> fizinius kubitus. Atlikti
logines operacijas šiems 2 lygio loginiams kubitams atitinkamai
pasitelkiami jiems pritaikyti klaidoms atsparūs elementai, neleidžiantys
klaidoms plisti. Pirmo lygio kodavime klaidos tikimybė yra <span class="math inline">\(cp^2\)</span>,
antro lygio <span class="math inline">\(c(cp^2)^2\)</span>, ir jeigu konkatenacija yra atliekama
<span class="math inline">\(k\)</span> kartų, loginiame <span class="math inline">\(k\)</span> lygio kubite – <span class="math inline">\((cp)^{2^k}/c\)</span>. Dėl
eksponentės, klaidingo atsakymo tikimybė gali būti padaroma
pageidaujamai maža didinant konkatenacijų skaičių <span class="math inline">\(k\)</span>, jeigu <span class="math inline">\(cp &lt; 1\)</span>.</p>
<p>Sakykime, kad norima atlikti skaičiavimą su ne didesne negu
<span class="math inline">\(\varepsilon\)</span> klaidos tikimybe, kuriam reikia pasitelkti iš viso
<span class="math inline">\(p(n)\)</span> skaičių loginių vartų. Skaičius <span class="math inline">\(n\)</span> nusako problemos dydį, o
<span class="math inline">\(p(n)\)</span> – polinomiškai augantį loginių vartų skaičių. Tad klaidos
tikimybė <span class="math inline">\(p\)</span> per loginį žingsnį turėtų būti <span class="math inline">\(p &lt; \varepsilon/p(n)\)</span>.
Todėl mažiausias konkatenacijų skaičius <span class="math inline">\(k\)</span>, reikalingas pasiekti šį
tikslą, randamas iš nelygybės:
<span class="math display" id="eq:nelygybe-maziausiam-konkatenaciju-skaiciui">\[\begin{equation}
\frac{(cp)^{2^k}}{c} \leq \frac{\varepsilon}{p(n)}\,.
\tag{9.62}
\end{equation}\]</span>
Iš to išplaukia, kad konkatenacijų skaičius turi būti:
<span class="math display" id="eq:konkatenaciju-skaiciaus-ivertinimas">\[\begin{equation}
k \geq \left\{1 + \frac{\log\left\lbrack\frac{p(n)}{\varepsilon}\right\rbrack}{\log\left\lbrack\frac{1}{cp}\right\rbrack}\right\}\,.
\tag{9.63}
\end{equation}\]</span>
Iš anksčiau pateiktų argumentų matome, kad kvantinės grandinės ilgis ir
fizinių kubitų skaičius auga tik polilogaritmiškai su
<span class="math inline">\(p(n)/\varepsilon\)</span>. <strong>Ribinė teorema</strong> (angl. <em>threshold theorem</em>)
formaliai įvardija, kad klaidos atsiradimo tikimybė kiekviename loginių
operacijų žingsnyje turi būti <span class="math inline">\(p_{\mathrm{th}} &lt; 1/c\)</span>, norint užtikrinti, kad
<span class="math inline">\(k\)</span> lygių konkatenacija leistų atlikti pageidaujamo tikslumo ir ilgio
kvantinius skaičiavimus. Šios ribos apskaičiavimas yra svarbus kvantinių
kompiuterių dizainui, įvairūs vertinimai rodo, kad
<span class="math inline">\(p_{\mathrm{th}} \approx 10^{-4}–10^{-6}\)</span>.</p>
</div>
<div id="kvantinis-tūris" class="section level2 hasAnchor" number="9.11">
<h2><span class="header-section-number">9.11</span> Kvantinis tūris<a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinis-tūris" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Dekoherencijos trukmės bei loginių vartų tikslumas įvardija du esminius
klaidų šaltinius (žr. @ref(#dekoherencija-poskyris) poskyrį). Tačiau didėjant kubitų skaičiui ir mažėjant šioms
klaidoms atsiranda poreikis tiksliau įvertinti skaičiuojamąją galią. Tam
idealiai norėtume suformuluoti rodiklį ar keletą rodiklių, kurie taikant
standartinį protokolą leistų palyginti skirtingus įrenginius
nepriklausomai nuo jų fizinio realizavimo. Galima įvardyti svarbiausius
fizinius parametrus, kurie nulemia ankstyvosios NISQ raidos kvantinių
kompiuterių skaičiuojamąją galią:</p>
<ol style="list-style-type: decimal">
<li><em>kubitų skaičius;</em></li>
<li>2 <em>kubitų (arba <span class="math inline">\(n\)</span> kubitų) loginių vartų realizavimo architektūra procesoriuje;</em></li>
<li><em>loginių grandinių gylis, kurį galima pasiekti, kol rezultatų neužmaskuoja klaidos;</em></li>
<li><em>pasiekiamas loginių vartų rinkinys;</em></li>
<li><em>operacijų skaičius, kurį galima vykdyti lygiagrečiai;</em></li>
</ol>
<p>Siekdami apimti visus šiuos parametrus, panagrinėkime <strong>kvantiniu
tūriu</strong> (angl. <em>quantum volume</em>) vadinamą rodiklį. Kvantinis tūris
randamas nustačius didžiausią skaičių procesoriaus kubitų, kurie gali
patikimai įvykdyti pateikto gylio specifinę grandinę. Kvantinio tūrio
rodiklis yra paremtas <strong>kvadratinėmis grandinėmis</strong> (angl. <em>square
circuits</em>), susidedančiomis iš <span class="math inline">\(d\)</span> skaičiaus loginių vartų sluoksnių,
nusakančių grandinės gylį, ir veikia tokiam pačiam <span class="math inline">\(d\)</span> skaičiui kubitų,
vadinamam <strong>grandinės pločiu</strong> (angl. <em>circuit width</em>). Imkime
procesorių, sudarytą iš <span class="math inline">\(n\)</span> kubitų. Pradėdami protokolą bandytume
įvykdyti kvadratinę <span class="math inline">\(2 \times 2\)</span> grandinę, sudarytą iš <span class="math inline">\(d=2\)</span> gylio su pasirinktais
2 kubitais. Čia turime laisvę pasirinkti geriausiai funkcionuojančius
kubitus procesoriuje. Jeigu, pagal formaliai nustatytus rodiklius,
grandinė atliekama sėkmingai, tada tęstume toliau: <span class="math inline">\(3 \times 3, 4 \times 4, \ldots\)</span>,
kol rastume didžiausią <span class="math inline">\(m \times m\)</span> dydžio kvadratinę grandinę
(<span class="math inline">\(m \leq n\)</span>), kurios procesorius nebegali sėkmingai įvykdyti. Taip
randamas procesoriaus kvantinis tūris, jis žymimas simboliu <span class="math inline">\(V_Q\)</span>, o
jo formalus apibrėžimas yra:
<span class="math display" id="eq:kvantinio-turio-apibrezimas">\[\begin{equation}
\log_2 V_Q = \max_{m \leq n} \{\min(m, d(m))\}\,.
\tag{9.64}
\end{equation}\]</span>
Ši išraiška nusako, kad ieškomas didžiausias <span class="math inline">\(m\)</span> skaičius kubitų tarp
visų procesoriaus <span class="math inline">\(n\)</span> kubitų, kurie sėkmingai įvykdo grandinę, <span class="math inline">\(d(m)\)</span>
yra maksimalus gylis didžiausioje <span class="math inline">\(m\)</span> kubitų skaičiaus kvadratinėje
grandinėje. Čia tūris pateikiamas naudojant logaritmą su baze 2, tad
<span class="math inline">\(\log_2 V_Q\)</span> galima interpretuoti kaip procesoriaus efektyvų kubitų
skaičių, kuris gali būti lygus arba mažesnis nei fizinių kubitų skaičius
procesoriuje. Eksponentiškai kubitų skaičiumi išreikštas kvantinis tūris
<span class="math inline">\(V_Q\)</span> atspindi kvantinių būsenų erdvės dydį, kurį procesorius gali
efektyviai pasiekti atliekant unitariąsias transformacijas. Jeigu,
sakykime <span class="math inline">\(d(m) = 10\)</span>, tada kvantinis tūris, imant eksponentę su
baze 2, yra randamas: <span class="math inline">\(V_Q = 2^{10} = 1024\)</span>.</p>
<p>Toliau apžvelgiame kvantinio tūrio įvertinimo protokolą. Kiekvieną
loginių vartų sluoksnį sudaro dvi dalys: atsitiktinis visų <span class="math inline">\(d\)</span> kubitų
indeksavimo sukeitimas (angl. <em>permutation</em>) ir atsitiktinės 2 kubitų
unitariosios transformacijos, atliekamos kiekvienai porai vienas šalia
kito esančių (ar atsiradusių po sukeitimo) kubitų. Kubitų indeksavimo
sukeitimas kvantinėje grandinėje bendrai žymimas raide <span class="math inline">\(\pi\)</span> ir
pasitelkia <span class="math inline">\(SWAP\)</span> loginius vartus. O štai kiekviena iš 2 kubitų operacijų
yra parenkama <strong>Haar-atsitiktinai</strong> (angl. <em>Haar random</em>) iš <span class="math inline">\((4 \times 4)\)</span>
matricų, nusakančių bendro tipo unitariąsias 2 kubitų transformacijas.
Šių transformacijų asortimentas yra formaliai vadinamas <strong>SU(4) grupe</strong>
(angl. <em>special unitary group</em>). Haar-atsitiktinis SU(4) matricos
parinkimas yra analogiškas atsitiktiniam skaliarinio skaičiaus
parinkimui iš lygiai pasiskirsčiusių skaičių rinkinio. Kvantinio tūrio
protokolą atliekanti grandinė yra
parodyta <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:kvantinio-turio-protokolo-grandine">9.10</a> pav.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:kvantinio-turio-protokolo-grandine"></span>
<img src="media/image9_11.svg" alt="Kvadratinėmis $(d \times d)$ grandinėmis pagrįstas kvantinio tūrio nustatymo protokolas" width="85%" />
<p class="caption">
9.10 pav. Kvadratinėmis <span class="math inline">\((d \times d)\)</span> grandinėmis pagrįstas kvantinio tūrio nustatymo protokolas
</p>
</div>
<p>Siekiant įvertinti, ar grandinė buvo įvykdyta sėkmingai, taikomas
<strong>sunkiųjų išvesties būsenų generavimas</strong> (angl. <em>heavy output
generation</em>). Išmatuotų galutinių būsenų pasiskirstymas yra nusakomas
tikimybėmis
<span class="math inline">\(p_U(x) = |\langle x|U|0\rangle|^2\)</span>.
Čia <span class="math inline">\(|0\rangle\)</span> yra pradinė <span class="math inline">\(n\)</span> kubitų registro būsena,
<span class="math inline">\(U\)</span> nusako visą <span class="math inline">\(n\)</span> kubitų protokolo unitariųjų transformacijų seką, o
<span class="math inline">\(|x\rangle\)</span> yra galutinė registro būsena. Galutinės
būsenos <span class="math inline">\(|x\rangle\)</span> ir tikimybės <span class="math inline">\(p_U(x)\)</span> randami
atliekant modeliavimą klasikiniu kompiuteriu. Sunkiosios išvesties
kubitų būsenos yra tos, kurių tikimybės jas rasti yra didesnės nei visų
galimų būsenų tikimybių mediana, <span class="math inline">\(p_U(x) &gt; p_{\mathrm{med}}\)</span>. Taikant
Haar-atsitiktinumą galima apskaičiuoti, kad tikimybė rasti būsenas
<span class="math inline">\(|x\rangle\)</span> aukščiau medianos yra <span class="math inline">\(p=0.85\)</span> ir
asimptotiškai artėja prie <span class="math inline">\(p=0.5\)</span> tikimybės, jeigu įrenginys veikia itin
blogai. Kvadratinės grandinės testas yra laikomas įvykdytu, jeigu bent
2/3 visų sugeneruotų būsenų atitinka būsenas su didesnėmis tikimybėmis
nei tikimybių mediana.</p>
<p>Didesnis kvantinis tūris gali būti pasiektas procesoriuose, kurie turi
daugiau kubitų su ilgomis koherencijos trukmėmis ir mažomis loginių
vartų klaidomis. Taip pat svarbu, kad protokolo pateikti <span class="math inline">\(SWAP\)</span> bei SU(4)
loginiai vartai galėtų būti efektyviai išreikšti kvantinio procesoriaus
loginių vartų rinkiniu. Svarbu yra ir kubitų maksimalus tarpusavio
jungimas, loginių operacijų paralelizavimo galimybės, taip pat
optimaliai sukompiliuotos loginės operacijos. Kitu atveju siekiant
įvykdyti pateiktą kvantinę grandinę reikės papildomų loginių operacijų
skaičiaus, ir realus grandinės gylis įrenginyje bus didesnis, tad
tikimybė ją sėkmingai įvykdyti mažės.</p>
<p>Siekdami iliustruoti kubitų tarpusavio jungimo įtaką
skaičiavimams, <a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fig:dvi-kv-procesoriaus-architekturos">9.11</a> pav. pateikiame dvi skirtingas kvantinio procesoriaus kubitų jungčių
schemas. Pirmoje pavaizduota IBM superlaidininkais
pagrįstų grupės <em>Falcon</em> procesorių architektūra, kurioje kubitų
išdėstymas paremtas heksagonine simetrija. Toks kubitų išdėstymas yra
specialiai gamintojų pritaikytas atlikti jų parinktiems klaidų taisymo
algoritmams, atsižvelgiant į kitus procesoriaus parametrus. Didėjant
kubitų skaičiui, jų išdėstymas <em>Falcon</em> procesoriuose toliau bus
paremtas heksagonine simetrija. Čia kubitas, pagal savo poziciją, gali
turėti nuo vienos iki trijų jungčių su <strong>artimiausiai esančiais kubitais
kaimynais</strong> (angl. <em>nearest-neighbor connectivity</em>). Tai reiškia, kad
tiktai tarp šių kubitų įmanomi 2 kubitų loginiai vartai, tokie kaip
<em>cX</em>. Pavyzdžiui, atlikti <em>cX</em> tarp kubitų #1 ir #15 tiesiogiai
neįmanoma. Tam būtina įvykdyti seką <em>SWAP</em> loginių operacijų tarp
tarpinių kubitų, šitaip realizuojant norimą operaciją šiems dviem
kubitams.</p>
<p>Antroji pateikta kvantinio procesoriaus architektūra
leidžia 2 kubitų loginius vartus atlikti tiesiogiai tarp bet kurių
kubitų. Tai vadinamasis <strong>visų su visais” jungimasis</strong>
(angl. <em>all-to-all connectivity</em>). Jonų gardelėmis pagrįsti kvantiniai
procesoriai pasižymi galimybėmis realizuoti „visų su visais”
architektūrą. Neatsižvelgiant į kitus procesoriaus veikimo faktorius,
tokio tipo architektūra turi akivaizdų pranašumą prieš IBM <em>Falcon</em>, nes
potencialiai sumažina reikalaujamą loginių vartų skaičių atlikti tam
pačiam algoritmui.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:dvi-kv-procesoriaus-architekturos"></span>
<img src="media/image9_12.svg" alt="Dvi kvantinio procesoriaus architektūros, pasitelkiančios skirtingą kubitų tarpusavio jungimą. Tai nulemia, tarp kurių kubitų galima atlikti 2 ar daugiau kubitų sąlyginius loginius vartus" width="41%" /><img src="media/image9_13.svg" alt="Dvi kvantinio procesoriaus architektūros, pasitelkiančios skirtingą kubitų tarpusavio jungimą. Tai nulemia, tarp kurių kubitų galima atlikti 2 ar daugiau kubitų sąlyginius loginius vartus" width="41%" />
<p class="caption">
9.11 pav. Dvi kvantinio procesoriaus architektūros, pasitelkiančios skirtingą kubitų tarpusavio jungimą. Tai nulemia, tarp kurių kubitų galima atlikti 2 ar daugiau kubitų sąlyginius loginius vartus
</p>
</div>
<p>Kvantinis tūris leidžia patikimai įvertinti pagrindinius skaičiuojamąją
galią nulemiančius faktorius, tačiau yra orientuotas į artimosios raidos
NISQ kvantinius kompiuterius. Spartus klasikinių skaičiavimo išteklių
augimas gali užkirsti kelią atlikti klasikiniam kvantinės grandinės
modeliavimui, kuris reikalingas rezultatų patikrinimui procesoriuose su
daugiau nei ~60 kubitų. Augant kubitų skaičiui bei mažėjant klaidoms
bus reikalingas kitas būdas įvertinti kvantinių kompiuterių
skaičiuojamajai galiai.</p>

</div>
</div>



            </section>

          </div>
        </div>
      </div>
<a href="sistemu-modeliavimas-ir-qml.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["kvantinekompiuterija.pdf", "kvantinekompiuterija.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
