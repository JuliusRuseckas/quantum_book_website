[["index.html", "Kvantinė kompiuterija Pratarmė Kaip skaityti šią knygą Padėka Apie autorius Prisidėti prie knygos Licencija", " Kvantinė kompiuterija Tadas Paulauskas Julius Ruseckas 2022-11-27 Pratarmė Idėja parengti knygą apie kvantinę kompiuteriją lietuvių kalba kilo Covid-19 pandemijos metu. Dėl laboratorijų uždarymo ir sulėtėjusių mokslinių tyrimų atsirado galimybė daugiau laiko skirti šiai sparčiai besivystančiai sričiai. Knyga prasidėjo veikiau kaip autorių sukauptų teorinių žinių susisteminimas į vieną dokumentą asmeniniams darbams. Perorientuoti dokumentą į platesnei auditorijai skirtą knygą buvo nutarta atsižvelgiant į tai, kad jos rašymo metu dar neegzistavo nė viena lietuviška knyga apie kvantinę kompiuteriją. Tikimės, kad knyga padės geriau susipažinti su šia technologija ir paskatins ne vien platesnį susidomėjimą, bet ir jos plėtrą Lietuvoje. Kvantinė kompiuterija apjungia keletą mokslo sričių – fiziką, kompiuterių mokslą, grynąją matematiką, inžinerinius mokslus. Knyga koncentruota į kompiuterių mokslo priartėjimą prie šios srities ir apibūdina informacijos apdorojimą kvantiniame procesoriuje abstrakčiu lygmeniu. To turėtų pakakti norint atsispirti nuo pradinio taško ir toliau plėsti žinias norima kryptimi. Ši knyga buvo parašyta remiantis svarbiausiomis esamomis knygomis ir moksliniais straipsniais apie kvantinę kompiuteriją. Tarp naudotų knygų yra šios srities „biblija“ tapusi autorių Nielsen ir Chuang „Quantum Computation and Quantum Information“ (Nielsen and Chuang 2000), Nakahara ir Ohmi „Quantum Computing – From Linear Algebra to Physical Realizations“ (Nakahara and Ohmi 2008), ir kitos. Išsamus literatūros sąrašas yra pateiktas knygos pabaigoje. Dalis medžiagos taip pat naudota iš T.P. doktorantūros metu klausyto kurso „Quantum computing“, kurį dėstė profesorius Friedland Shmuel, užrašų. Kaip skaityti šią knygą Knyga skirta skaitytojams, kurie nėra anksčiau susipažinę su kvantine kompiuterija. Jos tikslas – pristatyti šią sritį pradedant nuo elementariausių savokų, skiriant daugiau dėmesio konceptualiam supratimui. Nors knyga nebuvo specialiai orientuojama į vadovėlio formatą, tačiau skyrių seka turi progresiją, kuri gali būti panaudota vieno semestro bakalauro ar magistrantūros studentų kursui. Jeigu skaitytojas nėra turėjęs tikslinių mokslų žinių ir nori patenkinti savo smalsumą, tada rekomenduojame skaityti tik pirmąjį ir penktąjį skyrius. Pirmajame skyriuje glaustai apžvelgiama kvantinė kompiuterija ir palyginama su klasikine kompiuterija. Kituose skyriuose iš esmės sugrįžtama prie pirmajame skyriuje minėtų savokų bei algoritmų ir jie parodomi išsamiau. Penktajame skyriuje apžvelgiami kvantinės informacijos aspektai, tokie kaip kriptografija ir kvantinės informacijos siuntimas pasitelkiant teleportacijos metodą. Šie taikymai perteikia kvantinių bitų elgsenos keistenybes ir jų siūlomus privalumus. Kituose skyriuose po visų matematinių išraiškų pateikti konceptualūs paaiškinimai. Tad net ir neskaitant lygčių įmanoma susidaryti bendrą idėją apie pateiktų kvantinių algoritmų veikimo principą. Norint įsisavinti visą pateiktą knygoje medžiagą, rekomenduotina turėti bent bakalauro lygio tiesinės algebros žinių. Kvantinės mechanikos žinios, be abejo, praverstų, tačiau nėra būtinos. Reikalingi matematiniai įrankiai ir kvantinės mechanikos taisyklės, taikomos kvantinėje kompiuterijoje, yra pateikiamos šioje knygoje. Jeigu turite pakankamai žinių minėtose srityse, tada antrąjį skyrių, kuris skirtas matematikos žinioms atgaivinti, galite atsiversti esant poreikiui. Padėka Autoriai dėkoja Vaidui Pačebutui ir Arūnui Krotkui už paramą rengiant šią knygą, taip pat Audriui Alkauskui, Maženai Mackoit Sinkevičienei, Karoliui Jankauskui, Artūrui Pupšiui už vertingus patarimus. Iliustracijos – Jovita Jankauskienė Kalbos redaktorė – Rozita Znamenskaitė (KTU leidykla „Technologija“) Apie autorius Tadas Paulauskas įgijo fizikos mokslų daktaro laipsnį Ilinojaus universitete Čikagoje. Vėliau atliko tyrimus Monašo universitete Melburne. Šios knygos rašymo metu dirba Fizinių ir technologijos mokslų centre (FTMC), Optoelektronikos skyriuje. Mokslinių tyrimų sritis apima puslaidininkių fiziką, nanotechnologijas, medžiagų inžineriją. Julius Ruseckas įgijo fizikos mokslų daktaro laipsnį Vilniaus universitete. Vėliau dirbo mokslinį darbą Vilniaus universiteto Fizikos fakulteto teorinės fizikos ir astronomijos institute. Pagrindinė mokslinių tyrimų sritis – kvantinė optika ir labai šaltos atominės dujos. Šios knygos rašymo metu dirba Baltijos pažangių technologijų institute (BPTI). Prisidėti prie knygos Norite prisidėti prie šios atvirai prieinamos knygos turinio kūrimo, redagavimo ar apipavidalinimo? Visada ieškome gabių žmonių ir tyrėjų, kurie papildytų knygos kūrėjų gretas! Rašykite mums į el. paštą info@kvantinekompiuterija.lt. Visą knygos turinį bookdown formate galite pasiekti GitHub paskyroje. Licencija Internete pateikiama knygos versija gali būti naudojama pagal Creative Commons licenciją Priskyrimas - Nekomercinis naudojimas - Analogiškas platinimas 4.0 Tarptautinė (CC BY-NC-SA 4.0) "],["kvantinės-kompiuterijos-apžvalga.html", "1 skyrius. Kvantinės kompiuterijos apžvalga 1.1 Įvadas 1.2 Kvantinės kompiuterijos pradmenys 1.3 Tiuringo mašina 1.4 Skaičiavimų ištekliai 1.5 Kvantiniai bitai 1.6 Kvantinės informacijos apdorojimas 1.7 Skaičiavimo procesas 1.8 Kvantinių kompiuterių charakteristikų palyginimas 1.9 Dekoherencijos trukmė ir loginių vartų tikslumas", " 1 skyrius. Kvantinės kompiuterijos apžvalga 1.1 Įvadas Šiandieniniai kompiuteriai, kuriuos čia vadinsime klasikiniais, atvėrė kelią į informacijos amžių. Puslaidininkinių tranzistorių išradimas XX a. viduryje ir jų pagrindu formuojami mikroprocesoriai leido nuosekliai didinti kompiuterių skaičiuojamąją galią bei kompiuterių miniatiūrizacijos lygį. Sunku nepervertinti kompiuterių vaidmens technologinėje ir socialinėje žmonijos raidoje – nuo naujų medžiagų ir medikamentų kūrimo, atliekamų skaičiavimų nustatant erdvėlaivių trajektorijas, mašininiu mokymusi grindžiamo savaeigio transporto, genų inžinerijos iki socialinių tinklų, paremtų į tinklą sujungtais kompiuteriais. Moore’o dėsnis (angl. Moore’s law) yra artimai susietas su skaičiuojamosios galios didėjimu per pastaruosius 40 metų. Šis dėsnis teigia, kad tranzistorių skaičius integruotose mikroprocesorių grandinėse padvigubėja maždaug kas dvejus metus. Didesnis tranzistorių skaičius procesoriuose gali leisti atlikti sudėtingesnes skaičiavimų operacijas, suteikti daugiau greitai pasiekiamos atminties ir paralelizuoti skaičiavimus. Moore’o dėsnis savo ruožtu reiškia komponentų mažėjimą; puslaidininkinių procesorių komponentų dydžiai siekia 1–2 nanometrus. Dviejuose nanometruose galima išrikiuoti apie dešimt atomų, tad, be praktinės, matome ir fundamentinę ribą klasikinių kompiuterių komponentų dydžiui – vienas atomas. Tai nulems, jog netolimoje ateityje prireiks kitų būdų patenkinti didėjantiems skaičiavimų spartos poreikiams. Tačiau technologinei raidai svarbių užduočių skaičiavimo galimybės jau ir dabar yra itin ribotos. Mažėjant klasikinių kompiuterių komponentų dydžiui, tenka neišvengiamai atsižvelgti į kvantinius dydžio efektus (angl. quantum size-effects). Medžiagos apimtį sumažinus iki nanometro skalės, ima ryškėti krūvininkų energijos lygmenų persitvarkymai, taip pat didėja tikimybė krūvininkams pabėgti iš medžiagos kvantinio tuneliavimo principu (angl. quantum tunneling). Šie ir kiti kvantiniai efektai padaro puslaidininkinių tranzistorių veikimą nenuspėjamą, ir reikia papildomų priemonių norint išlaikyti jų funkcionavimą. Pažangesnių nanomedžiagų gamybos principų įsisavinimas veikiausiai leis klasikinius procesorius padaryti energetiškai efektyvesnius ir padidinti jų spartą. Tačiau yra ir kitas sprendimo būdas – keisti patį klasikinį skaičiavimo modelį į tokį, kuris paremtas kvantinėmis taisyklėmis. Kvantinė kompiuterija yra nauja skaičiavimų paradigma. Tai nulemia fundamentalaus klasikinės informacijos paketo bito pakeitimas kvantiniu bitu, vadinamuoju kubitu (angl. qubit). Šios technologijos privalumai kyla iš tipinių kvantinių efektų – kubito gebėjimo būti skirtingose būsenose vienu metu, vadinamojoje būsenų superpozicijoje (angl. state superposition), interferencijos efektų (angl. interference) ir kvantinio supynimo (angl. quantum entanglement). Kvantinis procesorius yra sudarytas iš daugelio kubitų, o bendroje visų kubitų būsenų superpozicijoje yra koduojama ir apdorojama informacija. Kadangi kvantinių būsenų transformacijos, kurioms vykstant atliekamas informacijos apdorojimas, veikia visas būsenas superpozicijoje vienu metu, kvantinis kompiuteris iš pagrindų pasižymi didelėmis paralelizavimo galimybėmis. Kubitu gali būti įvairios kvantinės fizinės sistemos, kuriose įmanoma tiksliai kontroliuoti ir nuskaityti dvi skirtingas būsenas. Tarp jų yra elektronų ir atomų branduolių sukininės būsenos, sklindančių fotonų poliarizacija, elektroniniai ir vibraciniai atomų lygmenys, elektromagnetinio lauko rezonansai uždaroje ertmėje, krūvininkų skaičius superlaidininkuose. Įdomu paminėti, kad skaičiavimai, pagrįsti kvantinėmis taisyklėmis, buvo pasiūlyti kur kas anksčiau, nei dydžio efektai klasikiniuose kompiuteriuose galėjo kelti rūpesčių, maždaug 1980 metais. Tada tai atrodė arti fantastikos ribų, nes kontroliuoti kvantinių sistemų būsenas ir apsaugoti jas pakankamai ilgai nuo sunykimo, norint spėti atlikti skaičiavimus, itin keblu. Šiuo požiūriu technologinėje raidoje kvantinė kompiuterija žymi pradžią, kai įspūdingu tikslumu gebama kontroliuoti fundamentalių gamtos ingredientų kitimą laike. Kvantinė kompiuterija yra tik vienas šios pažangos vaisius, tačiau potencialiai turintis esminę rolę paveikti žmonių kasdienybei. Rašydami šią knygą esame vadinamojoje triukšmingų tarpinės skalės kvantinių technologijų etape (angl. noisy intermediate-scale quantum, trumpinys NISQ). NISQ kvantiniai procesoriai turi 50-100 kubitų skaičių, pasižymi sparčiai atsirandančiomis klaidomis ir nenaudoja klaidų taisymo algoritmų. Tai neleidžia atlikti ilgų ir tikslių praktinės svarbos skaičiavimų. Didėjant kvantinių kompiuterių skaičiuojamajai galiai verta tikėtis proveržių srityse, kuriose reikalingi intensyvūs skaičiavimai. Šios sritys apima medikamentų ir technologinių medžiagų kūrimą, branduolinę energetiką, fundamentinius mokslinius tyrimus, dirbtinio intelekto tobulinimą, finansinių rinkų modeliavimą, logistiką, klimato kaitos ir kitų kompleksinių sistemų vyksmų modeliavimą. Kvantiniai kompiuteriai veikiausiai neišstums klasikinių įrenginių, puikiai atliekančių daugybę funkcijų, bet bus naudojami greta. To pavyzdys – grafikos apdorojimo procesorius (angl. graphics processing unit), integruotas daugumoje kompiuterių. Palyginus su bendro naudojimo kompiuterio procesoriumi, grafikos procesoriaus elektroninė architektūra suteikia galimybes paralelizuoti ir itin paspartinti tam tikro tipo duomenų apdorojimą. Galima panašiai įsivaizduoti ir su klasikiniu kompiuteriu integruotą kvantinį procesorių, į kurį nukreipiamos užduotys, reikalaujančios jo suteikiamų privalumų, taip realizuojant hibridinį kvantinį-klasikinį skaičiavimo metodą. Knygoje pristatomi kvantinės kompiuterijos pagrindai vadinamiesiems universaliesiems kvantiniams kompiuteriams (angl. universal quantum computers). Universalumas čia reiškia, kad jie nėra specializuoti spręsti specifinius uždavinius, bet gali atlikti bet kokį suformuluotą skaičiavimą. Šiuo metu plačiausiai vystomas kvantinio skaičiavimo modelis yra grįstas loginiais vartais (angl. gate-based model); jis dar vadinamas kvantinių grandinių modeliu (angl. quantum circuit model). Kaip rodo pavadinimas, jų žemiausio lygmens programavimas yra pagrįstas kvantiniais loginiais vartais, kurie atlieka kubitų būsenų transformacijas. Kvantiniame procesoriuje pasitelkiama keletas skirtingų loginių vartų, sudarančių universalų rinkinį; jų kombinacijomis galima įvykdyti visus įmanomus skaičiavimus. Tokiu principu veikia ir klasikiniai kompiuterių procesoriai, kuriuose elektroninės loginės grandinės atlieka pateiktos dvejetainės skaičių sekos apdorojimą. Skaičiavimų universalumas leidžia atsiriboti nuo konkrečios fizinės sistemos, realizuojančios kubitus, ir susitelkti į skaičiavimo užduočių formulavimą bei programavimą. Skirtingi kvantiniai procesoriai gali naudoti skirtingo tipo loginius elementus; tačiau tai tik reiškia, kad kvantinį algoritmą teks perkompiliuoti naujais elementais – algoritmo pagrindas nekinta. Ankstyvieji kvantinės kompiuterijos tyrinėtojai turi pirmenybę apsiprantant su pasauliu, kuriame reikia žaisti pagal kvantines taisykles. Vertinant iš fizikos perspektyvos, kubitas – pati paprasčiausia kvantinė sistema, kuri nėra triviali. Kvantiniame kompiuteryje matome situaciją, kai iš daugelio paprastų sistemų iškyla nauji kompleksiškumo reiškiniai. Kvantinis superpozicijos principas yra pagrindinis to šaltinis; visgi tai kitokios prigimties superpozicija, nei aptinkama klasikinėse sistemose. Pavyzdžiui, skirtingi stygų vibracijos dažniai muzikos instrumente nusako skirtingas būsenas. Spragtelėjus stygą pirštu, ji greičiausiai bus sužadinta virpėti vienu metu keletu skirtingų dažnių, o tai savo ruožtu nusakys stovinčiųjų bangų (virpesių) superpoziciją. Taip pat ir bangos, keliaujančios sužadintu vandens paviršiumi skirtingomis kryptimis, yra būsenų superpozicija bei demonstruoja tokius reiškinius kaip interferencija, kada persiklojusių bangų amplitudė vietomis padidėja ir sumažėja. Norint pamatyti skirtumus tarp klasikinių ir kvantinių sistemų įsivaizduokime instrumento stygą, kuri gali vibruoti tik dviem skirtingais dažniais. Vadinsime juos \\(|0\\rangle\\) ir \\(|1\\rangle\\). Stygos būseną galime užrašyti kaip šių virpesių sumą: \\(|S\\rangle = a|0\\rangle + b|1\\rangle\\); čia \\(a\\) ir \\(b\\) nusako atitinkamų virpesių amplitudę, tai yra garsumą. Siekdami padaryti šį pavyzdį artimesnį kvantinėms sistemoms, tvirtinsime, kad styga bet kuriuo metu negali nevibruoti bent vienu iš šių dviejų dažnių. Keturių stygų violončelėje jos bendrą būseną bet kuriuo metu galima nusakyti įvardijant keturių stygų būsenas – \\(|S_1 \\rangle\\), \\(|S_2 \\rangle\\), \\(|S_3 \\rangle\\), \\(|S_4 \\rangle\\), ir todėl iš viso aštuonias amplitudes \\(\\{(a_1,b_1),\\ldots,(a_4,b_4)\\}\\). Tačiau, jeigu šios stygos būtų kvantinės sistemos taip pat su dviem skirtingomis būsenomis (kubitai), nusakyti violončelės būsenai reikėtų įvardyti šešiolika amplitudžių! Papildomos būsenos kvantinėje violončelės versijoje atsiranda dėl to, kad galima ne vien tos pačios stygos būsenų superpozicija, bet ir bendra skirtingų stygų būsenų superpozicija. Pavyzdžiui, dvi galimos klasikinės violončelės būsenos yra kai visos keturios stygos vibruoja tik \\(|0 \\rangle\\) dažniu, nusakoma amplitudėmis \\(\\{(a_1,0),(a_2,0),(a_3,0),(a_4,0)\\}\\) ir kai vienu metu visos stygos vibruoja tik \\(|1\\rangle\\) dažniu, nusakoma amplitudėmis \\(\\{(0,b_1 ),(0,b_2 ),(0,b_3 ),(0,b_4 )\\}\\). Jeigu šios stygos būtų kvantinės, tada galima ir šių klasikinių būsenų superpozicija. Tai reiškia, vienu metu visos stygos vibruoja tik \\(|0\\rangle\\) dažniu ir nevibruoja \\(|1\\rangle\\), taip pat vibruoja \\(|1\\rangle\\) dažniu ir nevibruoja \\(|0\\rangle\\). Bendrai tariant, jeigu klasikinių stygų skaičius yra \\(n\\), tokiai sistemai nusakyti bet kuriuo metu reikia \\(2n\\) amplitudžių verčių. O štai kvantinėje jos versijoje šis skaičius yra \\(2^n\\). Tad jeigu sutarsime, kad amplitudžių vertės koduoja informaciją, taps akivaizdu, jog kvantinės sistemos gali savyje laikyti eksponentiškai daugiau informacijos. Eksponentinis skirtumas tarp klasikinių ir kvantinių būsenų skaičiaus atsiranda dėl to, kad kvantinėse sistemose galimos supintosios būsenos (angl. entangled states). Minėta superpozicijos būsena yra kvantinio supynimo pavyzdys, leidžiantis keletui „stygų” elgtis kaip viena „superstyga”. Supintos sistemos pasižymi kvantinėmis koreliacijomis, kurių neįmanoma imituoti klasiškai ir paaiškinti klasikine tikimybių teorija. Jos elgiasi panašiai kaip vienas darinys, net jeigu yra atskirtos viena nuo kitos dideliais atstumais. Pavyzdžiui, dviejų klasikinių bitų būseną galima pakeisti į bet kurią kitą iš keturių galimų kombinacijų \\(\\{00, 01, 10, 11\\}\\) tik keičiant kiekvieno individualaus bito būseną. Supintojoje 2 kubitų būsenoje pakanka kontroliuoti vieno pasirinkto kubito būseną norint akimirksniu pakeisti jų bendrą būseną į bet kurią iš analogiškai keturių skirtingų. 1.1 pav. Dviejų kubitų kvantinis supynimas Supintosiose sistemose (žr. 1.1 pav.) dalis informacijos yra laikoma kvantinėse koreliacijose tarp kubitų būsenų. To gerą pavyzdį pateikia fizikas Johnas Preskillas. Įsivaizduokime, kad turime dvi šimto puslapių dydžio knygas – vieną įprastą klasikinę, o kitą kvantinę, kurioje informacija yra laikoma kvantinėse būsenose. Perskaitę vieną įprastos knygos puslapį sužinome 1% visos joje pateikiamos informacijos, tad perskaitę šimtą puslapių žinome viską, kas joje yra. Tačiau skaitydami kvantinę knygą ir atversdami kiekvieną naują puslapį gauname nenuspėjamą turinį. Perskaitę visą šimtą puslapių turėsime tik mažą idėją, apie ką rašoma knygoje, nes eksponentiškai didesnė dalis informacijos yra laikoma ne atskiruose puslapiuose, bet koreliacijose tarp jų. Norint sužinoti visą informaciją, laikomą kvantinėje knygoje, reikia „skaityti” visus knygos puslapius vienu metu. Tai yra klasikinėje terpėje neturintis analogijų procesas. Informacija, kuri koduojama ir apdorojama kvantinėse sistemose, vadinama kvantine informacija. Kvantinės informacijos teorija (angl. quantum information theory) yra nauja informatikos šaka ir skiriasi nuo klasikinės informatikos keletu esminių principų. Didžioji dalis informacijos, esančios kvantinių būsenų erdvėje, nėra prieinama. Norint sužinoti anksčiau minėto kvantinio instrumento būseną esančioje superpozicijoje, galimi atsakymai yra: visos keturios stygos vibruoja pirmuoju \\(|0\\rangle\\) arba antruoju \\(|1\\rangle\\) dažniu. Kitaip tariant, atskleisdami kvantinėse superpozicijos būsenose laikomą informaciją gauname klasikinę informaciją, o superpozicija yra sugriaunama. Neįmanoma nuspėti, kuris rezultatas bus aptiktas; žinomos tik jų tikimybės, kurios yra proporcingos amplitudžių dydžiams. Wooterso ir Zureko uždraustojo kopijavimo teorema (angl. no-cloning theorem) nusako kitą esminį skirtumą tarp kvantinės ir klasikinės informacijos. Ši teorema teigia, kad kvantinės informacijos neįmanoma kopijuoti. Tai nereiškia, kad žinodami informacijos, tai yra kvantinės būsenos, paruošimo žingsnius negalime jos tiksliai atkartoti. Šis principas veikiau rodo, kad gavus kvantinės informacijos paketą su nežinomu turiniu neįmanoma sukurti šio turinio identiškos kopijos. Nors šie skirtumai atrodytų kaip keblumai, panaikinantys minėtus kvantinių sistemų privalumus, tačiau dar ne viskas prarasta. Pirmiausiai galima atkreipti dėmesį, kad nors apdorojamos informacijos apimtis tam tikrose užduotyse gali būti astronominio dydžio, tačiau praktikoje dažnai prireikia tik sąlygiškai mažos jos dalies, kad sužinotume norimą atsakymą ar perteiktume duomenis žmogiškuoju pavidalu. Dėl eksponentinio būsenų skaičiaus perteikti net ir 300 kubitų laikomą kvantinę informaciją į klasikinės atminties išteklius būtų neįmanoma, tam prireiktų maždaug \\(10^{90}\\) amplitudžių verčių. Šis skaičius yra didesnis nei stebimoje Visatoje esančių atomų skaičius. Ekstravagantiškos kvantinių sistemų savybės pačios savaime neužtikrina, kad jomis pagrįstas skaičiavimas bus pranašesnis už klasikinius. Galima pateikti tris geras priežastis, kodėl kvantinis skaičiavimo modelis visgi demonstruoja pranašumą. Pirma (ir akivaizdžiausia) priežastis slypi kvantinių sistemų modeliavime. Dėl eksponentiškai didelės kvantinių būsenų erdvės nėra žinoma, kaip efektyviai jas modeliuoti klasikiniu kompiuteriu. Čia ištekliai auga eksponentiškai su sistemos dydžiu (kubitų skaičiumi), o štai modeliuojami kvantiniu kompiuteriu jie bendrai auga tiesiškai. Vienas pavyzdys, kuriame kvantinių sistemų modeliavimas galėtų suteikti globaliai svarbų proveržį, yra vadinamas azoto fiksacijos procesu (angl. nitrogen fixation process). Šiame procese stipriomis trigubomis kovalentinėmis jungtimis molekulėse \\(\\mathrm{N}_2\\) susijungę azoto atomai yra atskiriami ir kartu su kitais elementais transformuojami į amoniaką (\\(\\mathrm{NH}_3\\)) bei kitus nitratus, naudojamus pramoninei trąšų gamybai. Efektyviausiam žinomam procesui, vadinamam Haberio-Bošo procesu (angl. Haber-Bosch process), reikia itin didelių slėgių ir temperatūrų šiai transformacijai atlikti, ir todėl išeikvojama ypatingai daug energijos. Azoto fiksacija yra taip pat esminis procesas biologinėse sistemose atliekant biosintezę. Biologinės sistemos tai atlieka itin efektyviai įprastinėmis kambario sąlygomis naudojant nitrogenazės fermentą. Šio organinio cheminio proceso supratimas galėtų padaryti trąšų gamybą energetiškai žymiai efektyvesnę. Tačiau jis yra neįkandamas klasikiniams superkompiuteriams dėl per didelio laisvės laipsnių skaičiaus net ir sąlygiškai mažoje molekulėje. Antroji priežastis slypi neįveikiamų klasikinių užduočių skaičiavimuose kvantiniu kompiuteriu. Jau dabar yra atrasta eksponentiškai laiko išteklių atžvilgiu greitesnių kvantinių algoritmų už geriausius žinomus klasikinius tam tikroms problemoms spręsti ir naujų algoritmų skaičius sparčiai auga. Tai padaro klasikiniams kompiuteriams fundamentiškai neįveikiamas problemas įveikiamas kvantiniams. Galiausiai skaičiavimų sudėtingumo (angl. computational complexity) teorijos argumentai teigia, kad kvantiniu kompiuteriu galima efektyviau testuoti reikšmes iš koreliuotųjų tikimybinių funkcijų (angl. correlated probability distribution). Tokio tipo skaičiavimais yra dažnai grindžiami pirmieji kvantinės viršenybės (angl. quantum supremacy) demonstravimai prieš klasikinius kompiuterius pasitelkiant mažą skaičių kubitų. Esminiai kvantinės informacijos skirtumai taip pat atsispindi ir ryšiuose, kuriais siunčiama arba pasitelkiama kvantinė informacija. Kvantinis supynimas leidžia atlikti komunikacijų protokolus, neįmanomus naudojant vien klasikines būsenas. Tarp šių protokolų yra tankusis kodavimas (angl. dense coding), leidžiantis nusiųsti dvigubai daugiau bitų klasikinės informacijos su kiekvienu kubitu. Kvantinė teleportacija (angl. quantum teleportation) suteikia būdą persiųsti tolydžiosiose kubito būsenos amplitudėse koduojamą kvantinę informaciją naudojant tik du bitus informacijos. Ne mažiau svarbūs yra kvantinės informacijos principų taikymai kriptografijoje. Kvantiniai protokolai leidžia užtikrinti fizikos dėsniais apsaugotą komunikaciją. Itin didelio saugumo reikalaujančios komunikacijos ateityje veikiausiai kliausis kvantiniais ryšiais arba turės būti atnaujinamos naujais klasikiniais protokolais, kadangi šiandieniniai kriptografijos protokolai tampa įveikiami pažangiais kvantiniais kompiuteriais. 1.2 Kvantinės kompiuterijos pradmenys Kvantinių sistemų egzistavimas ir pagrindiniai jų elgsenos principai buvo laipsniškai atskleisti 1900–1930 metų laikotarpiu ieškant išeities iš absurdiškų spėjimų, kuriuos buvo galima prieiti taikant tuometines fizikos teorijas. Viena tokių problemų buvo vadinama ultravioletinės srities katastrofa (angl. ultraviolet catastrophe), privedanti prie begalinių energijų. Šios anomalijos ištaisymas ir interpretacija fizikiniame modelyje įvedant elektromagnetinio lauko energijos kvantą, dabar vadinamą fotonu, buvo pirmieji žingsniai link kvantinės mechanikos atsiradimo. Kvantinė mechanika suteikia rinkinį taisyklių, vadinamų postulatais, kurios padeda sujungti abstraktų jos matematinį formalizmą su tuo, ką įmanoma objektyviai išmatuoti ir apibūdinti fiziniame lygmenyje. Postulatai kvantinėje mechanikoje gali būti palyginami su aksiomomis matematinėse logikų sistemose, įvardijantys pradinius pasiūlymus ar principus, kurie savaime nėra įrodomi, tačiau pagal juos grindžiama likusi loginė sistema. Fizinių teorijų, pagrįstų kvantine mechanika, pavyzdžiai yra kvantinė elektrodinamika ir kvantinė chromodinamika, apibūdinančios šviesos (fotonų) sąveiką su elektros krūvį turinčia materija (elektronai, protonai, miuonai) ir branduolyje stipriąsias sąveikas tarp kvarkų bei gliuonų atitinkamai. Kitaip nei klasikinėje fizikoje, kvantinės sistemos būsena ir su ja susietos savybės, tokios kaip jos padėtis, judėjimo greitis ar energija, negali būti tiesiogiai stebimi nepaveikiant pačios sistemos būsenos. Tai savo ruožtu apibūdina tarsi paslėptą pasaulį, kurio nei tiesiogiai, nei tiksliai pasiekti negalime. Kiek žinoma, gamta yra fundamentaliai kvantinė, nors keistosios jos savybės atsiskleidžia tik esant specifinėms sąlygoms. Pirmąsias idėjas panaudoti kvantines sistemas skaičiavimo procesuose galima aptikti jau devintojo dešimtmečio pradžioje. Tokie žymūs fizikai kaip Richardas Feynmanas, Paulas Benioffas, Yuri Maninas, Davidas Deutschas ir kiti atkreipė dėmesį, kad klasikiniais kompiuteriais modeliuoti kvantines sistemas bendroje situacijoje yra neefektyvu ir daugeliu atvejų tiesiog neįmanoma. Kompiuterio atminties ištekliai, reikalingi apibūdinti kvantinės sistemos būsenai, auga eksponentiškai kartu su sistemos dydžiu. Tai brėžia praktinę ribą ties santykinai mažo dydžio sistemomis bei riboto tipo skaičiavimais ir todėl tiesiogiai veikia fundamentinių tyrimų spartą bei technologinę raidą. Kvantinio kompiuterio idėją pastūmėjo to meto technologiniai pasiekimai, pirmą kartą demonstruojantys individualių atominio lygmens sistemų kontrolę. Pavyzdžiui, galėjimas judinti ir sugrupuoti pavienius atomus medžiagos paviršiuje skenuojamuoju elektroniniu mikroskopu, jonų pagavimas elektromagnetinėse gaudyklėse, pavienių elektronų perkėlimas įvairiuose elektroniniuose dariniuose. Šie pasiekimai veikiau suteikė stimulo tolimesniems tyrimams, kadangi mechaniškai kontroliuoti atominio lygmens sistemas nebūtinai reiškia, kad kontroliuojamos ir jų kvantinės būsenos. Informacijos kodavimas ir apdorojimas kvantinėse sistemose yra pagrįstas jų būsenų koherentiniu valdymu (angl. coherent control). Fizikiniais terminais tai reiškia gebėjimą išlaikyti ir keisti santykines fazes tarp kvantinių sistemų. Kad geriau suprastume koherencijos principą, įsivaizduokime dviejų žmonių irkluojamą valtį. Norint ja plaukti irkluotojams tenka sukoordinuoti periodinį irklų pakėlimą iš vandens, nuleidimą ir atsistūmimą nuo vandens. Jeigu jie tai idealiai sukoordinuoja, tada galime sakyti, kad jų santykinė fazė lygi nuliui. Koherentinis valdymas reiškia, kad jie gali tiksliai pasirinkti kokią tik pageidauja fazę ir ją išlaikyti. Tačiau jeigu šie irkluotojų atliekami judesiai nepastoviai kinta, tai lems nekoherentinį plaukimą ir tiesiog valties sukinėjimąsi vietoje. Viena iš esminių užduočių išlaikant kvantinių sistemų koherenciją – užtikrinti jų izoliavimą nuo nepageidaujamų sąveikų su aplinkos kvantinėmis sistemomis, kurios nenuspėjamai keičia jų santykines fazes ir priveda prie dekoherencijos (angl. decoherence). Dekoherencija yra didžiausias kvantinių kompiuterių priešas, jos efektai pasireiškia atsitiktiniais būsenų pokyčiais, sistemos triukšmu, ir dėl to atsirandančiomis skaičiavimų klaidomis. Žinoma, yra ir tokių kvantinių sistemų, kurios labai silpnai sąveikauja su kitomis sistemomis. Tačiau sąveikos yra reikalingos siekiant realizuoti logines operacijas ir skaičiavimų universalumą. Šie vienas kitam prieštaraujantys reikalavimai uždeda apribojimus sistemoms, kurios yra tinkamos realizuoti kubitus. Kvantinė kompiuterija įgavo pagreitį ir sulaukė platesnės bendruomenės susidomėjimo dešimtojo dešimtmečio pradžioje. Peteris Šoras sukūrė algoritmą, kuriuo parodė, kad kvantiniu kompiuteriu įmanoma pasiekti eksponentinį pagreitinimą siekiant atlikti itin didelės svarbos užduotis – pirminių skaičių faktorizavimą ir diskrečiojo logaritmo apskaičiavimą. Nėra žinomų efektyvių algoritmų spręsti šias problemas naudojant klasikinius kompiuterius, ir jos traktuojamos kaip neįveikiamos. Kadangi pirminių skaičių faktorizavimu yra pagrįsta didžioji dalis globaliai taikomos kriptografijos, tai indikuoja akivaizdžią praktinę svarbą ir kartu potencialiai egzistencinę krizę komunikacijų saugumui. Ne mažiau svarbūs buvo pirmieji kvantinių klaidų taisymo principai. Klaidų prevencijos ir taisymo algoritmai yra neatsiejama dalis praktinės svarbos skaičiavimuose. Kubitais pagrįstas modelis buvo pastūmėtas itin sėkmingo skaitmeninio kompiuterio modelio, naudojančio dvejetainę sistemą. Vertinant iš praktinės pusės, kontroliuoti dvi būsenas sistemoje yra paprasčiau ir tai išlaiko skaičiavimų universalumą – sudėtingesnis modelis nėra būtinas norint atlikti visus suformuluojamus skaičiavimus. Kubitais pagrįstuose skaičiavimo modeliuose pasirenkamos sistemos, kurios nusakomos dviem skirtingomis būsenomis arba kuriuose tarp daugelio galimų būsenų yra efektyviai kontroliuojamos tik dvi skaičiavimams atlikti. Pavyzdžiui, jonų gaudyklėmis (angl. ion traps) pagrįsti kvantiniai procesoriai išnaudoja dalį pagautų jonų elektroninių ir vibracinių energijos lygmenų. Ne vien išimtinai atominio lygmens sistemos demonstruoja kvantinius reiškinius. Makroskopinio skaičiaus elektronų bendrosios krūvio kvantinės būsenos, vadinamos transmonais (angl. transmon), stabilizuojasi superlaidininkuose esant itin mažoms temperatūroms ir yra naudojamos šios architektūros kvantiniuose kompiuteriuose. Kitos technologijos, galinčios tapti svarbios ateityje, yra grindžiamos fotonika ir atominiais defektais puslaidininkiuose. Verta išskirti fotoninius įrenginius, kurie turi natūralų privalumą, nes gali būti paprasčiau integruojami į kvantinius tinklus išnaudojant egzistuojančius šviesolaidinius tinklus ir palydovus. Kvantiniai tinklai suteikia galimybes taikyti išskaidytą skaičiavimų modelį (angl. distributed computing) tarp ne itin galingų ankstyvosios raidos kvantinių kompiuterių, tačiau juos kartu sujungus galima efektyviai pasiekti didesnę skaičiavimų galią. 1.3 Tiuringo mašina Siekiant tiksliau palyginti kvantinių ir klasikinių kompiuterių skaičiavimų efektyvumą, verta trumpam grįžti prie klasikinio skaičiavimo modelio. Šiandieninių kompiuterių konceptas, apimantis pagrindinius jų ingredientus bei skaičiavimų universalumą, buvo suformuluotas Alano Tiuringo (angl. Alan Turing) 1930 metais. Tiuringo darbas šioje srityje buvo paskatintas kitų siekių ir tik vėliau buvo suprasta atradimo svarba universalaus kompiuterio gimimui. Tiuringas siekė atsakyti į žymaus matematiko Davido Hilberto (angl. David Hilbert) iškeltą klausimą ir iššūkį – surasti įrodymą: ar visada egzistuoja algoritmas, kuris naudodamas loginės sistemos aksiomas gali nuspręsti, ar pateiktas teiginys yra teisingas arba neteisingas? Prieš žygiuojant toliau priminsime, kad algoritmas – tai tiksliai nusakyta veiksmų seka ar instrukcijos, skirtos išspręsti užduotį. Su aritmetinio pobūdžio algoritmais susiduriama jau vidurinėje mokykloje, pavyzdžiui, naudojant Euklido (angl. Euclid) 2000 metų senumo algoritmus reikia atlikti dviejų skaičių dalybą su liekanomis arba didžiausio bendrojo daliklio paiešką. Algoritmų paskirtis gali būti įvairiausio pobūdžio, įskaitant duomenų apdorojimą ir automatizuotą sprendimų priėmimą. Algoritmus reikėtų atskirti nuo kompiuterio programų, kadangi algoritmai yra bendresnio pobūdžio instrukcijos ir egzistuoja nepriklausomai nuo programavimo kalbų. Skirtingos programavimo kalbos gali būti pavartojamos tam pačiam algoritmui įvykdyti. Hilbertas pats tikėjosi, kad visada galima rasti tokius algoritmus ir todėl iš principo įmanoma išspręsti visas problemas matematikoje. Įrodymas, kad matematikoje egzistuoja neišsprendžiamų problemų, dar tais pačiais metais buvo pateiktas Kurto Godelio (angl. Kurt Gödel) jo dviejose žymiose nepilnumo teoremose (angl. Gödel’s incompleteness theorems). Šios teoremos tvirtina, kad aksiomomis pagrįstose loginėse sistemose visada bus galima rasti teiginių, kurių neįmanoma nei įrodyti, nei paneigti. To nepavyks apeiti net ir įvedus papildomas aksiomas, t. y. išplečiant loginę sistemą, kadangi tokia sistema negalės užtikrinti savęs pačios nuoseklumo (užtikrinti neprieštaravimo pačiai sau). Tiuringas performulavo Gödelio rezultatus į algoritmų kalbą, kuriuos gali įvykdyti jo apibūdinta Tiuringo mašina. Tai idealizuotas konceptualus kompiuteris, turintis visus esminius šių dienų kompiuterio komponentus: skaitymo ir rašymo įrenginius, atmintį, procesorių. Tiuringo mašina gali atlikti visus skaičiavimus, kuriuos gali atlikti žmogus, tik efektyviai turi neribotą kiekį popieriaus ir rašymo priemonių. A. Tiuringas kartu su A. Churchu pateikė formalų algoritmo apibūdinimą (angl. Church-Turing thesis): Churcho–Tiuringo tezė: visos funkcijų klasės, apskaičiuojamos Tiuringo mašina, yra ekvivalentiškos klasei funkcijų, apskaičiuojamų naudojant algoritmą. Kitaip tariant, Tiuringo mašina gali įvykdyti bet kokį suformuluojamą algoritmą. Tai taikydamas Tiuringas parodė, kad egzistuoja kompiuteriu neišsprendžiamų algoritmų, vienas toks yra vadinamas sustojimo problema (angl. halting problem). Šiuolaikiniai programuojami kompiuteriai yra pagrįsti fon Noimano architektūra (angl. von Neumann architecture), pristatyta šio žymaus matematiko (angl. John von Neumann) ir realizuota 1940–1950 metais. Fon Noimano architektūra atspindi realizuotą Tiuringo mašiną, naudojančią technologiškai praktiškesnius sprendimus ir aritmetinę loginę sistemą (Būlio algebrą). Skaičiavimo galios ir universalumo atžvilgiu programuojamų šiandieninių kompiuterių modelis yra ekvivalentiškas Tiuringo mašinai su ribota atmintimi. Šie bendri principai leidžia suprasti, kad kvantinis kompiuteris negalės atlikti to, ko negali atlikti universali Tiuringo mašina, kuria galima modeliuoti ir kvantinius kompiuterius. Kvantinių kompiuterių pranašumas atsiskleidžia kvantinių algoritmų efektyvumu. 1.4 Skaičiavimų ištekliai Algoritmų kompleksiškumo analizės sritis parodo problemai spręsti reikalingus skaičiavimo išteklius – bendrai laiko, erdvės (atminties) ir energijos išteklius. Tradiciškai kompiuterių moksle laikas ir erdvė buvo pagrindiniai dominantys ištekliai. Jie leidžia nustatyti, ar tam tikros klasės problemos gali būti išsprendžiamos per atitinkamą laiką esant ribotai kompiuterio atminčiai. Yra nemažai problemų, kurios traktuojamos kaip sunkios ar net neįveikiamos dėl joms išspręsti reikalingų nepasiekiamo dydžio išteklių. Pavyzdžiui, geriausias žinomas klasikinis algoritmas skaičiaus faktorizavimui į dviejų pirminių skaičių sandaugą reikalauja eksponentiškai augančių laiko išteklių su faktorizuojamojo skaičiaus dydžiu. Ši problema neturi efektyvaus skaičiavimų metodo ir nuo sąlygiškai mažos įvesties dydžio tampa laiko atžvilgiu neįveikiama. Operacijų skaičius yra tiesiogiai susietas su laiko ištekliais, reikalingais atlikti algoritmą. Kompiuterio procesoriaus dažnis ir jo architektūros bei algoritmo paralelizavimo galimybės yra pagrindiniai veiksniai, kurie atspindi, kiek operacijų per laiko vienetą galima atlikti, ir todėl nusako bendrą algoritmo vykdymo laiką. Tiksliai nusakyti laiko išteklius yra keblu, kadangi net nežymiai pakeitus skaičiavimo modelį ar kompiuterio architektūrą tai gali juos paveikti. Tačiau dažnai mus domina esminė algoritmo elgsena bei viršutinės operacijų skaičiaus ribos. Asimptotinė algoritmo elgsena didėjant įvesties dydžiui leidžia tai įvertinti. Imkime pavyzdį: palyginkime du skirtingus algoritmus, atliekančius tą pačią užduotį. Reikalingas operacijų skaičius, kuris priklauso nuo įvesties tikslumo ar dydžio, nusakyto n-bitais, pirmajame algoritme yra \\(f(n) = n^3 + 10n + 100\\), o antrajame \\(g(n) = 1000n + \\log (n)\\). Šių funkcijų asimptotinė elgsena, kai \\(n\\rightarrow \\infty\\) (artėja prie labai didelio skaičiaus), yra atitinkamai \\(O(n^3 )\\) ir \\(O(n)\\). Simbolis \\(O\\) su skliausteliuose pažymėta funkcine forma yra vartojamas įvardyti funkcijos viršutinei elgsenos ribai ir blogiausiam scenarijui. Algoritmas \\(g(n)\\) su tiesine \\(O(n)\\) elgsena yra akivaizdžiai efektyvesnis, kai \\(n\\rightarrow \\infty\\), nepaisant didelio koeficiento šalia \\(n\\). Vertinant laiko išteklius, riba yra standartiškai nubrėžiama tarp algoritmų, kurių ištekliai auga: 1) kaip polinomas ir 2) kuriuose resursai auga greičiau nei bet koks polinomas (sakoma „superpolinomiškai”). Problema yra lengva, traktuojama, arba įmanoma, jeigu egzistuoja algoritmas, kuriam reikalingi polinominiai laiko ištekliai. Palyginimui, problema yra vadinama sunkia, netraktuojama, arba neįmanoma, jeigu ištekliai auga superpolinomiškai. Antruoju atveju įprasta sakyti, kad yra reikalaujama eksponentinio dydžio išteklių. Tai mažas piktnaudžiavimas eksponentinės funkcijos apibrėžimu, nes, pavyzdžiui, \\(n^{\\log n}\\) auga greičiau nei bet kuris polinomas, bet lėčiau nei tikra eksponentinė funkcija. Aišku, galima įsivaizduoti ir polinomą su itin dideliu koeficientu (pvz., \\(n^{1000}\\)), kuriam gali prireikti daugiau operacijų nei kai kurioms eksponentėms (pvz., \\(2^{n/1000}\\)). Tačiau praktikoje algoritmų su dideliais koeficientais retai pasitaiko, ir istoriškai polinominiai algoritmai pasitvirtina esantys efektyvesni. 1.2 pav. pateikiame kreives keleto dažnai aptinkamų kompleksiškumo klasės funkcijų, palyginančių, kaip auga operacijų skaičius didėjant įvesties dydžiui. Atkreipiame dėmesį, kad čia vertikalioji ašis užsibaigia tik ties 2000. 1.2 pav. Keletas algoritmų sudėtingumo pavyzdžių. Nuo sparčiausiai iki lėčiausiai augančio operacijų skaičiaus: eksponentinė elgsena, polinominė, logtiesinė ir tiesinė Galime palyginti laiko išteklius keletui kvantinių ir klasikinių algoritmų, skirtų atlikti tą pačią užduotį. Faktorizuojant pirminius skaičius geriausiam žinomam klasikiniam algoritmui reikalinga \\(O\\left( e^{n^{\\frac{1}{3}}\\log (n)^{\\frac{2}{3}}} \\right)\\) operacijų, o kvantiniam Šoro – \\(O\\big( n^2 \\log (n)\\log (\\log(n))\\big)\\). Šis eksponentinis pagreitinimas yra artimai susietas su Šoro algoritme taikoma kvantine Furjė transformacija (angl. quantum Fourier transform), kuriai reikalinga \\(O(n^2 )\\) operacijų. Klasikinei diskrečiajai Furjė transformacijai (angl. fast Fourier transform) reikalinga eksponentiškai daugiau operacijų, \\(O(n2^n )\\). Taip pat galima paminėti nestruktūrizuotų duomenų bazių Groverio kvantinės paieškos algoritmą (angl. Grover algorithm), kuriam reikia \\(O\\left(\\sqrt{n}\\right)\\) operacijų ir kuris suteikia kvadratinį pagreitinimą prieš klasikinę paiešką \\(O(n)\\). Algoritmui reikalingi erdvės ištekliai yra ne kas kita, kaip atminties ištekliai. Atminties išteklių esminis augimas didėjant įvesties dydžiui \\(n\\) yra taip pat nusakomas \\(O\\) simboliu. Laiko ir atminties ištekliai gali augti tokiu pačiu tempu, jeigu kiekviename algoritmo žingsnyje yra reikalaujama nauja atminties celė. Atminties ištekliai skiriasi nuo laiko, nes dažnai yra įmanoma atlaisvinti nenaudojamos atminties išteklius. Nėra įrodyta, kad kvantiniai algoritmai turi pranašumą atminties išteklių srityje. Nors tai neatspindi algoritmų atminties sudėtingumo, tačiau šioje vietoje verta pabandyti lyginti klasikinių bei kvantinių kompiuterių atminties talpą. Informacija yra įrašoma kvantinio kompiuterio kubitų registre. Registras, sudarytas iš \\(n\\) kubitų, gali būti \\(2^n\\) skirtingose būsenose vienu metu, o kiekvieną būseną nusakančios amplitudės yra kompleksiniai skaičiai. Galime pažiūrėti, kiek informacijos baitais atitiktų, pavyzdžiui, 50 kubitų registras klasikiniame kompiuteryje. Pirmiausiai atkreipiame dėmesį, kad nusakyti tolydžiai kintančią kubito amplitudę iš principo reikėtų begalinio tikslumo ir todėl formaliai begalinės informacijos kiekio. Tačiau praktiškai kvantiniame kompiuteryje tikslumas bus taip pat ribotas (dėl triukšmo, loginių vartų netikslumų), tad skaičiaus tikslumui apsiribosime 32 bitais (angl. single-precission floating-point number). Nusakyti bendrai 50 kubitų sistemos būsenai reikia \\(2^{50}\\) kompleksinių amplitudžių, kiekvienai iš jų reikia 2 realiųjų skaičių, kurių kiekvienas užima 32 bitus. Tad iš viso reikalaujama 8 petabaitų atminties. Tai yra artima darbinei atminčiai, kurią vienas iš pajėgiausių superkompiuterių (IBM Summit) šios knygos rašymo metu geba pasiūlyti. Dėl eksponentinio atminties reikalavimų augimo kvantinio kompiuterio veikimo modeliavimas pradedant nuo maždaug 50–60 kubitų ribos tampa labai greitai neįveikiamas net ir sudėjus visas planetos atminties saugyklas. Šiuo požiūriu kvantinis kompiuteris gali pasiūlyti didesnę atminties talpą, negu kada nors bus įmanoma pasiekti klasikiniais įrenginiais. Čia svarbus priminimas, kad tai yra kvantinė informacija, saugoma būsenų superpozicijose. Šią informaciją galima efektyviai apdoroti, tačiau, kitaip nei klasikinės, jos visos tiesiogiai nuskaityti neįmanoma. Galime sakyti, kad kvantinė informacija yra paslėpta arba potenciali. Minėtame pavyzdyje pamatavę 50 kubitų gausime 50 bitų, o ne 8 petabaitų dvejetainių skaičių seką. Energija yra kitas svarbus skaičiavimų išteklius ir gali būti susietas su laiko bei erdvės ištekliais, reikalingais atlikti algoritmą. Su vadinamąja galios siena (angl. power wall) klasikiniai kompiuteriai susidūrė dar 2000 metų pradžioje, kai buvo pasiekti maždaug 3,5 GHz procesorių dažniai. Kiekviename klasikinio procesoriaus cikle, kai tranzistorių loginės būsenos pasikeičia (\\(0 \\rightarrow 1\\), \\(1 \\rightarrow 0\\)), yra išeikvojama energija ir išsklaidoma šilumos forma. Standartiniai CMOS (angl. complementary metal-oxide-semiconductor) tranzistorių technologija pagrįsti procesoriai itin pažengė mažinant energijos sąnaudas, daugiausia mažinant tranzistorių įtampą loginėms vertėms keisti. Norint toliau didinti klasikinių kompiuterių galią svarbu atrasti būdą, kaip tokiu pačiu greičiu ar sparčiau mažinti jų energijos sąnaudas. Nors šiuo metu klasikiniai procesoriai eikvoja energiją dėl neoptimalių technologijų, tačiau egzistuoja ir fundamentali riba, įvardijanti minimalią energijos kainą ištrinant informaciją. Landauerio principas (angl. Landauer principle) teigia, kad informacija ir energija yra artimai susietos: Landauerio principas: kiekvieną kartą, kai ištrinamas vienas bitas informacijos, į aplinką yra išsklaidoma bent \\(k_{\\mathrm{B}}T\\log (2)\\) energijos. Čia \\(k_{\\mathrm{B}}\\) yra Bolcmano konstanta, \\(T\\) – kompiuterio aplinkos temperatūra. Tai suteikia užuominą, kad informacija nėra vien abstraktus konceptas, tačiau gali būti prilyginta kitiems fizikiniams dydžiams. Atliekant skaičiavimus klasikiniame procesoriuje dalis informacijos yra visada ištrinama dėl juose naudojamų negrįžtamųjų loginių vartų. Pavyzdžiui, plačiai naudojamuose loginiuose vartuose NAND (angl. negated AND) yra įvestis dviem bitams ir išvestis vienam bitui: \\((0,0)\\rightarrow 1\\), \\((0,1)\\rightarrow 1\\), \\((1,0)\\rightarrow 1\\), \\((1,1)\\rightarrow 0\\). Čia skliausteliuose nurodyta įvesties bitų vertė ir rodyklyte – išvesties bitas. Jeigu išvesties bito vertė yra 1, tada galimos trys skirtingos įvesties bitų kombinacijos. Todėl neįmanoma unikaliai pasakyti, kokie buvo įvesties bitai iš trijų kombinacijų, ir dėl šios priežasties vienas bitas informacijos yra negrįžtamai prarandamas. Landauerio ribą galima apeiti naudojant grįžtamuosius loginius vartus ir neištrinant informacijos skaičiavimo procese. Tam atliekamas įprastas skaičiavimas, o pabaigoje registras yra grąžinamas į pradinę loginę būseną termodinamiškai grįžtamuoju būdu. Klasikiniuose skaičiavimuose galima pasitelkti vien tik grįžtamuosius loginius vartus, tačiau procesorių architektūra sudėtingėja, tam reikia papildomų bitų ir loginių vartų. O štai kvantiniame kompiuteryje skaičiavimai yra pagrįsti grįžtamaisiais loginiais vartais, mat kvantinės fizikos dėsniai yra fundamentaliai grįžtamieji. Kitaip tariant, kvantiniame kompiuteryje galima atsukti laiką atgal. Tam tereikia pritaikyti atvirkštinius loginius vartus atvirkštine tvarka. Tiesa, informacija kvantiniame procesoriuje yra trinama kubitų būsenų matavimo ir dekoherencijos procesų metu. Tačiau išsklaidoma Landauerio energija auga tiesiškai su kubitu skaičiumi \\(n\\), o ne eksponentiškai su galimų būsenų skaičiumi \\(2^n\\). Tai bendrai yra gera žinia, kadangi kvantiniai kompiuteriai turi potencialą dominuoti ateityje atliekant intensyviausius skaičiavimus. 1.5 Kvantiniai bitai Klasikinėje kompiuterijoje informacija yra koduojama naudojant „abėcelę”, turinčią dvi skirtingas „raides”, standartiškai įvardijamas 0 ir 1, kurios nusako elementariausią loginę sistemos būseną. Mažiausias klasikinės informacijos vienetas bitas (angl. binary digit) atspindi šią dvejetainę būseną. Kadangi dvejetainių skaičių seka yra diskrečioji, joje koduojama informacija vadinama skaitmenine. Tai galima palyginti su informacija, laikoma analoginiu pavidalu, pavyzdžiui, vinilinėse plokštelėse, kuriose garso įrašas kinta tolydžiai su paviršiaus įspaudimo gyliu ir deformacijomis. Bitas yra matematinis objektas, turintis dvejetainę savybę, ir nepriklauso nuo jį realizuojančių fizinių sistemų. Tai itin pravartu, kadangi naudojant vien abstrakčius matematinius objektus ir taikant su jais susietą operacijų logiką galima formuluoti skaičiavimo modelius ir testuoti informacines teorijas nesirūpinant dėl fizinio lygmens. Pagrindinis reikalavimas fiziniame lygmenyje yra tas, kad bitą realizuojantis darinys turėtų dvi būsenas, kurias būtų lengva atskirti ir keisti panorėjus. Fizinė sistema, realizuojanti skaitmeninę informaciją, neprivalo būti savaime diskreti. Tranzistoriais pagrįstuose procesoriuose bitų vertės yra koduojamos elektros įtampa, kuri nusako tolydžiai kintantį fizikinį dydį. Šis iš esmės analoginis signalas yra skaitmenizuojamas diskrečiosiomis elektroninių grandinių įtampomis \\(V=0\\) ir \\(V=V_0\\), koduojančiomis bito būsenas 0 ir 1. Kvantinis bitas (kubitas) taip pat gali būti realizuojamas skirtingomis fizinėmis sistemomis. Kubitą apibūdiname nusakydami jo būseną, tačiau tai yra iš esmės kitoks matematinis objektas nei klasikinis bitas. Kubito būsena yra įvardijama vektoriumi 2 dimensijų kompleksinėje vektorių erdvėje ir bendrai užrašoma taip: \\[\\begin{equation} |\\psi \\rangle = a|0\\rangle + b|1\\rangle\\,. \\tag{1.1} \\end{equation}\\] Formaliai šis objektas leidžia apskaičiuoti rezultatų tikimybes nustatant kvantinės sistemos būseną, kuri buvo paruošta taikant žinomą procedūrų seką. Nei daugiau, nei mažiau. Kaip ir klasikinis bitas, kubitas gali būti būsenoje 0, nusakomoje \\(|0\\rangle\\), būsenoje 1, nusakomoje \\(|0\\rangle\\), tačiau kartu ir begalybėje kitų skirtingų būsenų kombinacijų tolydžiai keičiant koeficientus \\(a\\) ir \\(b\\). Terminai „kvantinė būsena” ir „vektorius” šiame kontekste dažnai vartojami pakaitomis ir reiškia tą patį, nes kvantinė būsena yra visiškai nusakoma vektoriumi. Vartojami skliausteliai \\(|\\ldots\\rangle\\) indikuoja, kad šis objektas yra vektorius. Kubito būseną žymime savo nuožiūra pasirinktu simboliu, šiuo atveju viršuje graikiška raide \\(\\psi\\) (tariama psi). Vektorius \\(|\\psi\\rangle\\) yra kitų dviejų vektorių, \\(|0\\rangle\\) ir \\(|1\\rangle\\), vadinamų skaičiuojamaisiais baziniais vektoriais (angl. computational basis vectors), kombinacija. Baziniai vektoriai atlieka panašią funkciją kaip ilguma ir platuma geografinėje sistemoje nusakyti objekto padėčiai Žemės paviršiuje. Santykinai su baziniais vektoriais yra įvardijama \\(|\\psi\\rangle\\) orientacija vektorių erdvėje. Koeficientai \\(a\\) ir \\(b\\), formaliai vadinami amplitudėmis, yra kompleksiniai skaičiai (turi realiąją ir menamąją dalis). Amplitudės gali kisti tolydžiai, tačiau yra tarpusavyje susietos taip, kad jų (kompleksinių) kvadratų suma susidėtų į vienetą (sakoma, kad yra normuotos): \\[\\begin{equation} |a|^2 + |b|^2 = 1\\,. \\tag{1.2} \\end{equation}\\] Šis reikalavimas reiškia, kad kubitų būsenos \\(|\\psi\\rangle\\) yra visada nusakytos vienetinio ilgio vektoriumi. Vieno kubito būsenas galime iliustruoti grafiškai pasitelkdami vadinamąją Blocho sferą (angl. Bloch sphere). Vieną kubitą perteikiame perrašę kompleksines amplitudes \\(a\\) ir \\(b\\) taip, kad jos būtų parametrizuotos kampais \\(\\theta\\) ir \\(\\varphi\\), nurodytais sferoje (žr. 1.3 pav.): \\[\\begin{equation} |\\psi\\rangle = \\cos\\left(\\frac{\\theta}{2}\\right) |0\\rangle + \\mathrm{e}^{\\mathrm{i}\\varphi}\\sin\\left(\\frac{\\theta}{2}\\right)|1\\rangle\\,. \\tag{1.3} \\end{equation}\\] Kubito būsena yra nusakoma Blocho vektoriumi, pavaizduotu nuo centro iki Blocho sferos paviršiaus. Matome, kad skirtingos kubito būsenos nusako skirtingą vektoriaus orientaciją, tačiau išlaiko vienetinį jo ilgį. Pavyzdžiui, būsenos \\(|0\\rangle\\) ir \\(|1\\rangle\\) yra Blocho vektoriaus pozicijos išilgai \\(z\\) ašies ir nukreiptos į viršų arba į apačią (\\(\\theta = 0^{\\circ}\\,,180^{\\circ}\\)), atitinkamai. Sferos pusiaujas (\\(\\theta = 90^{\\circ}\\)) nusako visas \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenų superpozicijas, kurios skiriasi viena nuo kitos tik santykiniu \\(\\mathrm{e}^{\\mathrm{i}\\varphi}\\) fazės nariu, parametrizuojamu azimutiniu kampu \\(\\varphi\\). Visi įmanomi vektoriai nuo centro iki bet kurio taško sferos paviršiuje įvardija visas galimas kubito būsenas. 1.3 pav. Blocho sfera Siekdami sužinoti kubito būseną mes turime jį pamatuoti (angl. state measurement). Būsenų amplitudžių kvadratas nusako galimus matavimo rezultatus ir jų tikimybes. Matavimo procesą šiame skyriuje simboliškai rašysime \\(M\\) raide, prišlieta prie kubito būsenos \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\). Atlikus kubito matavimą galima rasti \\(|0\\rangle\\) būseną su tikimybe \\(p = |a|^2\\) arba \\(|1\\rangle\\) su tikimybe \\(p = |b|^2\\): \\[\\begin{align} M|\\psi\\rangle \\rightarrow &amp; |0\\rangle\\,,\\qquad p = |a|^2\\,,\\tag{1.4}\\\\ M|\\psi\\rangle \\rightarrow &amp; |1\\rangle\\,,\\qquad p = |b|^2\\,.\\tag{1.5} \\end{align}\\] Matavimas priverčia kubitą „pasirinkti” vieną iš dviejų galimų būsenų, \\(|0\\rangle\\) arba \\(|1\\rangle\\), o superpozicijos būsena yra negrįžtamai prarandama. Kartais dar sakoma, kad superpozicijos būsena suyra (angl. state collapse). Amplitudžių kvadratų vienetinė suma atspindi tai, kad tikimybė \\(p\\) rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\) būseną turi susidėti į 1. Čia naudojame trupmenas vietoj procentų nusakyti tikimybėms, pavyzdžiui, \\(p = 0.75\\) nusako 75% tikimybę. Siekdami pabrėžti statistinį matavimų aspektą, imkime pavyzdį \\(|\\psi\\rangle\\) būsenos, kurioje amplitudės yra \\(a = \\mathrm{i}\\sqrt{0.7}\\) ir \\(b = \\sqrt{0.3}\\). Paruošus daugybę kubitų identiškoje \\(|\\psi\\rangle\\) būsenoje ir visiems atlikus būsenų matavimus, 0.7 visų kartų bus rasta būsena \\(|0\\rangle\\) bei 0.3 visų kartų \\(|1\\rangle\\). Panašiai kaip metant monetą – nors ir žinome, kad tikimybė gauti vieną iš dviejų rezultatų turėtų būti \\(p = 0.5\\), tačiau norint šį statistinį faktą realizuoti reikia kartoti monetos metimą begalę kartų. Trumpoje sekoje ši statistika gali drastiškai skirtis nuo \\(p = 0.5\\), kadangi atskiri monetos metimo rezultatai nėra priklausomi vienas nuo kito. Net ir paruošus identišką kubito būseną ir ją pamatavus begalę kartų, koeficientų \\(a\\) ir \\(b\\) unikaliai įvardyti taip nepavyks. Žinosime tik jų (kompleksinius) kvadratus \\(|a|^2\\) ir \\(|b|^2\\), nusakančius tikimybes rasti \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenas. Mat kubito amplitudės \\(a\\) ir \\(b\\) yra kompleksiniai skaičiai, kuriuos bendrai užrašome \\(z = |z| \\mathrm{e}^{\\mathrm{i}\\varphi}\\). Čia \\(|z|\\) yra kompleksinio skaičiaus \\(z\\) modulis, o narys \\(\\mathrm{e}^{\\mathrm{i}\\varphi}\\) nusako santykinę fazę. Santykinė fazė tarp kubitų būsenų \\(|0\\rangle\\) ir \\(|1\\rangle\\) yra svarbi ir turi fiziškai stebimą efektą, tačiau informacija apie ją kompleksiniame kvadrate ir matavimo proceso metu yra prarandama. Tad galime klausti, jeigu neįmanoma atskleisti bendros kubito superpozicijos būsenos, kaip žinoti, kad visas šis reikalas nėra susigalvota matematinė iliuzija? Nors matavimas pakeičia kubito būseną atsitiktinai, tačiau iki matavimo būsenas kvantiniame kompiuteryje galime keisti deterministiškai. Būsenų transformacijose atsitiktinumų nėra, todėl pradėję nuo, pavyzdžiui, \\(|1\\rangle\\) būsenos, galime patikrinti, ar po sekos transformacijų matavimų tikimybės atitinka spėjimus, nusakomus \\(|a|^2\\) ir \\(|b|^2\\). Kvantinių būsenų tomografija (angl. quantum state tomography) yra vienas metodas, leidžiantis unikaliai nusakyti būseną. Šis metodas reikalauja paruošti identišką kvantinę būseną daugybę kartų ir atlikti sumaniai parinktus skirtingo tipo būsenų matavimus. Kvantinių būsenų tomografija nėra įprastai taikoma kvantinėje kompiuterijoje, tačiau leidžia atlikti diagnostines užduotis. Vis dėlto, turint tik vieną kubitą nežinomoje superpozicijos būsenoje, atskleisti amplitudžių \\(a\\) ir \\(b\\), kitaip tariant, pasakyti, kokia yra būsena \\(|\\psi\\rangle\\) prieš matavimą – iš esmės neįmanoma. Kiek žinoma, kvantiniuose matavimuose stebimas atsitiktinumas yra vienintelis tikras atsitiktinis procesas gamtoje (angl. true quantum randomness). Vis dar nėra suprastos to ištakos – kvantinėje fizikoje šis faktas tiesiog pateikiamas kaip postulatas. Vienas iš bandymų tai paaiškinti traktuoja viską, įskaitant matavimo įrenginį ir patį eksperimentuotoją, kvantiniu lygmeniu. Tada visas procesas turėtų būti unitarinis ir be atsitiktinumų. Kažkas panašaus į matavimo procesą galėtų atsirasti dėl mikroskopinio dydžio daiktų sparčios dekoherencijos. Nepaisant atliktų darbų šioje srityje, nėra sutarimo, ar taip įmanoma įrodyti matuojant stebimą atsitiktinumą. Tad nors kvantinė mechanika ir turi interpretacinių klaustukų, tačiau gali tiksliau nei bet kuri kita teorija apibūdinti stebimą pasaulį. Tuo mes ir vadovaujamės kvantinės kompiuterijos taikymuose nesigilindami į filosofinius aspektus. Šis pragmatinis principas yra Davido N. Mermino vadinamas „tylėk ir skaičiuok” (angl. shut up and calculate). Gebėjimas beprecedentiškai tiksliai kontroliuoti kvantines sistemas ir besivystantis kvantinės informatikos mokslas galbūt ateityje leis geriau suprasti keistąsias šios teorijos savybes. Dabar aptarsime, kaip perteikti būsenas, sudarytas iš daugiau nei vieno kubito. Tam pirmiausiai imkime du klasikinius bitus. Du bitai vienu metu gali būti vienoje iš keturių skirtingų būsenų \\(\\{00, 01, 10, 11\\}\\). Vadovaujantis kvantinės superpozicijos principu, bendra 2 kubitų būsena \\(|\\psi\\rangle\\) yra visų šių klasikinių bitų būsenų superpozicija: \\[\\begin{equation} |\\psi\\rangle = a|00\\rangle + b|01\\rangle + c|10\\rangle + d|11\\rangle\\,. \\tag{1.6} \\end{equation}\\] Vektorius \\(|\\psi\\rangle\\) yra nusakomas įvardijant keturias amplitudes, prišlietas prie \\(\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}\\) 2 kubitų skaičiuojamųjų bazinių vektorių. Pirmo kubito \\(k_1\\) būsena yra įvardijama kairiuoju skaičiumi, o antro \\(k_2\\) – dešiniuoju, \\(|k_1 k_2 \\rangle\\). Formaliai \\(|k_1 k_2 \\rangle\\) nusako vektorių \\(|k_1 \\rangle\\) ir \\(|k_2 \\rangle\\) tenzorinę sandaugą, žymimą \\(|k_1 k_2 \\rangle \\equiv |k_1\\rangle\\otimes |k_2 \\rangle\\), ir yra apibrėžtas 4 dimensijų kompleksinėje vektorių erdvėje. Keičiant amplitudes yra keičiama \\(|\\psi\\rangle\\) vektoriaus orientacija šioje vektorių erdvėje. Amplitudės tarpusavyje vėlgi susietos taip, kad jų (kompleksinių) kvadratų suma susidėtų į vienetą: \\[\\begin{equation} |a|^2 +|b|^2 + |c|^2 + |d|^2 = 1\\,. \\tag{1.7} \\end{equation}\\] Matavimo \\(M|\\psi\\rangle\\) pabaigoje gauname du bitus informacijos, susietus su viena iš keturių galimų būsenų. Tikimybė rasti bet kurią iš jų vėlgi nusakoma tos būsenos amplitudės kvadratu: \\[\\begin{align} M|\\psi\\rangle \\rightarrow &amp;|00 \\rangle\\,,\\qquad p = |a|^2\\,, \\tag{1.8}\\\\ M|\\psi\\rangle \\rightarrow &amp;|01 \\rangle\\,,\\qquad p = |b|^2\\,, \\tag{1.9}\\\\ M|\\psi\\rangle \\rightarrow &amp;|10 \\rangle\\,,\\qquad p = |c|^2\\,, \\tag{1.10}\\\\ M|\\psi\\rangle \\rightarrow &amp;|11 \\rangle\\,,\\qquad p = |d|^2\\,. \\tag{1.11} \\end{align}\\] Galiausiai kvantinio registro, sudaryto iš \\(n\\) kubitų, būsena yra įvardijama visų \\(2^n\\) bazinių vektorių kombinacija ir nusakoma \\(2^n\\) dimensijų vektorių erdvėje. Ši superpozicijos būsena glaustai užrašoma pasitelkiant sumos simbolį: \\[\\begin{equation} |\\psi\\rangle = \\sum_{x = 0}^{2^n - 1}c_x |x\\rangle\\,. \\tag{1.12} \\end{equation}\\] Čia \\(c_x\\) yra \\(|x\\rangle\\) bazinio vektoriaus amplitudė, o amplitudžių kvadratų suma tenkina \\(\\sum_x |c_x|^2 = 1\\). Kiekvienas bazinis vektorius \\(|x\\rangle\\) yra formaliai pavienių \\(n\\) kubitų tenzorinė sandauga \\(|x\\rangle \\equiv |k_1 \\rangle\\otimes |k_2 \\rangle\\otimes\\ldots\\otimes |k_n \\rangle\\), \\(k_i \\in \\{ 0,1\\}\\). Atlikę visų \\(n\\) kubitų būsenų matavimus rasime \\(n\\) bitų seką, nusakomą vienu iš galimų superpozicijoje esančių būsenų \\(|x\\rangle\\) su tikimybe \\(|c_x|^2\\). 1.6 Kvantinės informacijos apdorojimas Kompiuterių mokslas teigia, kad pasitelkiant vos keletą skirtingų elementarių loginių elementų ir sujungiant juos kartu galima realizuoti visus įmanomus skaičiavimus. Klasikiniame procesoriuje dvejetainė informacija yra apdorojama pasitelkiant loginius vartus. Skirtingi loginiai vartai turi tam tikrą skaičių įvesties ir išvesties jungčių, į kurias galime įsivaizduoti ateinant laidus. Laidais tarp loginių vartų keliaujantis elektros signalas dviejų skirtingų verčių įtampos pavidalu nusako keliaujančius bitus. Loginiai vartai su atkeliavusiais bitais gali atlikti skirtingas elementariąsias bitų transformacijas. Pavyzdžiui, loginiai vartai, kurie turi po vieną įvesties ir išvesties bitą, gali būti tik dviejų rūšių. Pirma iš jų palieka išvesties bito vertę tokią pačią, kaip ir įvesties \\(0\\rightarrow 0\\), \\(1\\rightarrow 1\\) ir nusako trivialų identitetą, dar vadinama tapatybės transformacija (angl. identity). Antrojo tipo vartai išvestyje apverčia įvesties bito vertę \\(0\\rightarrow 1\\), \\(1\\rightarrow0\\) ir yra žinomi kaip NOT. Kiti elementarūs loginiai vartai AND, OR, NAND turi įvestį dviem bitams ir vieną išvesties bitą. Norint atlikti visus įmanomus klasikinius skaičiavimus, tai yra pasiekti skaičiavimų universalumą, pakanka vien AND ir NOT, arba vien tik NAND loginių vartų, iš kurių kombinacijų konstruojamos loginės grandinės. Dvejetainis elektros signalas, praėjęs tokią programuojamą loginę grandinę, yra pakeičiamas kita seka taip atliekant dvejetainių skaičių aritmetiką ir logines operacijas. Likusią kompiuterio įrangą galima vadinti išoriniais elementais, kurie padeda pateikti informaciją į procesoriaus loginių operacijų elementą ir iš jo paimti bei perteikti apdorotą informaciją. Norint suprasti pagrindinius kvantinės informacijos apdorojimo principus galima taip pat apsiriboti kvantinio procesoriaus veikimo funkcijomis. Kaip ir klasikinis procesorius, kvantinis procesorius vykdo pateiktas logines grandines, sudarytas iš loginių vartų sekų. Vieno kubito atveju kvantinių loginių vartų efektą galima iliustruoti kaip Blocho vektoriaus krypties keitimą Blocho sferoje. Kitaip nei klasikiniame procesoriuje, kuriame vieno bito galimos transformacijos yra tik tapatybės transformacija ir NOT loginiai vartai, skirtingų 1 kubito transformacijų iš principo yra begalybė. Tai yra dėl to, kad amplitudės, nusakančios kubito būseną, gali kisti tolydžiai, tad Blocho vektoriaus pasukimas apie tam tikrą Blocho sferos ašį skirtingais kampais formaliai nusako skirtingus loginius vartus. Kaip ir klasikiniame, kvantiniame procesoriuje galima rasti universalų rinkinį loginių vartų, kurių kombinacijos leidžia atlikti visas įmanomas kvantinio registro būsenų transformacijas ir todėl galiausiai – visus suformuluojamus algoritmus. Kubitų loginiai vartai yra apibūdinami matematiniais objektais, kurie vadinami tiesiniais operatoriais. Šie operatoriai turi svarbią savybę – veikdami bendrą kvantinę būseną, nusakytą vektoriumi \\(|\\psi\\rangle\\), jie keičia tik šio vektoriaus orientaciją vektorių erdvėje, tačiau nekeičia vektoriaus ilgio. Ši savybė vadinama unitarumu (angl. unitarity) ir užtikrina, kad loginiai vartai nepažeidžia tikimybinio būsenų matavimo principo – visų galimų matavimo rezultatų tikimybės \\(p\\) susidės į 1. Norint sužinoti kvantinių loginių vartų efektą bendrai superpozicijos būsenai pakanka žinoti, kaip atitinkamas operatorius \\(U\\) veikia kiekvieną skaičiuojamąjį vektorių atskirai: \\[\\begin{equation} U|\\psi\\rangle = U(a|0\\rangle + b|1\\rangle) = a( U|0\\rangle) + b(U|1\\rangle)\\,. \\tag{1.13} \\end{equation}\\] Skaičius (amplitudes) \\(a\\) ir \\(b\\) iškėlėme už skliaustelių norėdami aiškiau parodyti, kad operatoriai veikia vektorius ir kiekvieną jų superpozicijoje vienu metu. Pavyzdžiui, kvantiniai loginiai vartai NOT, žymimi simboliu \\(X\\) ir veikiantys superpozicijos būseną \\(|\\psi\\rangle\\), turi šį efektą: \\[\\begin{equation} X|\\psi\\rangle = a(X|0\\rangle) + b(X|1\\rangle) =a|1\\rangle + b|0\\rangle\\,. \\tag{1.14} \\end{equation}\\] Jų efektas baziniams vektoriams yra \\(X|0\\rangle = |1\\rangle\\) ir \\(X|1\\rangle = |0\\rangle\\). Matome elementariausią kvantinio paralelizmo pavyzdį, kai pritaikius vieną loginę operaciją ji yra įvertinama visuose superpozicijos nariuose vienu metu. Klasikiniame kompiuteryje, norint apskaičiuoti funkcijos \\(f(x)\\) vertes su reikšmėmis \\(x\\), reikia \\(f(x)\\) įvertinti su kiekviena \\(x\\) reikšme atskirai. Tad jeigu funkcijos reikšmes \\(x\\) koduojame skirtingais kubitų skaičiuojamaisiais vektoriais, superpozicijos principas ir tiesinis operatorių veikimas leidžia įvertinti vienu funkcijos \\(f\\) iškvietimu visas reikšmes tuo pačiu metu. Kvantinės būsenos ir jas transformuojantys operatoriai yra realizuojami tiesinėje algebroje stulpeliniais vektoriais ir matricomis, atitinkamai. Vieno kubito būsena gali būti išreikšta bet kuriuo iš šių būdų: \\[\\begin{equation} |\\psi\\rangle = a|0\\rangle + b|1\\rangle = a\\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix} + b\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}\\,. \\tag{1.15} \\end{equation}\\] Visi operatoriai, keičiantys 1 kubito būseną, yra realizuojami (\\(2\\times 2\\)) dydžio matricomis. Pavyzdžiui, kvantinių NOT bei vadinamųjų Hadamardo loginių vartų (angl. Hadamard, trumpinys \\(H\\)) veiksmai kubito būsenai \\(|1\\rangle\\) atrodo taip: \\[\\begin{align} X|1\\rangle = &amp;\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix} = |0\\rangle\\,, \\tag{1.16}\\\\ H|1\\rangle = &amp;\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\\\ \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -1 \\\\ \\end{bmatrix} = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\,.\\tag{1.17} \\end{align}\\] Iš pateiktų pavyzdžių matyti, kad \\(H\\) ir \\(X\\) vartai yra sau atvirkštiniai. Atlikus du veiksmus vieną po kito, pavyzdžiui, \\(HH\\), kubito būsena nepakinta. Iš tiesų visi loginiai vartai kvantinėje kompiuterijoje turi sau atvirkštinius loginius vartus arba yra patys sau atvirkštiniai. Pasukus būseną nusakantį vektorių tam tikra kryptimi, atvirkštiniai loginiai vartai atsuka šį vektorių atgal atbuline kryptimi išlaikydami jo ilgį. Tiesinėje algebroje \\(n\\) kubitų būseną nusakantis vektorius yra stulpelis su \\(2^n\\) elementų, o loginiai vartai yra \\((2^n \\times 2^n)\\) dydžio unitarinės matricos. Jos nusako \\(n\\) kubitų būsenos transformaciją – vektoriaus posūkį \\(2^n\\) dimensijų vektorių erdvėje. Tačiau norint atlikti visas įmanomas \\(n\\) kubitų būsenų transformacijas nepakanka, kad kiekvienam kubitui atskirai veiktų 1 kubito loginiai vartai. Tai pirmiausiai matome todėl, kad didžioji dalis \\(2^n\\) skirtingų superpozicijos būsenų yra supintos. Supynimas yra nelokalus efektas, jo neįmanoma nei įvesti, nei panaikinti atliekant kvantines transformacijas su pavieniais kubitais. Nelokalios transformacijos yra reikalingos sukurti supintosioms būsenoms ir taip atlikti bendresnes n kubitų būsenų transformacijas. Kaip tik galėjimas panaudoti visą eksponentiškai didelę būsenų erdvę suteikia kvantiniams kompiuteriams pranašumą prieš klasikinius įrenginius. Sąlyginiai 2 kubitų loginiai vartai \\(CNOT\\) (angl. controlled NOT, trumpinys \\(cX\\)) kartu su bendro tipo 1 kubito vartais leidžia realizuoti vieną galimą universalų rinkinį. Vartai \\(cX\\) apverčia antrojo kubito būseną, jeigu pirmojo kubito būsena yra \\(|1\\rangle\\), ir palieka ją nepakeistą, jeigu pirmasis yra \\(|0\\rangle\\). Fiziškai tai apibūdina sąveikas tarp dviejų kubitų. Vienas pavyzdys \\(cX\\), veikiančių 2-kubitų būseną \\(|11\\rangle\\) tiesinėje algebroje: \\[\\begin{equation} cX|11\\rangle = \\begin{bmatrix} \\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{matrix} &amp; \\begin{matrix} 0 &amp; 0 \\\\ 0 &amp; 0 \\\\ \\end{matrix} \\\\ \\begin{matrix} 0 &amp; 0 \\\\ 0 &amp; 0 \\\\ \\end{matrix} &amp; \\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{matrix} \\\\ \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix} = |10\\rangle\\,. \\tag{1.18} \\end{equation}\\] Tačiau kvantinėje kompiuterijoje galime pritaikyti \\(cX\\), kai pirmas kubitas yra \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenų superpozicijoje. Tai nusako klasikinėje kompiuterijoje analogo neturinčią deterministinę operaciją – kvantinį supynimą: \\[\\begin{equation} cX(a|0\\rangle + b|1\\rangle)\\otimes |0\\rangle = a|00\\rangle + b|11\\rangle\\,. \\tag{1.19} \\end{equation}\\] Kubitų būsenų transformacijas galima itin paprastai ir intuityviai iliustruoti. Kiekvienam kubitui yra priskiriama atskira grandis – horizontali linija, o loginių vartų sekos yra išrikiuojamos iš kairės į dešinę ir pavaizduoja laike atliekamas būsenų tranformacijas. Skaičiavimo pradžioje kubitai yra standartiškai inicijuojami (angl. reset) į pradines \\(|0\\rangle\\) būsenas. Tokios diagramos yra vadinamos kvantinėmis grandinėmis (angl. quantum circuits). 1.4 pav. Kvantinės grandinės pavyzdys 1.4 pav. kvantinėje grandinėje matome 1 kubito vadinamuosius Pauli-\\(X\\) vartus (žali); loginiai vartai, veikiantys du ar daugiau kubitų, turi vertikalią kubitų grandines jungiančią liniją. Tarp jų yra 2 kubitų fazės vartai (oranžiniai) ir 3 kubitų vadinamieji Tofoli loginiai vartai (mėlyni). Parodyta kvantinė grandinė pritaiko jau paruoštai trijų kubitų (\\(k_1\\), \\(k_2\\), \\(k_3\\)) būsenai \\(|\\psi\\rangle\\) santykinę fazę. Kubitai \\(a_1\\) ir \\(a_2\\) pradinėse \\(|0\\rangle\\) būsenose čia atlieka juodraščio funkciją, į kurį užrašomi tarpiniai skaičiavimo rezultatai. Nuo jų būsenų priklauso, kuriam iš skaičiuojamųjų vektorių, sudarančių \\(|\\psi\\rangle\\), bus pritaikytos fazės \\(\\theta_1\\) ir \\(\\theta_2\\). Kvantiniai loginiai vartai, veikiantys atskirus kubitus, gali būti atliekami vienu metu (paraleliai), jeigu kvantinio procesoriaus architektūra tai leidžia. Kvantinės grandinės gylis \\(d\\) (angl. circuit depth) nusako ilgiausią loginių vartų seką grandinėje nuo pradžios iki algoritmo pabaigos, kuri nebegali būti padaroma trumpesnė didesniu paralelizavimu. Parodytos grandinės gylis yra \\(d = 13\\). 1.7 Skaičiavimo procesas Apibendrinus, norint atlikti skaičiavimą kvantiniame procesoriuje reikalingi trys pagrindiniai elementai: kvantinių bitų registras. Registras – tai kubitų rinkinys, kuriame koduojama ir apdorojama informacija. Registrą galima inicializuoti į mums žinomą pradinę būseną, standartiškai \\(|0\\rangle\\) visiems kubitams; universalių kvantinių loginių vartų rinkinys. Loginiai vartai atlieka registro būsenų keitimo operacijas, leidžiančias koduoti ir apdoroti informaciją; kubitų būsenų matavimai. Norint nuskaityti registre apdorotą informaciją, kubitų būsenos turi būti išmatuojamos. Šie trys elementai yra traktuojami, kaip esantys loginiame lygmenyje. Kubitų skaičius bei skaičiavimo klaidų efektyvus nebuvimas loginiame lygmenyje nebūtinai atspindi fizinio procesoriaus kubitų skaičių bei veikimo netikslumus. Fiziniame lygmenyje skaičiavimo klaidos gali atsirasti dėl kubitų būsenų dekoherencijos, netikslių loginių vartų atlikimo bei matavimo procedūrų klaidų. Loginis lygmuo atspindi fizinio lygmens procesoriaus funkcionavimą su jau atliktais klaidų taisymo kodais (angl. error correction codes). Klaidoms atspari skaičiavimo teorija teigia, kad jeigu klaidų atsiradimo dažnis yra mažesnis nei tam tikra riba, tada įmanoma transformuoti kvantines grandines į klaidoms atsparias, kuriose klaidos efektyviai aptinkamos ir ištaisomos. Tai leistų atlikti neribotos trukmės kvantinius skaičiavimus. Kvantinių klaidų taisyme, panašiai kaip ir klasikinėje skaitmeninėje kompiuterijoje bei ryšiuose, pasitelkiama perteklinė informacija (angl. redundant information). Vietoj vieno fizinio kubito, informacija yra koduojama kelete fizinių kubitų, kurie formuoja vadinamąjį loginį kubitą (angl. logical qubit). Loginiai vartai yra pakeičiami loginių vartų seka, kurią pritaikius fiziniams kubitams efektyviai atliekama norima loginė operacija su loginiais kubitais. Esminiai skirtumai nuo klasikinių klaidų taisymo atsiranda dėl to, kad kvantinės taisyklės neleidžia kopijuoti būsenų, o tiesioginis būsenų matavimas sugriauna superpoziciją ir joje saugomą informaciją. Kvantinių klaidų aptikimas ir taisymas yra įmanomas pasitelkiant vėlgi supintąsias kvantines būsenas. Dėl tolygiai galinčių kisti būsenų kvantinis kompiuteris iš pirmo žvilgsnio atrodytų analoginis įrenginys. Analoginiai klasikiniai kompiuteriai neprigijo praktikoje, nes jų klaidas taisyti itin keblu. Tačiau kvantinėje kompiuterijoje klaidos gali būti efektyviai skaitmenizuojamos, pakanka sugebėti taisyti tik tris skirtingo tipo klaidas norint ištaisyti bendriausio tipo (tolydžiai kintančias) klaidas. Tad klaidų taisymo skaitmeninimas bei išmatuotų būsenų skaitmeninis pavidalas rodo, kad kvantinis kompiuteris yra veikiau dualus analoginis–skaitmeninis įrenginys, ir galbūt tiksliausiai – tiesiog kvantinis. 1.5 pav. Kvantinio skaičiavimo procesas Siekdami lengviau įsivaizduoti kvantinio skaičiavimo procesą, pateikiame jį visą sluoksniais (angl. full quantum stack) iliustracijoje 1.5 pav. Aukščiausiame loginiame lygmenyje kvantinio kompiuterio programavimą galima atlikti įvairiomis programavimo kalbomis, pavyzdžiui, Python, C++, ar specializuotose kvantinio programavimo aplinkose. Šiame lygmenyje yra pasitelkiami jau suformuluoti kvantiniai algoritmai ar įvairūs jų moduliai, kurie taip pat gali pasitelkti tarpinius klasikinius skaičiavimus. Programos yra toliau nukreipiamos į žemesnį kvantinių loginių grandinių lygį, kuriame algoritmai yra išreiškiami loginiais vartais. Kvantinio loginio lygmens programavimas yra nauja paradigma. Nors 10–20 kubitų dydžio procesoriui pateikiamo algoritmo loginių vartų sekas galima iš principo sudėlioti ir optimizuoti „rankomis”, tačiau to tampa nebeįmanoma padaryti procesoriui, turinčiam 1000 kubitų. Todėl neišvengiamai teks automatizuoti kvantinių grandinių kompiliavimą ir optimizavimą. Artimuoju kvantinių kompiuterių raidos laikotarpiu tai gali lemti, ar tam tikrus algoritmus apskritai įmanoma atlikti. Pavyzdžiui, Šoro algoritmą galima realizuoti renkantis panaudoti daugiau kubitų ir mažiau loginių operacijų, arba atvirkščiai. Ribotas kubitų skaičius, tarpusavio kubitų jungčių topologija, ribotas loginių vartų tikslumas bei jų atlikimo trukmė yra vieni iš pagrindinių faktorių, į kuriuos turėtų būti atsižvelgiama kvantinių grandinių kompiliavime. Kvantinis loginis lygmuo į tai neatsižvelgia ir todėl turi būti kompiliuojamas pasitelkiant kvantinių klaidų taisymo kodus. Šie kodai priklausys nuo kvantinio procesoriaus architektūros ir galbūt specifinės skaičiavimo užduoties. Loginės operacijos yra toliau išreiškiamos mašinine kalba, kuri įvardija, kokie fiziniai veiksmai (lazerių impulsai, grandinės įtampos keitimai ir t.t.) yra atliekami kontroliuoti kvantiniam procesoriui. Kvantiniame fiziniame lygmenyje yra fizinių kubitų sistema. Ji izoliuota nuo išorinių sąveikų ir veikiama tik per klasikinę–kvantinę ribą atlikti unitarinėms kvantinių būsenų transformacijoms bei matavimams. Pasitelkiama klasikinė kompiuterija atlikti kvantinio procesoriaus veikimo diagnostikai, papildomiems sistemą stabilizuojantiems ir klaidas mažinantiems protokolams. 1.8 Kvantinių kompiuterių charakteristikų palyginimas Atsižvelgdami į kuriamų kvantinių kompiuterių neidealias veikimo charakteristikas norime geriau suprasti, kaip galima įvertinti jų gebėjimą įvykdyti pateiktą algoritmą, ir tarpusavyje palyginti skirtingus įrenginius. Vienas iš pagrindinių rodiklių palyginti skirtingų superkompiuterių skaičiuojamajai galiai yra flopai (angl. floating-point operations per second, trumpinys FLOPS). Flopais matuojama skaičiuojamoji galia nusako, kiek aritmetinių operacijų skaičių per sekundę sugeba atlikti superkompiuteriai. Pagrindiniai fiziniai rodikliai, turintys įtakos flopams, yra naudojamų procesorių dažniai ir procesorių lustų skaičius. Antrasis rodiklis nusako gebėjimą paralelizuoti skaičiavimus, tai leidžia atlikti daugiau loginių operacijų per tą patį procesoriaus laiko ciklą. Dominančiam kvantiniam algoritmui atlikti egzistuoja minimalūs kubitų bei loginių vartų skaičiaus reikalavimai. Jeigu klaidos neribotų kvantinių kompiuterių veikimo, jų skaičiavimo galia taip pat galiausiai atsiremtų į loginių operacijų skaičių per laiko vienetą. Imant konkretų pavyzdį, galima įvertinti Šoro algoritmui reikalingus laiko išteklius siekiant įveikti \\(n = 1024\\) bitų RSA kriptografija užšifruotą turinį. Teoriniai skaičiavimai rodo, kad tam reikia maždaug \\(2n\\) loginių kubitų, o sudėtingumas yra nulemtas \\(O(n^3 \\log n)\\) skaičiumi Tofoli loginių vartų. Tad reikėtų maždaug 2050 kubitų ir bent maždaug \\(10^{10}\\) loginių vartų. Loginių vartų atlikimo trukmė skiriasi tarp fizinių kvantinio procesoriaus realizacijų, tačiau bendrai yra žymiai ilgesnė (veikia apytikriai MHz dažniu) nei klasikinių procesorių (veikiančių GHz dažniu). Pavyzdžiui, transmonais pagrįstuose IBM procesoriuose šios knygos rašymo metu 2 kubitų cX loginiai vartai, ribojantys bendrą loginių operacijų atlikimo trukmę, užtrunka maždaug 200 nanosekundžių. O štai jonų gardelėmis pagrįstuose procesoriuose IonQ 2 kubitų loginiai vartai atliekami žymiai lėčiau, apytikriai 200 mikrosekundžių per operaciją. Darant prielaidas, kad tiek užtrunka atlikti ir 3 kubitų Tofoli loginius vartus bei kad kvantinės grandinės gylis abiejose architektūrose yra toks pat kaip ir loginių vartų skaičius, apytikriai \\(10^{10}\\) loginių vartų užtruktų apytikriai 1 ir apytikriai \\(5\\times 10^2\\) valandų, atitinkamai. Aktreipiame dėmesį, kad čia naudojome loginių kubitų skaičių. Vienam loginiam kubitui realizuoti gali prireikti \\(10^1\\)–\\(10^6\\) fizinių kubitų, loginių vartų skaičius didės taip pat. Vis dėlto tai yra veikiau pesimistinis įvertinimas – kvantinės technologijos itin sparčiai tobulėja ir tikėtina, kad atsiras sumanesni būdai, kaip sumažinti kvantinių skaičiavimų išteklius. 1.9 Dekoherencijos trukmė ir loginių vartų tikslumas Artimuoju kvantinių kompiuterių raidos laikotarpiu yra svarbiau atsižvelgti į skaičiavimų trukmę ir tikslumą ribojančius faktorius. Elementariausi fiziniai rodikliai, nusakantys kvantinio procesoriaus gebėjimą atlikti skaičiavimus, yra kubitų dekoherencijos trukmė ir loginių vartų tikslumas. Dekoherencija yra procesas, kurio metu nekontroliuojamos kubitų sąveikos su kitomis kompiuterio vidinėmis ar išorinėmis kvantinėmis sistemomis nebeleidžia demonstruoti interferencinių savybių. Mūsų požiūriu, nežinant apie įvykusias sąveikas atrodys, kad laikui bėgant kubitų būsenos tampa atsitiktinės, praranda gebėjimą išlaikyti superpozicijas ir demonstruoti supynimą su kitais procesoriaus kubitais. Sakoma, kad kubitų būsenos sunyksta. Standartiškai yra išskiriamos dvi dekoherencijos trukmės \\(T_1\\) ir \\(T_2\\). Tikimybė, kad kubitas, paruoštas į būseną \\(|1\\rangle\\) atskaitos laike \\(t = 0\\), joje išliks praėjus laiko intervalui \\(t\\), paprastai seka eksponentinę gesimo funkciją \\(\\mathrm{e}^{-\\frac{t}{T_1}}\\). Dekoherencijos laiko konstanta \\(T_1\\) nusako vadinamąjį amplitudės slopinimo (angl. amplitude-damping), arba energijos relaksacijos (angl. energy relaxation) laiką. Istoriškai kubitų sistemose, pagrįstose superlaidžiomis grandinėmis ir jonų gaudyklėmis, kubitų būsenos \\(|0\\rangle\\) ir \\(|1\\rangle\\) nusakomos žemiausio ir gretimo aukštesnio energijos lygmens kvantinės sistemos būsenomis. Energijos relaksacija šiame kontekste, \\(|1\\rangle \\rightarrow |0\\rangle\\), yra procesas, kuriame aukštesnio energijos lygmens būsena savaime ar stimuliuojama iš išorės sugrįžta į žemesnį lygį. Pavyzdžiui, praėjus laikui \\(t = T_1\\) tikimybė pamatavus kubitą vis dar jį rasti \\(|1\\rangle\\) būsenoje yra \\(p = 0.37\\). Dekoherencijos trukmės konstanta \\(T_2\\) nusako fazės slopinimo (angl. phase-damping) trukmę, dar vadinamą depoliarizacijos trukme (angl. depolarization). Šis rodiklis įvardija kubitų, esančių būsenų superpozicijoje, gebėjimą išlaikyti santykinę fazę. Kaip ir laiko konstantą \\(T_1\\), \\(T_2\\) galima nustatyti atlikus seriją matavimų naudojant skirtingus laiko intervalus, po kurių išmatuojamos būsenos. Fazės slopinimo konstantai rasti kubitas yra paruošiamas į superpozicijos būseną \\(|0_x \\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\) atskaitos laike \\(t = 0\\). Praėjus laiko intervalui \\(t\\) yra pritaikoma Hadamardo transformacija ir išmatuojama būsena. Jeigu įvyko fazės klaida, kubito būsena pasikeičia taip: \\(|0_x \\rangle \\rightarrow |1_x\\rangle\\), tad atlikus \\(H\\) vartus bus rasta būsena \\(|1\\rangle\\), o ne \\(|0\\rangle\\). Tikimybė rasti \\(|0\\rangle\\) būseną seka eksponentinę gesimo funkciją \\(\\frac{\\mathrm{e}^{-\\frac{t}{T_2}} + 1}{2}\\). Po pakankamai ilgo laiko \\(t \\gg T_2\\) tikimybės rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\) būseną susivienodina. Abiejų minėtų procesų gesimo funkcijos yra parodytos 1.6 pav. 1.6 pav. Fazės ir amplitudės slopinimas. Parodytos kreivės nusako, kokia tikimybė rasti kubitą pradinėje nurodytoje būsenoje bėgant laikui. Iliustracijai panaudota \\(T_1 = T_2 = 300\\) mikrosekundžių dekoherencijos trukmė Individualių kvantinių loginių vartų tikslumą (angl. gate fidelity) galima įvertinti palyginus, kiek būsenos, kurioms buvo atliekami šie loginiai vartai, yra artimos būsenoms, kurioms buvo atlikti idealiai veikiantys loginiai vartai. Idealiai veikiančių loginių vartų efektas kvantinei būsenai gali būti apskaičiuotas popieriaus lape arba klasikiniu kompiuteriniu modeliavimu. Gerai funkcionuojančių vartų tikslumas neturėtų priklausyti nuo pateiktos kvantinės būsenos, tad dažnai atliekant šį testą yra suvidurkinamas loginių vartų efektas daugeliui skirtingų pradinių būsenų. Loginių vartų netikslumų įvedamos klaidos sumuojasi su atliekamų vartų skaičiumi, tad kuo ilgesnis algoritmas, tuo tikslesni turėtų būti loginiai vartai. Norint sėkmingai vykdyti klaidų taisymo algoritmus ir pasiekti klaidoms atsparią skaičiavimų ribą, reikalingas tam tikras minimalus loginių vartų tikslumas. Įprastai kvantiniame procesoriuje tikslumą riboja 2 kubitų loginiai vartai, kuriuos yra fiziškai sudėtingiau realizuoti negu 1 kubito loginius vartus. "],["matematikos-skyrius.html", "2 skyrius. Matematinių įrankių rinkinys 2.1 Tiesinė algebra 2.2 Kompleksiniai skaičiai 2.3 Vidinė vektorių sandauga 2.4 Kubito reprezentacija Blocho sferoje 2.5 Tiesiniai operatoriai ir matricos 2.6 Unitariniai ir ermitiniai operatoriai 2.7 Diadinė operatorių dekompozicija 2.8 Matricos pėdsakas 2.9 Tenzorinė vektorių sandauga 2.10 Tenzorinė operatorių sandauga 2.11 Operatorių funkcijos", " 2 skyrius. Matematinių įrankių rinkinys 2.1 Tiesinė algebra Tiesinė algebra yra kvantinės kompiuterijos matematinė kalba. Šiame skyriuje pateikiame jos pagrindinius konceptus bei kitus matematinius įrankius, kurių naudojimą bus galima aptikti įvairiose knygos vietose. Tai jokiu būdu nėra pilnutinis tiesinės algebros išdėstymas – išsamesnį pristatymą, esant poreikiui, galima rasti matematikos ir fizikos sričių literatūros šaltiniuose, kurių dalis yra pateikta knygos pabaigoje. Pagrindiniai objektai tiesinėje algebroje yra vektorių erdvės, kurių elementai – vektoriai. Kvantinėje kompiuterijoje aptinkamos vien baigtinio dimensijų skaičiaus vektorių erdvės. Taip yra todėl, kad naudojamas baigtinis \\(n\\) skaičius kubitų, pavienių kubitų būsena yra nusakoma vektoriumi 2 dimensijų vektorių erdvėje, o jų bendra būsena \\(2^n\\) dimensijose. Baigtinio dimensijų skaičiaus sistemas yra lengviau analizuoti – išvengiama matematinių komplikacijų, dažnai sutinkamų kitose kvantinėse sistemose su begaliniu dimensijų skaičiumi ir reikalaujančių papildomo žinių bagažo. Tad, šiuo požiūriu, koncentruojantis vien į baigtinio dimensijų skaičiaus sistemas galima žymiai greičiau įsisavinti esminius konceptus. Vektoriai yra aptinkami įvairiausiose srityse ir dažnai apibūdinami kaip rodyklytės erdvėje, turinčios tam tikrą ilgį bei orientaciją. Kvantinėje kompiuterijoje tik specifinėse situacijose tokia vektorių vaizdinė reprezentacija yra įmanoma, pavyzdžiui, perteikiant vieno kubito būseną vektoriumi Blocho sferoje. Panašios vizualizacijos, be abejo, yra naudingos įgauti pradinę intuiciją apie vektorius ir jų transformacijas. Vis dėlto yra tikslingiau galvoti apie vektorius tiesiog kaip apie abstrakčius objektus, turinčius nurodytas savybes. Jos nusako, kaip galima sudėti vektorius ir sudauginti juos su skaičiais. Vektorių vizualizacijos keblumas kvantinėje kompiuterijoje atsiranda dėl to, kad šie vektoriai yra apibrėžti kompleksinėje vektorių erdvėje (angl. complex vector space), o ne įprastinėje realiųjų skaičių Euklido erdvėje (angl. Euclidean vector space). Be to, kvantinės būsenos yra formaliai nusakomos spinduliais (angl. rays), nors ir įprasta sakyti, kad vektoriais. Spindulys yra grupė vektorių, kurie skiriasi tarp savęs tik globalia faze (čia reikia atskirti nuo santykinės fazės). Pavyzdžiui, kvantinė būsena, nusakyta \\(|v\\rangle\\) arba \\(- |v\\rangle\\) vektoriais, yra fiziškai identiška, nors tai ir reikštų skirtingus euklidinius vektorius, orientuotus antiparaleliai. Kvantinėje kompiuterijoje kompleksinių vektorių baigtinio dydžio \\(d\\) dimensijų erdvę žymėsime simboliu \\(V^d\\). Viršuje užrašome erdvės dimensiją \\(d\\) (natūralusis teigiamasis skaičius), jeigu yra poreikis specifinėje situacijoje ją įvardyti. Vektorių erdvės elementai yra vektoriai, kuriuos visada galime išreikšti sugrupuotų kompleksinių skaičių stulpeliu: \\[\\begin{equation} |v\\rangle = \\begin{bmatrix} z_1 \\\\ z_2 \\\\ \\vdots \\\\ z_n \\\\ \\end{bmatrix}\\,. \\tag{2.1} \\end{equation}\\] Skliausteliai, turintys formą \\(|\\ldots \\rangle\\) yra naudojami įvardyti kad šis objektas yra vektorius stulpelis. Skaičius žymime indeksuotomis mažosiomis raidėmis \\(z_i\\). Norint glaustai parodyti, kad vektorius \\(|v\\rangle\\) priklauso tam tikrai vektorių erdvei \\(V\\), rašome \\(|v\\rangle \\in V\\). Simbolis \\(\\in\\) nusako, kad kairėje esantis objektas yra vienas iš dešinėje esančio objekto elementų. Elementų \\(z_i\\) skaičius vektoriuje nusako vektorių erdvės dimensijų skaičių. Vektorius galima sudėti tik tuo atveju, jeigu jie priklauso tai pačiai vektorių erdvei. Apsistojant ties viena reprezentatyvia vektorių erdve \\(V\\), joje yra apibrėžtos vektorių sudėties operacijos, tenkinančios šias savybes: \\[\\begin{align} |v_1 \\rangle + |v_2 \\rangle = &amp; |v_2 \\rangle + |v_1 \\rangle\\,; \\tag{2.2} \\\\ |v_1 \\rangle + \\big( |v_2\\rangle + |v_3 \\rangle \\big) = &amp; \\big( |v_1 \\rangle + |v_2 \\rangle \\big) + |v_3\\rangle\\,. \\tag{2.3} \\end{align}\\] Tai bendrai parodo, kad eiliškumas vektorių sudėčiai nėra svarbus. Vektorių erdvėje taip pat egzistuoja nulinis vektorius, analogiškas nuliniam skaičiui. Kvantinėje kompiuterijoje \\(|0 \\rangle\\) yra jau paskirtas kitkam, tad nusakyti nuliniam vektoriui vartojamas simbolis 0. Nulinio vektoriaus efektas apibūdinamas \\(|v\\rangle + 0 = |v \\rangle\\), iš to gauname \\(|v\\rangle - |v\\rangle = 0\\). Kompleksinio skaičiaus \\(z_i\\) daugyba su vektoriais tenkina šias savybes: \\[\\begin{align} z\\big( |v_1 \\rangle + |v_2 \\rangle \\big) = &amp; z |v_1\\rangle + z |v_2\\rangle\\,; \\tag{2.4} \\\\ ( z_1 + z_2 ) |v \\rangle = &amp; z_1 |v \\rangle + z_2 |v \\rangle\\,; \\tag{2.5} \\\\ ( z_1 z_2 ) |v \\rangle = &amp; z_1 \\big(z_2 |v \\rangle\\big)\\,. \\tag{2.6} \\end{align}\\] Atkreipiame dėmesį, kad sandaugose praleidžiame daugybos simbolį, tad du vienas šalia kito raidėmis nusakyti skaičiai (ar skaičius su vektoriumi) reiškia, kad jie yra sudauginami. Skaičių daugybai nesvarbu eiliškumas \\(z_1 z_2 = z_2 z_1\\). Taip pat galima daugyba su nuliniu skaičiumi, deja, taip pat žymimu \\(0\\), \\(0 |v \\rangle = 0\\). Tai yra visos elementariosios ir itin intuityvios aritmetinės operacijos. Šių aritmetinių operacijų metu gautas vektorius vėlgi priklauso tai pačiai vektorių erdvei. Kvantinėse sistemose yra apibrėžta vadinamoji dviejų vektorių vidinė sandauga, žymima \\(\\langle v |u \\rangle\\), kurios rezultatas yra skaičius. Prie vidinės sandaugos šiame skyriuje dar sugrįšime. Toliau primename vektorių, išreikštų sugrupuotų skaičių stulpeliais, aritmetiką. Imant kaip pavyzdį trijų elementų vektorius, sudėtis nusakoma: \\[\\begin{equation} \\begin{bmatrix} z_1 \\\\ z_2 \\\\ z_3 \\\\ \\end{bmatrix} + \\begin{bmatrix} z_4 \\\\ z_5 \\\\ z_6 \\\\ \\end{bmatrix} = \\begin{bmatrix} z_1 + z_4 \\\\ z_2 + z_5 \\\\ z_3 + z_6 \\\\ \\end{bmatrix}\\,. \\tag{2.7} \\end{equation}\\] Čia kiekvienas elementas \\(z_i\\) yra kompleksinis skaičius. Vektoriaus ir skaičiaus \\(g\\) sandauga: \\[\\begin{equation} g\\begin{bmatrix} z_1 \\\\ z_2 \\\\ z_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} g z_1 \\\\ g z_2 \\\\ g z_3 \\\\ \\end{bmatrix}\\,. \\tag{2.8} \\end{equation}\\] Kiti du svarbūs konceptai yra vektorių erdvę dengiantis vektorių rinkinys (angl. spanning set) ir vektorių tiesinė nepriklausomybė (angl. linear independence). Vektorių erdvę \\(V\\) dengiantis rinkinys \\(\\big\\{ |v_1\\rangle , |v_2\\rangle , |v_3 \\rangle\\ldots \\big\\}\\) yra toks vektorių rinkinys, kurių tiesinėmis kombinacijomis galima išreikšti bet kokį vektorių \\(|v\\rangle\\), esantį \\(V\\). Tai yra: \\[\\begin{equation} |v \\rangle = \\sum_i z_i |v_i\\rangle\\,. \\tag{2.9} \\end{equation}\\] Tiesinė vektorių nepriklausomybė leidžia formaliai nusakyti vektorių erdvės dimensiją ir tuo pačiu rasti mažiausią skaičių vektorių, dengiančių vektorių erdvę \\(V\\). Vektoriai \\(\\big\\{|v_1 \\rangle , |v_2 \\rangle ,\\ldots , |v_n \\rangle\\big\\}\\) yra tiesiškai priklausomi, jeigu bent vienas vektorius šiame rinkinyje, sakysime \\(|v_2 \\rangle\\), gali būti išreikštas likusių \\(n-1\\) vektorių tiesinėmis kombinacijomis: \\[\\begin{equation} z_1 |v_1\\rangle + z_3 |v_2 \\rangle + \\cdots + z_n |v_n \\rangle = |v_2\\rangle\\,. \\tag{2.10} \\end{equation}\\] Tiesiškai nepriklausomų vektorių rinkinyje nė vieno iš jų neįmanoma išreikšti kitų likusiųjų suma. Formaliai, tiesiškai priklausomas vektorių rinkinys tenkina šią lygybę: \\[\\begin{equation} z_1 |v_1 \\rangle + z_2 |v_2\\rangle + \\cdots + z_n |v_n \\rangle = 0\\,. \\tag{2.11} \\end{equation}\\] Čia suma lygi nuliniam vektoriui ir joje egzistuoja skaičiai \\(z_i\\), kurie ne visi lygūs nuliui \\(z_i \\neq 0\\). O štai tiesiškai nepriklausomame vektorių rinkinyje ši lygybė gali būti tenkinama tik tuo atveju, jeigu visi skaičiai \\(z_i = 0\\). Galima parodyti, kad bet kurie du skirtingi tiesiškai nepriklausomi vektorių rinkiniai, dengiantys tą pačią vektorių erdvę \\(V\\), turi vienodą skaičių vektorių. Vektoriai, priklausantys tokiam rinkiniui, yra vadinami baziniais vektoriais (angl. basis vectors), o jų skaičius rinkinyje formaliai nusako vektorių erdvės V dimensiją. Pavyzdžiui, imkime 3 dimensijų erdvės bazinių vektorių rinkinį: \\[\\begin{equation} |v_1 \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix},\\quad |v_2\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix},\\quad |v_3 \\rangle = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\tag{2.12} \\end{equation}\\] Matome, kad bet kokį vektorių \\(|v\\rangle\\) šioje erdvėje galime išreikšti jų suma: \\[\\begin{equation} |v\\rangle = \\begin{bmatrix} a \\\\ b \\\\ c \\\\ \\end{bmatrix} = a\\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} + b\\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix} + c\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\tag{2.13} \\end{equation}\\] Taip pat akivaizdu, kad dviejų bazinių vektorių, pavyzdžiui \\(|v_1 \\rangle\\) ir \\(|v_3 \\rangle\\), nepakaktų išreikšti visus įmanomus vektorius šioje erdvėje. Keturi baziniai vektoriai 3 dimensijose būtų perteklius, kadangi vieną iš jų visada galime išreikšti kitų suma. Egzistuoja begalė skirtingų bazinių vektorių rinkinių. Pavyzdžiui, kitas rinkinys: \\[\\begin{equation} |v_1 \\rangle = \\begin{bmatrix} 2 \\\\ - 1 \\\\ 0 \\\\ \\end{bmatrix},\\quad |v_2 \\rangle = \\begin{bmatrix} 2 \\\\ 5 \\\\ 3 \\\\ \\end{bmatrix},\\quad |v_3 \\rangle = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\tag{2.14} \\end{equation}\\] Siekdami patikrinti šių vektorių tiesinę nepriklausomybę išspręstume trijų lygčių sistemą: \\[\\begin{equation} \\begin{aligned} 2a + 2b + c =&amp; 0\\,, \\\\ -a + 5b + c =&amp; 0\\,,\\\\ 3b + c =&amp; 0\\,. \\\\ \\end{aligned} \\tag{2.15} \\end{equation}\\] Sistemą išsprendę rastume, kad vieninteliai skaičiai, tenkinantys lygybę, yra \\(a = b = c = 0\\). Vienas svarbus skirtumas tarp šio bazinio vektorių rinkinio ir parodyto anksčiau yra tai, kad ankstesniame rinkinyje visi vektoriai tarpusavyje sudaro stačiuosius kampus. Kompleksinėje vektorių erdvėje statmenumo konceptas yra vadinamas ortogonalumu (angl. orthogonality). Dviejų vektorių ortogonalumą, kaip matysime vėliau, galima nustatyti atlikus jų vidinę sandaugą, \\(\\langle v_m |v_n \\rangle\\). Jeigu du (nenuliniai) vektoriai yra ortogonalieji, jų vidinė sandauga visada bus skaičius, lygus nuliui. Kvantinėje kompiuterijoje 2 dimensijų kompleksinių vektorių erdvės \\(V^2\\) nusako individualių kubitų būsenų erdvę. Bendra vieno kubito būsena yra vektorius: \\[\\begin{equation} |\\psi\\rangle = a|0\\rangle + b|1\\rangle\\,. \\tag{2.16} \\end{equation}\\] Čia \\(|0\\rangle\\) ir \\(|1\\rangle\\) yra standartiškai naudojami baziniai vektoriai, dar vadinami skaičiuojamaisiais baziniais vektoriais. Išreiškus juos stulpeliniu vektoriumi: \\[\\begin{equation} |0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix},\\quad |1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\tag{2.17} \\end{equation}\\] Galima lengvai patikrinti, kad šis dviejų vektorių rinkinys \\(\\big\\{|0\\rangle , |1\\rangle\\big\\}\\) yra tiesiškai nepriklausomas ir todėl jų kombinacijomis galima išreikšti bet kokį kitą vektorių \\(|v\\rangle\\) šioje 2 dimensijų erdvėje keičiant koeficientus \\(a\\) ir \\(b\\): \\[\\begin{equation} |v\\rangle = a\\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix} + b\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}\\,. \\tag{2.18} \\end{equation}\\] Kvantinėje mechanikoje koeficientai turi tenkinti lygybę \\(|a|^2 + |b|^2 = 1\\). Nors šis bazinių vektorių rinkinys kvantinėje kompiuterijoje naudojamas standartiškai, tačiau skirtingų bazinių rinkinių yra begalė. Kitas dažnai aptinkamas ortogonalus 1 kubito būsenas nusakantis rinkinys yra šis: \\[\\begin{equation} |0_x \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\\\ \\end{bmatrix},\\quad |1_x \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -1 \\\\ \\end{bmatrix}\\,. \\tag{2.19} \\end{equation}\\] Palyginę su \\(\\big\\{|0\\rangle, |1\\rangle\\big\\}\\) matome, kad \\(\\big\\{|0_x \\rangle, |1_x \\rangle\\big\\}\\) rinkinyje bazinius vektorius galime išreikšti sudėję bei atėmę pirmųjų elementus, atitinkamai, naudojant koeficientus \\(a = b = 1/\\sqrt{2}\\): \\[\\begin{equation} |0_x \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\,,\\quad |1_x \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle - |1\\rangle\\big)\\,. \\tag{2.20} \\end{equation}\\] Dviejų bazinių vektorių suma kvantinėje kompiuterijoje yra vadinama būsenų superpozicija. Tiesinės algebros požiūriu, tai tiesiog atspindi vieną galimą būdą išreikšti vektorių sąlygiškai su kitais dviem. Užbaigdami šią dalį atitrūksime nuo kompleksinių skaičių ir kvantinių sistemų. Kompleksinių skaičių vartojimas komplikuoja vektorių, kaip matematinių objektų, iliustravimą. Siekiant susidaryti intuiciją yra palankiau sugrįžti prie realiosios Euklido vektorių erdvės, kurioje galima vektorius pavaizduoti rodyklyte. Euklido erdvėje vektorių daugyba yra galima tik su realiaisiais skaičiais. Realieji skaičiai yra vartojami nusakant kasdienius dydžius, tokius kaip atstumas, aukštis, valiutos kiekis sąskaitoje ir panašiai. Vektorius nusako dydį, bet dar pateikia ir informaciją apie kryptį. Paprastas pavyzdys būtų greičio vektorius, suteikiantis informaciją apie greitį bei judėjimo kryptį. Imkime kaip pavyzdį greitumo vektorių \\(|g\\rangle\\), nusakantį greitį 2 dimensijose (plokštumoje): \\[\\begin{equation} |g \\rangle = \\begin{bmatrix} 2 \\\\ 3 \\\\ \\end{bmatrix}\\,. \\tag{2.21} \\end{equation}\\] Galime žvelgti į šiuos du skaičius stulpelyje, kaip suteikiančius koordinates \\((x, y)\\). Naudojant statmeną \\(x\\)–\\(y\\) koordinačių sistemą, šis vektorius pavaizduotas 2.1 pav. 2.1 pav. Vektoriaus pavyzdys plokštumoje. Joje priskirta stačiakampė \\(x\\)–\\(y\\) kordinačių sistema; vienetiniai vektoriai pažymėti žalia spalva Norėdami nubrėžti \\(|g\\rangle\\) vektorių, einame 2 žingsnius \\(x\\) ašimi į dešinę ir 3 \\(y\\) ašimi į viršų. Šiuo atveju nėra svarbu, ar vektorius prasideda nuo 0, ar kitur, svarbu vektoriaus orientacija ir ilgis. Vektoriaus ilgis \\(|g\\rangle\\) nusakys šiame pavyzdyje greitį, kurį rodytų spidometras. Taikydami Pitagoro teoremą randame \\(|g\\rangle\\) ilgį \\(\\sqrt{2^2 + 3^2} = \\sqrt{13}\\). Vektoriaus iliustracijoje matome \\(|0\\rangle\\) ir \\(|1\\rangle,\\) pažymėtus rodyklytėmis, kurie atlieka, analogiškai su kubitais, bazinių vektorių vaidmenį. Jie yra statmeni (ortogonalieji) vienas kito atžvilgiu ir vienetinio ilgio. Vektorių \\(|g\\rangle\\) išreiškiame jais taip: \\[\\begin{equation} |g\\rangle = 2|0\\rangle + 3|1\\rangle = 2\\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix} + 3\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\tag{2.22} \\end{equation}\\] Visi įmanomi vektoriai šioje plokštumoje gali būti sukonstruoti naudojant šiuos bazinius vektorius bei keičiant koeficientus \\(a\\) ir \\(b\\). Bazinių vektorių rinkinys, analogiškas minėtam kubitų rinkiniui \\(\\big\\{ |0_x \\rangle, |1_x \\rangle\\big\\}\\), šioje plokštumoje būtų gautas pasukus \\(|0\\rangle\\) ir \\(|1\\rangle\\) kartu pagal laikrodžio rodyklę \\(45^{\\circ}\\) laipsnių kampu išlaikant tarp jų statųjį kampą. 2.2 Kompleksiniai skaičiai Šie skaičiai turi realiąją ir menamąją dalis ir yra bendrai išreiškiami \\(z = a + b\\mathrm{i}\\). Čia \\(a\\) ir \\(b\\) yra realieji skaičiai, kompleksinio skaičiaus realioji (Re) ir menamoji (Im) dalys yra atitinkamai \\(a\\) ir \\(b\\). Tai dar gali būti rašoma \\(\\mathrm{Re}(z) = a\\), \\(\\mathrm{Im}(z) = b\\). Skaičių \\(b\\) dauginantis raide \\(\\mathrm{i}\\) žymimas narys yra menamasis vienetas, turintis savybę: \\[\\begin{equation} \\mathrm{i}^2 = -1\\,. \\tag{2.23} \\end{equation}\\] Tad į realųjį skaičių galime žiūrėti kaip į kompleksinį skaičių, kuriame menamoji dalis \\(b = 0\\). Atliekant dviejų kompleksinių skaičių arba kompleksinio ir realiojo skaičiaus sudėtis, realiosios ir menamosios dalys yra sudedamos tarpusavyje atskirai: \\[\\begin{equation} (a + b\\mathrm{i}) + (c + d\\mathrm{i}) = (a + c) + (b + d)\\mathrm{i}\\,. \\tag{2.24} \\end{equation}\\] Taikydami menamojo vieneto savybę bei kompleksinių skaičių sudėtį, dviejų kompleksinių skaičių sandaugą randame: \\[\\begin{equation} (a + b\\mathrm{i}) (c + d\\mathrm{i}) = (ac - bd) + (ad + bc)\\mathrm{i}\\,. \\tag{2.25} \\end{equation}\\] Atliekant skaičiavimus kvantinėje kompiuterijoje dažnai naudojamas vadinamasis kompleksinis skaičiaus jungimas, dar įvardijamas kaip konjugacija (angl. complex conjugation). Apačioje parodytas ryšys tarp kompleksinio skaičiaus \\(z\\) ir jo kompleksinės jungties, kuri yra žymima su žvaigždute \\(z^{*}\\): \\[\\begin{equation} z = a + b\\mathrm{i} \\rightarrow z^{*} = a - b\\mathrm{i}\\,. \\tag{2.26} \\end{equation}\\] Kompleksinis jungimas apverčia menamosios dalies ženklą. Pavyzdžiui, kvantinės būsenos kompleksinės amplitudės \\(z\\) kvadratas yra apskaičiuojamas naudojant kompleksinę jungtį: \\[\\begin{equation} |z|^2 = z z^{*} = (a + b\\mathrm{i}) (a - b\\mathrm{i}) = a^2 + b^2\\,. \\tag{2.27} \\end{equation}\\] Čia \\(|z|\\) reiškia šio skaičiaus modulį ir matome, kad \\(z z^{*}\\) visada yra realusis skaičius. Kompleksinius skaičius galime išreikšti grafiškai plokštumoje, kurioje horizontalioji ir vertikalioji ašys nusako realiąją (Re) ir menamąją (Im) dalis, atitinkamai. 2.2 pav. Kompleksinio skaičiaus pavaizdavimas stačiakampėje Re–Im koordinačių sistemoje pateikiant koordinates \\((a, b)\\). Naudojant polines koordinates, pateikiamas spindulio ilgis ir kampas (\\(|z|\\), \\(\\theta\\)) Viršuje parodyti du būdai išreikšti kompleksiniam skaičiui. Galime nusakyti kompleksinį skaičių \\((a, b)\\) koordinatėmis Re–Im koordinačių sistemoje arba išreikšti \\(z\\) polinėje koordinačių sistemoje. Nubrėžę spindulį nuo koordinačių centro iki \\((a, b)\\) taško, spindulys sudaro \\(\\theta\\) kampą su Re ašimi. Kadangi spindulio ilgis yra \\(|z| = \\sqrt{a^2 + b^2}\\), koordinates \\((a, b)\\) galime išreikšti \\(\\big(a = |z|\\cos(\\theta), b = |z|\\sin(\\theta)\\big)\\). Tad polinėje koordinačių sistemoje nusakomi du parametrai, spindulio ilgis ir kampas (\\(|z|\\), \\(\\theta\\)). Jeigu imsime kompleksinį skaičių, kurio spindulio ilgis \\(|z| = 1\\), Oilerio formulė (angl. Euler formula) mums rodo: \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\theta} = \\cos(\\theta) + \\mathrm{i}\\sin(\\theta)\\,. \\tag{2.28} \\end{equation}\\] Oilerio formulėje \\(\\mathrm{e}\\) yra natūraliojo logaritmo pagrindas, kurio reikšmė \\(\\mathrm{e}\\sim 2.718\\ldots\\) . Akivaizdu, kad Oilerio funkcijos modulis \\(\\big|\\mathrm{e}^{\\mathrm{i}\\theta}\\big| = 1\\). Bet kokį kompleksinį skaičių \\(z\\) galime išreikšti taip: \\[\\begin{equation} z = |z|\\mathrm{e}^{\\mathrm{i}\\theta}\\,. \\tag{2.29} \\end{equation}\\] Taip išreikšto skaičiaus \\(z\\) kompleksinė jungtis bei jo modulio kvadratas, minėti viršuje, gaunami atliekant konjugaciją eksponentėje: \\[\\begin{align} z^{*} = &amp; |z|\\mathrm{e}^{-\\mathrm{i}\\theta}\\,;\\tag{2.30}\\\\ |z|^2 = &amp; |z| |z|\\mathrm{e}^{-\\mathrm{i}\\theta}\\mathrm{e}^{\\mathrm{i}\\theta}= |z|^2\\,. \\tag{2.31} \\end{align}\\] Viršuje pritaikėme eksponenčių daugybos formulę, \\(\\mathrm{e}^{\\mathrm{i}a}\\mathrm{e}^{\\mathrm{i}b} = \\mathrm{e}^{\\mathrm{i}(a + b)}\\) bei \\(\\mathrm{e}^0 = 1\\). 2.3 Vidinė vektorių sandauga Šioje dalyje apibūdiname kvantinėje kompiuterijoje dažnai aptinkamą vidinę dviejų vektorių sandaugą (angl. inner product), dar vadinama skaliarine sandauga (angl. scalar product). Vektorius \\(|\\psi\\rangle\\) su tokio tipo skliausteliais yra vadinamas ket ir yra asocijuojamas su stulpeliniu vektoriumi. Vektorius eilutė yra žymimas apsuktais skliausteliais, \\(\\langle\\psi|\\) ir vadinamas bra. Iš bet kokio ket vektoriaus galime padaryti bra vektorių dviem žingsniais. Pavyzdžiui, turime ket su keturiais elementais: \\[\\begin{equation} |\\psi\\rangle = \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\\\ \\end{bmatrix}\\,. \\tag{2.32} \\end{equation}\\] Visi \\(|\\psi\\rangle\\) vektoriaus elementai yra bendrai kompleksiniai skaičiai. Pirmame žingsnyje vektorius eilutė yra gaunamas atlikus vadinamąją transpoziciją (angl. transposition), žymimą T raide virš vektoriaus \\(|\\psi\\rangle^T\\). Elementai stulpelyje iš viršaus į apačią yra pergrupuojami eilutėje iš kairės į dešinę: \\[\\begin{equation} |\\psi\\rangle^T = \\lbrack a_1\\: a_2\\: a_3\\: a_4\\rbrack\\,. \\tag{2.33} \\end{equation}\\] Galiausiai, bra vektorius yra gaunamas atlikus transponuotajam vektoriui kiekvieno jo elemento kompleksinę jungtį \\(\\big(|\\psi\\rangle^T\\big)^{*}= |\\psi\\rangle^{\\dagger} = \\langle\\psi|\\). Ši dviguba operacija yra vadinama ermitine jungtimi, kuriai nurodyti vartojamas durklo formos ženklas \\(\\dagger\\). Tad galiausiai randame: \\[\\begin{equation} |\\psi\\rangle^{\\dagger} = \\langle\\psi| = \\lbrack a_1^{*}\\: a_2^{*}\\: a_3^{*}\\: a_4^{*}\\rbrack\\,. \\tag{2.34} \\end{equation}\\] Bra vektoriai yra dualūs ket vektoriams (angl. dual vector) – kiekvienas bra turi vieną sau atitinkantį ket. Formaliai, jeigu \\(|\\psi\\rangle\\) yra \\(V\\) vektorių erdvės elementas, tai jam dualus \\(\\langle\\psi|\\) vektorius yra dualios \\(\\overline{V}\\) vektorių erdvės elementas. Kadangi ket ir bra yra skirtingų erdvių elementai, jų tarpusavyje sudėti negalima, tai yra neapibrėžta operacija. Tačiau visos minėtos operacijos bra vektorių erdvėje \\(\\overline{V}\\) yra identiškos ket \\(V\\) erdvei. Vidinė dviejų vektorių sandauga yra atliekama tarp bra ir ket vektorių, tiesinėje algebroje – tarp vektoriaus eilutės ir stulpelio. Imkime kaip pirmą pavyzdį vidinę \\(|\\psi\\rangle\\) vektoriaus sandaugą su sau dualiu vektoriumi, \\(\\langle\\psi|\\psi\\rangle\\). Rašant vektoriaus elementais, vidinė sandauga formaliai išreiškiama: \\[\\begin{equation} \\begin{aligned} \\langle\\psi|\\psi\\rangle = &amp; \\lbrack a_1^{*}\\: a_2^{*}\\: a_3^{*}\\: a_4^{*} \\rbrack \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\\\ \\end{bmatrix} \\\\ = &amp; a_1^{*} a_1 + a_2^{*} a_{2} + a_3^{*} a_{3} + a_4^{*} a_{4} \\\\ = &amp; |a_1|^2 + |a_2|^2 + |a_3|^2 + |a_4|^2\\,. \\end{aligned} \\tag{2.35} \\end{equation}\\] Matome, kad atlikus vidinę vektoriaus sandaugą su sau dualiu vektoriumi rezultatas visada bus realusis neneigiamasis skaičius, \\(\\langle \\psi|\\psi\\rangle \\geq 0\\). Šis skaičius nusako kompleksinių kvadratų sumą, kurią dar galime identifikuoti kaip \\(|\\psi\\rangle\\) vektoriaus ilgio kvadratą. Kvantinės būsenos yra nusakomos normuotaisiais vektoriais, tai yra, turinčiais vienetinį vektoriaus ilgį. Tad normuotojo vektoriaus vidinė sandauga su savo dualiuoju vektoriumi visada lygi vienetui, \\(\\langle\\psi |\\psi\\rangle = 1\\). Galime bet kurį vektorių padaryti normuotuoju, jeigu jis toks nėra, padalindami jį iš skaičiaus, nusakančio vektoriaus ilgį \\(\\sqrt{\\langle\\psi |\\psi\\rangle}\\): \\[\\begin{equation} |\\hat{\\psi}\\rangle = |\\psi\\rangle/\\sqrt{\\langle\\psi |\\psi\\rangle}\\,. \\tag{2.36} \\end{equation}\\] Dviejų skirtingų tos pačios vektorių erdvės vektorių \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\) vidinė sandauga \\(\\langle\\psi|\\phi\\rangle\\) yra: \\[\\begin{equation} \\langle\\psi |\\phi\\rangle = \\lbrack a_1^{*}\\: a_2^{*}\\: a_3^{*}\\: a_4^{*}\\rbrack\\ \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\\\ b_4 \\\\ \\end{bmatrix} = a_1^{*} b_1 +a_2^{*} b_2 + a_3^{*} b_3 + a_4^{*} b_{4}\\,. \\tag{2.37} \\end{equation}\\] Dviejų vektorių, turinčių \\(n\\) elementų, vidinė sandauga \\(\\langle\\psi |\\phi\\rangle\\) yra glaustai užrašoma: \\[\\begin{equation} \\langle\\psi|\\phi\\rangle = \\sum_{i = 1}^{n} a_i^{*} b_i\\,. \\tag{2.38} \\end{equation}\\] Ket ir bra eiliškumas (kuris vektorius rašomas kairėje ir kuris – dešinėje) vidinėje sandaugoje gali būti svarbus, nes sudauginus skirtingus vektorius gaunamas skaičius yra bendrai kompleksinis. Skirtumas tarp jų eiliškumo slypi gauto skaičiaus kompleksiniame jungime. Šį principą galima išreikšti taip: \\[\\begin{equation} \\langle\\psi|\\phi\\rangle = \\big(\\langle\\phi|\\psi\\rangle\\big)^{*}\\,. \\tag{2.39} \\end{equation}\\] Skaičius vidinėje sandaugoje galime visada iškelti už jos: \\[\\begin{equation} \\langle\\psi|\\big(z_1|\\phi_1 \\rangle + z_2|\\phi_2\\rangle\\big) = z_1\\langle\\psi|\\phi_1\\rangle + z_2\\langle\\psi |\\phi_2 \\rangle\\,. \\tag{2.40} \\end{equation}\\] Vidinės sandaugos modulio kvadratas, \\(\\big|\\langle\\psi|\\phi\\rangle\\big|^2\\), dar vadinamas kompleksiniu kvadratu, naudojant vektorių simboliką yra: \\[\\begin{equation} \\big|\\langle\\psi|\\phi\\rangle\\big|^2 = \\langle\\psi |\\phi\\rangle\\langle\\psi |\\phi\\rangle^{*} = \\langle\\psi |\\phi\\rangle\\langle\\phi |\\psi\\rangle = \\langle\\phi |\\psi\\rangle\\langle\\psi |\\phi\\rangle = \\big|\\langle\\phi |\\psi\\rangle\\big|^2\\,. \\tag{2.41} \\end{equation}\\] Viršuje matome dviejų kompleksinių skaičių sandaugą, kuri yra gaunama iš dviejų vidinių vektorių sandaugų \\(\\langle\\psi |\\phi\\rangle\\) ir \\(\\langle\\phi |\\psi\\rangle\\). Kadangi šie du nariai nusako skaičius, juos galime pergrupuoti, kaip pageidaujama, nekeičiant rezultato; tai ir parodyta viršuje. Kompleksiniame kvadrate vektorių eiliškumas nėra svarbus. Ortogonaliųjų vektorių normuotumas gali būti glaustai užrašytas taip: \\(\\langle v_i|v_j \\rangle = \\delta_{ij}\\). Čia simbolis \\(\\delta_{ij}\\) vadinamas Kronekerio delta funkcija (angl. Kronecker delta function), kuri \\(\\delta_{ij} = 0\\), jeigu \\(i \\neq j\\) (pavyzdžiui, baziniai vektoriai vidinėje sandaugoje skiriasi) bei \\(\\delta_{ij} = 1\\), jeigu \\(i = j\\). Imkime vektorių \\(|v\\rangle\\), išreikštą ortogonaliaisiais baziniais vektoriais \\(\\big\\{|v_i \\rangle\\big\\}\\) su atitinkamais koeficientais \\(z_i\\): \\[\\begin{equation} |v\\rangle = \\sum_i z_i |v_i \\rangle\\,. \\tag{2.42} \\end{equation}\\] Naudodami \\(\\delta_{ij}\\), bet kurį \\(i\\)-tąjį koeficientą \\(z_i\\) galime rasti atlikę vektoriaus \\(|v\\rangle\\) vidinę sandaugą su atitinkamu bra \\(\\langle v_i|\\): \\[\\begin{equation} z_i = \\langle v_i |v \\rangle\\,. \\tag{2.43} \\end{equation}\\] Vidinės sandaugos geometrinę interpretaciją galime lengviau pamatyti naudodami 2 dimensijų Euklido vektorių erdvę. Imkime \\(|\\phi\\rangle = a|0\\rangle + b|1\\rangle\\) normuotąjį vektorių, išreikštą \\(|0\\rangle\\) ir \\(|1\\rangle\\) baziniais vektoriais, ir konkretų \\(a\\) ir \\(b\\) koeficientų pavyzdį: \\[\\begin{equation} |\\phi\\rangle = \\frac{2}{\\sqrt{13}}|0\\rangle + \\frac{3}{\\sqrt{13}}|1\\rangle = \\frac{1}{\\sqrt{13}}\\begin{bmatrix} 2 \\\\ 3 \\\\ \\end{bmatrix}\\,. \\tag{2.44} \\end{equation}\\] Atlikę šio vektoriaus vidinę sandaugą su \\(|0\\rangle\\) vektoriumi rasime: \\[\\begin{equation} \\langle 0|\\phi\\rangle = \\frac{2}{\\sqrt{13}}\\langle 0|0\\rangle + \\frac{3}{\\sqrt{13}}\\langle 0|1\\rangle = \\frac{2}{\\sqrt{13}}\\,. \\tag{2.45} \\end{equation}\\] Viršuje \\(\\langle 0|0\\rangle = 1\\) ir \\(\\langle 0|1\\rangle = 0\\), naudojant bazinių vektorių ortogonalumą ir normuotumą, apibendrinta minėta delta funkcija \\(\\langle v_i |v_j \\rangle = \\delta_{ij}\\). Galime šią vidinę sandaugą iliustruoti 2.3 pav. 2.3 pav. Vektoriaus \\(|\\phi\\rangle\\) dekompozicija į statmenus vienetinius (bazinius) vektorius \\(|0\\rangle\\) ir \\(|1\\rangle\\). Vidinės sandaugos čia nusako \\(|\\phi\\rangle\\) vektoriaus projekcijas (arba persiklojimą) į atitinkamus bazinius vektorius Nubrėžę brūkšniuotą statmeną liniją matome, kad vidinė sandauga \\(\\langle 0|\\phi\\rangle\\) indikuoja \\(|\\phi\\rangle\\) vektoriaus projekcijos dydį (arba persiklojimą) santykinai su \\(|0\\rangle\\) vektoriumi. Tai atspindi koeficientas šalia \\(|0\\rangle\\) vektoriaus. Analogiškai randama projekcija į \\(|1\\rangle\\) bazinį vektorių vidinėje sandaugoje \\(\\langle 1|\\phi\\rangle\\). Net ir kompleksinėje vektorių erdvėje yra teisinga sakyti, kad \\(\\langle 0|\\phi \\rangle\\) parodo, kokį komponentą \\(|\\phi\\rangle\\) turi \\(|0\\rangle\\) atžvilgiu. Norėdami įvertinti, kiek du normuotieji kompleksiniai vektoriai persikloja, galime apskaičiuoti vidinės sandaugos modulį \\[\\begin{equation} \\big|\\langle\\psi |\\phi \\rangle \\big| = \\sqrt{\\langle\\psi |\\phi\\rangle\\langle\\phi |\\psi\\rangle} = \\cos(\\theta)\\,. \\tag{2.46} \\end{equation}\\] \\(\\theta\\) nusako kampą tarp vektorių \\(|\\phi\\rangle\\) ir \\(|\\psi\\rangle\\). Verta atkreipti dėmesį, kad kampas čia yra apibrėžtas \\(0 \\leq \\theta \\leq \\pi/2\\), kadangi modulis visada grąžina teigiamąjį skaičių. Matome, kad dviejų vienodų vektorių vidinės sandaugos modulis yra 1, o ortogonaliųjų (\\(\\theta = \\pi/2\\)), žinoma, 0. 2.4 Kubito reprezentacija Blocho sferoje Vieno kubito būsenas \\(|\\psi\\rangle = a |0\\rangle + b|1\\rangle\\) įmanoma išreikšti geometriškai naudojant vadinamąją Blocho sferos reprezentaciją. Kubitas šioje reprezentacijoje pavaizduojamas kaip orientuotasis vektorius realioje 3 dimensijų erdvės Blocho sferoje, prasidedantis nuo sferos centro ir užsibaigiantis jos paviršiuje. Tokį kubito būsenos pavaizdavimą galime rasti pirmiausiai išreiškę kompleksinius skaičius \\(a\\) ir \\(b\\) Oilerio formule: \\[\\begin{equation} |\\psi\\rangle = |a|\\mathrm{e}^{\\mathrm{i}\\phi_1}|0\\rangle + |b|\\mathrm{e}^{\\mathrm{i}\\phi_2}|1\\rangle\\,. \\tag{2.47} \\end{equation}\\] Kadangi \\(\\mathrm{e}^{\\mathrm{i}\\phi}\\) narių modulis yra \\(|\\mathrm{e}^{\\mathrm{i}\\phi}| = 1\\) ir amplitudės susideda \\(|a|^2 + |b|^2 = 1\\), galime atlikti keitimą \\(|a| + |b| = \\cos(\\alpha) + \\sin(\\alpha)\\). Kampams paprastai yra leidžiama kisti nuo 0 iki \\(2\\pi\\) apsukant visą ratą. Tačiau \\(|a|\\) ir \\(|b|\\) yra teigiamieji skaičiai, tad išsaugodami šį reikalavimą turime apibrėžti \\(\\alpha\\) kampą \\(0 \\leq \\alpha \\leq \\pi/2\\). Konvenciškai yra taikomas keitimas \\(\\alpha = \\theta/2\\) ir kampas \\(\\theta\\) apibrėžiamas \\(0 \\leq \\theta \\leq \\pi\\), tad amplitudės tampa \\(|a| + |b| = \\cos(\\theta/2) + \\sin(\\theta/2)\\). Iškeldami \\(\\mathrm{e}^{\\mathrm{i}\\phi_1}\\) narį ir pervadindami \\(\\phi_2 - \\phi_1 \\equiv \\phi\\), gauname: \\[\\begin{equation} |\\psi\\rangle = \\mathrm{e}^{\\mathrm{i}\\phi_1}\\big(\\cos(\\theta/2)|0\\rangle + \\sin(\\theta/2)\\mathrm{e}^{\\mathrm{i}\\phi}|1\\rangle\\big)\\,. \\tag{2.48} \\end{equation}\\] Kadangi globali kvantinės būsenos fazė neturi fizinės įtakos, galime panaikinti narį \\(\\mathrm{e}^{\\mathrm{i}\\phi_1}\\). Taip prieiname prie kubito būsenos Blocho reprezentacijos: \\[\\begin{equation} |\\psi\\rangle = \\cos(\\theta/2)|0\\rangle + \\sin(\\theta/2)\\mathrm{e}^{\\mathrm{i}\\phi}|1\\rangle\\,. \\tag{2.49} \\end{equation}\\] Iš pirmo žvilgsnio atrodytų, kad turint dvi kompleksines amplitudes \\(a\\) ir \\(b\\) reikia bendrai keturių realiųjų skaičių nusakyti bendrai kubito būsenai. Tačiau dėl reikalavimo amplitudžių kvadratui susidėti į vienetą ir įtakos nedarančios globalios fazės pakanka tik dviejų realiujų skaičių. Pirmasis parametras \\(0 \\leq \\theta \\leq \\pi\\) nusako ilgumos kampą, kurį šioje reprezentacijoje Blocho vektorius sudaro su Blochos sferos \\(z\\) ašimi. Antrasis parametras \\(0 \\leq \\phi &lt; 2\\pi\\), nusako azimutinį kampą, kurį šio vektoriaus projekcija sudaro \\(x\\)–\\(y\\) plokštumoje (sferos pusiaujyje) skaičiuojant nuo teigiamosios \\(x\\) ašies. Blocho vektorius, tolydžiai keičiant šiuos du parametrus, apibūdina visus įmanomus taškus Blocho sferos paviršiuje. 2.4 pav. Bendra kubito būsena \\(|\\psi\\rangle\\) nusakoma Blocho vektoriumi, pažymėtu nuo Blocho sferos centro iki jos paviršiaus. Išilgai \\(x\\), \\(y\\) ir \\(z\\) ašių pažymėtos dažnai algoritmuose pasitelkiamos būsenos Patikrinkime keletą orientacijų, kad pamatytume, kaip Blocho sferoje pavaizduojamos skirtingos kubito būsenos. Jeigu imsime kampą \\(\\theta = 0\\), tada \\(\\cos(0/2) = 1\\), \\(\\sin(0/2) = 0\\) ir randame, kad į \\(+z\\) orientuotas Blocho vektorius nusako \\(|0\\rangle\\) būseną. Jeigu imsime \\(\\theta = \\pi\\), tada \\(\\cos(\\pi/2) = 0\\), \\(\\sin(\\pi/2) = 1\\) ir randame, kad į \\(-z\\) orientuotas vektorius nusako \\(|1\\rangle\\) būseną. Šiame kubito parametrizavime \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenos, kurios, kaip žinome, yra ortogonalios, vaizduojamos kaip antiparaleliai orientuoti Blocho vektoriai. Tai gali šiek tiek klaidinti ir šį skirtumą, atsirandantį perteikiant 1 kubito kompleksinę vektorių erdvę realioje sferoje, tiesiog reikia prisminti. Tad jeigu \\(z\\) ašys nusako \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenas, kokios būsenos yra išilgai \\(x\\) ir \\(y\\) ašių? Šias būsenas vadinsime atitinkamai \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\) bei \\(|0_y \\rangle\\) ir \\(|1_y \\rangle\\). Išilgai \\(x\\) ašies turime \\(\\theta = \\pi/2,\\) o imdami \\(\\phi = 0\\) ir \\(\\phi = \\pi\\) randame \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\): \\[\\begin{equation} |0_x \\rangle = \\frac{1}{\\sqrt{2}}\\big( |0\\rangle + |1\\rangle\\big)\\,,\\quad |1_x \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle - |1\\rangle\\big)\\,. \\tag{2.50} \\end{equation}\\] Išilgai \\(y\\) ašies \\(\\theta = \\pi/2\\) bei \\(\\phi = \\ \\pi/2\\) ir \\(\\phi = 3\\pi/2\\), randame \\(|0_y \\rangle\\) ir \\(|1_y \\rangle\\): \\[\\begin{equation} |0_y \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + \\mathrm{i}|1\\rangle\\big)\\,,\\quad |1_y \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle - \\mathrm{i}|1\\rangle)\\,. \\tag{2.51} \\end{equation}\\] Šios būsenos, kaip ir visos kitos \\(x\\)–\\(y\\) plokštumoje, yra lygios \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenų superpozicijos, besiskiriančios viena nuo kitos santykinėmis \\(\\phi\\) fazėmis. Galima patikrinti jų ortogonalumą, \\(\\langle 0_x|1_x \\rangle = 0\\), \\(\\langle 0_y |1_y \\rangle = 0\\). Trumpam grįžkime prie to, kodėl Blocho sferos reprezentacijoje atsiranda pusiniai kampai \\(\\theta/2\\). Kvantiniai 1 kubito loginiai vartai yra visiškai nusakomi unitariniais operatoriais, priklausančiais SU(2) grupei (angl. special unitary group), kurie atlieka vektoriaus rotaciją 2 kompleksinių dimensijų erdvėje. Tačiau Blocho sferoje vartų efektą iliustruojame kaip vektoriaus rotacijas 3 dimensijų Euklido erdvėje, kurias apibūdina operatoriai, priklausantys SO(3) grupei (angl. special orthogonal group). Tarp šių grupių yra atsitiktinė sąsaja, ledžianti atlikti SU(2) elemento vizualizaciją, tačiau SU(2) grupė dvigubai dengia SO(3) grupę. Tai reiškia, kad du SU(2) elementus, besiskiriančius tik \\(\\pi\\) faze, galime perteikti tuo pačiu elementu SO(3) grupėje, išsaugodami visą likusią grupės struktūrą. Dėl to rotacija \\(\\theta\\) kampu Blocho sferoje nusako \\(\\theta/2\\) rotaciją kompleksinėje vektorių erdvėje. Turime apeiti Blocho sferą aplink du kartus (\\(\\theta = 4\\pi\\)) siekdami sugrįžti į tą pačią būseną. 2.5 Tiesiniai operatoriai ir matricos Kvantiniai loginiai vartai matematikoje yra nusakomi objektais, kurie vadinami tiesiniais operatoriais (angl. linear operator). Operatoriai, veikdami vektoriais nusakytas kvantines būsenas, apibūdina šių vektorių transformacijas. Pavyzdžiui, 1 kubito Blocho sferos reprezentacijoje operatoriaus veiksmas yra keisti Blocho vektoriaus orientaciją sferoje. Formaliai, operatorius \\(A\\) (vartojame didžiąsias raides žymėti operatoriams) transformuoja kiekvieną vektorių \\(|v\\rangle \\in V\\) į kitą vektorių \\(|u\\rangle\\), priklausantį tai pačiai vektorių erdvei, \\(|u\\rangle \\in V\\): \\[\\begin{equation} A|v\\rangle = |u\\rangle\\,. \\tag{2.52} \\end{equation}\\] Operatoriaus veiksmas ket vektoriui yra užrašomas panašiai kaip jų tarpusavio sandauga, kurioje operatorius stovi kairėje ket pusėje. Toliau pateikiame elementarias operacijas tarp operatorių ir vektorių, operatorių ir operatorių. Skaičių, dauginantį vektorių, galima visada iškelti už operatoriaus ir vektoriaus: \\[\\begin{equation} A\\big(z|v\\rangle\\big) = zA|v\\rangle\\,. \\tag{2.53} \\end{equation}\\] Visi loginiai vartai kvantinėje kompiuterijoje yra tiesiniai operatoriai. Operatoriaus tiesiškumo savybė jam veikiant bet kokius du (ar daugiau) vektorius: \\[\\begin{equation} A\\big(|v\\rangle + |u\\rangle\\big) = A|v\\rangle + A|u\\rangle\\,. \\tag{2.54} \\end{equation}\\] Tai parodo, kad operatorius \\(A\\) veikia atskirai kiekvieną vektorių sumoje tiesiniu būdu. Kadangi bet kokį vektorių \\(V\\) erdvėje galima išreikšti pasirinktais baziniais vektoriais, norint nustatyti \\(A|\\psi\\rangle\\) pakanka žinoti, kaip tiesinis operatorius veikia pasirinktus bazinius vektorius. Du operatoriai \\(A\\) ir \\(B\\) yra lygūs (\\(A = B\\)), jeigu bet kokiam vektoriui galioja sąlygos \\(|v\\rangle \\in V\\), \\(A|v\\rangle = B|v\\rangle\\). Dviejų tiesinių operatorių suma nusako kitą tiesinį operatorių \\(A + B = C\\): \\[\\begin{equation} C|v\\rangle = (A + B)|v\\rangle = A|v\\rangle + B|v\\rangle\\,. \\tag{2.55} \\end{equation}\\] Operatorių sudėtyje eiliškumas nėra svarbus, \\(A + B = B + A\\). Vienas iš paprasčiausių operatorių yra identitetas (angl. identity), žymimas simboliu \\(I\\) ir dar vadinamas vienetiniu operatoriumi. Identititetas, veikdamas vektorių, jo nekeičia \\(I|v\\rangle = |v\\rangle\\); tai yra analogiška vektoriaus sandaugai su skaičiumi 1. Taip pat egzistuoja ir nulinis operatorius, vadinsime jį \\(N\\), \\(N|v\\rangle = 0\\). Dviejų operatorių sandauga \\(AB = D\\) nusako kitą operatorių: \\[\\begin{equation} AB|v\\rangle = D|v\\rangle\\,. \\tag{2.56} \\end{equation}\\] Kairėje lygties dalyje operatorius \\(B\\) veikia vektorių \\(|v\\rangle\\), toliau operatorius \\(A\\) veikia gautą vektorių \\(B|v\\rangle\\). Eiliškumas operatorių sandaugoje bendrai yra svarbus, nes kvantinėje kompiuterijoje dažnai aptinkami operatoriai, kuriems \\(AB \\neq BA\\). Tik itin specifinėse situacijose galima aptikti, kai eiliškumas nėra svarbus, \\(AB = BA\\). Kai dviejų ar daugiau operatorių sandaugos eiliškumas nėra svarbus, tokie operatoriai yra vadinami tarpusavyje komutatyviais (angl. commutative operators). Dviejų operatorių komutatyvumas yra standartiškai užrašomas įdedant juos į skliaustelius, kurios forma išskleidus reiškia: \\[\\begin{equation} \\lbrack A,B\\rbrack = AB - BA\\,. \\tag{2.57} \\end{equation}\\] Operatoriai \\(A\\) ir \\(B\\) yra komutatyvūs, jeigu \\(\\lbrack A,B\\rbrack = 0\\) ir nekomutatyvūs, jeigu \\(\\lbrack A,B\\rbrack \\neq 0\\). Kita savybė, dviejų operatorių antikomutatyvumas (angl. anticommutative), yra operacija, apibrėžta lenktiniais skliausteliais: \\[\\begin{equation} \\big\\{ A,B \\big\\} = AB + BA\\,. \\tag{2.58} \\end{equation}\\] Du operatoriai yra antikomutatyvieji, jeigu \\(\\big\\{ A,B \\big\\} = 0\\). Sukeitus antikomutatyviuosius operatorius vietomis skliausteliuose, jų sandaugoje atsiranda minuso ženklas, nes \\(AB = - BA\\). Šios dvi operatorių klasės aptinkamos specifinėse kvantinių skaičiavimų užduotyse, kaip bus aptarta vėliau. Abstraktus operatorius kvantinėje kompiuterijoje gali būti visada realizuojamas tiesinėje algebroje matricos forma – sugrupuotų skaičių lentele. Tai yra vadinama operatoriaus vaizdavimas matrica (angl. matrix representation). Abstrakti operatoriaus forma ir matricos forma yra ekvivalentiškos, tad šiuos terminus dažnai vartosime pakaitomis. Verta atsiminti, kad jei norime realizuoti operatorių matricos forma, reikia pasirinkti tam tikrą vektorių erdvės \\(V\\), kuriame veikia operatorius \\(A\\), bazinių vektorių rinkinį. Mat operatorius gali būti išreikštas su skirtingais bazinių vektorių rinkiniais. Jeigu nėra nurodoma kitaip, operatoriai standartiškai išreiškiami skaičiuojamųjų vektorių bazėje \\(\\big\\{|0\\rangle , |1\\rangle\\big\\}\\). Išsamiau panagrinėkime, kaip tiesiniai operatoriai (loginiai vartai) yra išreiškiami matricų forma, kuo išsiskiria tokių matricų savybės ir jų aritmetika. Matrica, transformuojanti vektorių \\(n\\) dimensijų vektorių erdvėje, yra kvadratinės formos kompleksinių skaičių lentelė, turinti (\\(n\\times n\\)) elementų (sakoma: \\(n\\) stulpelių ir \\(n\\) eilučių). Kadangi \\(n\\) kubitų vektorių erdvė yra \\(2^n\\) dimensijų, kvantinėje kompiuterijoje paprastai aptinkame tik kvadratines matricas su lyginiu skaičiumi eilučių ir stulpelių. Pavyzdžiui, visos vieno kubito būsenas nusakančios transformacijos yra išreiškiamos (\\(2\\times 2\\)) dydžio matricomis. Toliau pateikiame pagrindines aritmetines operacijas tarp matricų, iliustracijai naudodami (\\(3\\times 3\\)) matricų dydį. Matricų sudėtis galima tik tarp tokio paties dydžio matricų. Dviejų operatorių \\(A\\) ir \\(B\\), išreikštų matricomis, sudėtis: \\[\\begin{equation} \\begin{aligned} A + B = &amp;\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\\\ \\end{bmatrix} + \\begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} \\\\ b_{21} &amp; b_{22} &amp; b_{23} \\\\ b_{31} &amp; b_{32} &amp; b_{33} \\\\ \\end{bmatrix} \\\\ = &amp; \\begin{bmatrix} a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; a_{13} + b_{13} \\\\ a_{21} + b_{21} &amp; a_{22} + b_{22} &amp; a_{23} + b_{23} \\\\ a_{31} + b_{31} &amp; a_{32} + b_{32} &amp; a_{33} + b_{33} \\\\ \\end{bmatrix}\\,. \\end{aligned} \\tag{2.59} \\end{equation}\\] Matricų elementus, kurie yra bendrai kompleksiniai skaičiai, čia vadiname \\(a_{ij}\\) ir \\(b_{ij}\\). Pirmasis simbolis \\(i\\) padeda įvardyti eilutės numerį (skaičiuojant nuo viršaus), antrasis simbolis \\(j\\) – stulpelio numerį (skaičiuojant iš kairės). Taip rašyti nebūtina, tačiau pravartu siekiant greičiau įvardyti matricos elementus. Norint sudėti dvi matricas \\(A\\) ir \\(B\\) jų stulpelių ir eilučių skaičius turi būti vienodas. Sudėties tvarka yra nesvarbi \\(A + B = B + A\\), vadovaujantis minėta abstraktesne operatorių aritmetika. Skaičiaus ir matricos sandauga \\(zA = Az\\) yra apibrėžta: \\[\\begin{equation} z\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\\\ \\end{bmatrix} = \\begin{bmatrix} za_{11} &amp; za_{12} &amp; za_{13} \\\\ za_{21} &amp; za_{22} &amp; za_{23} \\\\ za_{31} &amp; za_{32} &amp; za_{33} \\\\ \\end{bmatrix}\\,. \\tag{2.60} \\end{equation}\\] Dviejų matricų sandauga tarpusavyje galima, jeigu pirmosios matricos stulpelių skaičius yra lygus antrosios matricos eilučių skaičiui. Kadangi čia susiduriame tik su kvadratinės formos matricomis, tai reiškia, kad matricos sandaugoje turi būti tokio paties dydžio. Sandaugoje gautas naujas darinys yra tokio paties dydžio nauja matrica. Matricų \\(AB = C\\) sandauga atliekama taip: \\[\\begin{equation} \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\\\ \\end{bmatrix}\\begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} \\\\ b_{21} &amp; b_{22} &amp; b_{23} \\\\ b_{31} &amp; b_{32} &amp; b_{33} \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{11} &amp; c_{12} &amp; c_{13} \\\\ c_{21} &amp; c_{22} &amp; c_{23} \\\\ c_{31} &amp; c_{32} &amp; c_{33} \\\\ \\end{bmatrix}\\,. \\tag{2.61} \\end{equation}\\] Kiekvienas elementas \\(c_{ij}\\) yra atitinkamos \\(A\\) eilutės ir \\(B\\) stulpelio elementų sandaugų suma: \\[\\begin{equation} C = \\begin{bmatrix} a_{11}b_{11} + a_{12}b_{21} + a_{13}b_{31} &amp; a_{11}b_{12} + a_{12}b_{22} + a_{13}b_{32} &amp; a_{11}b_{13} + a_{12}b_{23} + a_{13}b_{33} \\\\ a_{21}b_{11} + a_{22}b_{21} + a_{23}b_{31} &amp; a_{21}b_{12} + a_{22}b_{22} + a_{23}b_{32} &amp; a_{21}b_{13} + a_{22}b_{23} + a_{23}b_{33} \\\\ a_{31}b_{11} + a_{12}b_{21} + a_{13}b_{31} &amp; a_{31}b_{12} + a_{32}b_{22} + a_{33}b_{32} &amp; a_{31}b_{13} + a_{32}b_{23} + a_{33}b_{33} \\\\ \\end{bmatrix}\\,. \\tag{2.62} \\end{equation}\\] Matricų daugyba yra asociatyvi, pavyzdžiui, trijų operatorių sandaugoje \\(ABC = A(BC) = (AB)C\\). Galime pasirinkdami sudauginti pirmiausiai \\(BC\\) arba \\(AB\\) tarpusavyje. Šiame skyriuje minėtos vektorių operacijos: vektoriaus transpozicija, kompleksinė bei ermitinė jungtys yra taip pat naudojamos matricoms. Matricos transpozicija \\(A^T\\) sukeičia eilučių ir stulpelių elementus vietomis taip: \\[\\begin{equation} A^T = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\\\ \\end{bmatrix}^{T} = \\begin{bmatrix} a_{11} &amp; a_{21} &amp; a_{31} \\\\ a_{12} &amp; a_{22} &amp; a_{32} \\\\ a_{13} &amp; a_{23} &amp; a_{33} \\\\ \\end{bmatrix}\\,. \\tag{2.63} \\end{equation}\\] Matricų sandaugoje transpozicija sukeičia operatorių eiliškumą, \\((AB)^T = B^T A^T\\). Matricos kompleksinė jungtis \\(A^{*}\\) kiekvienam jo elementui atlieka kompleksinę jungtį \\(a_{ij}^{*}\\). Ermitinė matricos jungtis taip pat yra kartu atliekama transpozicija ir elementų kompleksinė jungtis \\(A^{\\dagger} = \\big(A^T\\big)^{*}\\): \\[\\begin{equation} A^{\\dagger} = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\\\ \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} a_{11}^{*} &amp; a_{21}^{*} &amp; a_{31}^{*} \\\\ a_{12}^{*} &amp; a_{22}^{*} &amp; a_{32}^{*} \\\\ a_{13}^{*} &amp; a_{23}^{*} &amp; a_{33}^{*} \\\\ \\end{bmatrix}\\,. \\tag{2.64} \\end{equation}\\] Matricų sandaugoje tai sukeičia eiliškumą \\((AB)^{\\dagger} = B^{\\dagger}A^{\\dagger}\\). Taip pat galima parodyti, kad \\((A^{\\dagger})^{\\dagger} = A\\), \\((A + B)^{\\dagger} = A^{\\dagger} + B^{\\dagger}\\) ir \\((zA)^{\\dagger} = z^{*}A^{\\dagger}\\). Pateikiame keturis kvantinėje kompiuterijoje dažnai aptinkamus operatorius ir jų matricų išraiškas skaičiuojamųjų vektorių bazėje \\(\\big\\{|0\\rangle , |1\\rangle\\big\\}\\): \\[\\begin{equation} I = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix}\\,,\\quad X = \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}\\,,\\quad Y = \\begin{bmatrix} 0 &amp; - i \\\\ i &amp; 0 \\\\ \\end{bmatrix}\\,,\\quad Z = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; - 1 \\\\ \\end{bmatrix}\\,. \\tag{2.65} \\end{equation}\\] Šios matricos vadinamos fiziko Pauli vardu (angl. Wolfgang Pauli) ir sudaro vadinamąjį Pauli bazinių matricų rinkinį \\(\\{ I, X, Y, Z\\}\\). Trys Pauli matricos \\(X\\), \\(Y\\), \\(Z\\) yra tarpusavyje nekomutatyvios, bet kurių dviejų Pauli matricų sandauga gražina trečiąją: \\[\\begin{align} XY = &amp; \\mathrm{i}Z\\,,\\quad XZ = -\\mathrm{i}Y\\,,\\quad YZ = \\mathrm{i}X\\,; \\tag{2.66}\\\\ YX = &amp; -\\mathrm{i}Z\\,,\\quad ZX = \\mathrm{i}Y\\,,\\quad ZZ = - \\mathrm{i}X\\,. \\tag{2.67} \\end{align}\\] Tai galime lengvai patikrinti, pavyzdžiui \\(XY\\) ir \\(YX\\): \\[\\begin{align} XY = &amp; \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}\\begin{bmatrix} 0 &amp; - \\mathrm{i} \\\\ \\mathrm{i} &amp; 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\cdot 0 + 1 \\cdot \\mathrm{i} &amp; 0 \\cdot 0 + 1 \\cdot 0 \\\\ 1 \\cdot 0 + 0 \\cdot \\mathrm{i} &amp; 1\\cdot (-\\mathrm{i}) + 0 \\cdot 0 \\\\ \\end{bmatrix} = \\mathrm{i}\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; - 1 \\\\ \\end{bmatrix} = \\mathrm{i}Z\\,; \\tag{2.68}\\\\ YX = &amp; \\begin{bmatrix} 0 &amp; -\\mathrm{i} \\\\ \\mathrm{i} &amp; 0 \\\\ \\end{bmatrix}\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\cdot 0 + 1 \\cdot (-\\mathrm{i}) &amp; 0 \\cdot 1 + 0 \\cdot (-\\mathrm{i}) \\\\ \\mathrm{i}\\cdot 0 + 0 \\cdot 1 &amp; \\mathrm{i} \\cdot 1 + 0 \\cdot 0 \\\\ \\end{bmatrix} = \\mathrm{i}\\begin{bmatrix} -1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix} = -\\mathrm{i}Z\\,. \\tag{2.69} \\end{align}\\] Akivaizdu, kad \\(X\\), \\(Y\\), \\(Z\\) Pauli operatoriai yra tarpusavyje antikomutatyvūs. Grįžkime prie vektorių veikimo operatoriumi, norėdami parodyti, kokios operacijos yra matematiškai apibrėžtos. Tą galime pavaizduoti matricų reprezentacija, nes vektorius gali būti taip pat formaliai vadinamas matrica. Pavyzdžiui, vieno kubito ket vektorius \\(|v\\rangle\\) yra išreiškiamas \\((2\\times 1)\\) dydžio matrica (vektorius stulpelis), tiesinėje algebroje turinčia dvi eilutes ir vieną stulpelį. O štai bra vektorius \\(\\langle v|\\) yra išreiškiamas \\((1\\times 2)\\) matrica (vektorius eilutė), turinčia vieną eilutę ir du stulpelius. Prisimenant matricų daugybą, leidžiama dauginti dvi \\((n\\times n)\\), \\((n\\times 1)\\) dydžio matricas; tai atlikę gauname naują \\((n\\times 1)\\) dydžio matricą, o tiksliau – vektorių stulpelį (ket). Tačiau šių dviejų matricų atvirkštinė daugyba \\((n\\times 1)(n\\times n)\\) nėra galima, nes stulpelių skaičius pirmojoje matricoje ir eilučių skaičius antrojoje neatitinka. Tai parodo, kad negalimas ket vektoriaus veikimas operatoriumi; jeigu ket stovi operatoriaus kairėje, \\(|v\\rangle A\\) yra neapibrėžta operacija. Teisingas eiliškumas yra \\(A|v\\rangle\\). Bra vektoriaus veikimas operatoriumi atliekamas būtent bra esant operatoriaus kairėje \\(\\langle v|A\\). Taip gaunamas kitas bra vektorius, nes \\((1\\times n)(n\\times n) = (1\\times n)\\). Šioje situacijoje neteisingas eiliškumas būtų \\(A\\langle v|\\). Iliustracijai imkime \\(X|0\\rangle\\) ir \\(\\langle 0|X\\): \\[\\begin{align} X|0\\rangle = &amp; \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}\\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\cdot 1 + 1 \\cdot 0 \\\\ 1 \\cdot 1 + 0 \\cdot 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = |1\\rangle\\,;\\tag{2.70}\\\\ \\langle 0| X = &amp; \\lbrack 1\\: 0 \\rbrack\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} = \\lbrack 1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 \\rbrack = \\lbrack 0\\: 1 \\rbrack = \\langle 1|\\,. \\tag{2.71} \\end{align}\\] Pamename, kad \\(|v\\rangle^{\\dagger} = \\langle v|\\) bei \\((AB)^{\\dagger} = B^{\\dagger}A^{\\dagger}\\). Iš to gauname, kad \\(\\big( A|v\\rangle\\big)^{\\dagger} = \\langle v| A^{\\dagger}\\). Todėl dualioje erdvėje \\(A|v\\rangle\\) operacijos atitikmuo yra ermitinė \\(A^{\\dagger}\\) operatoriaus jungtis, veikianti bra vektorių iš dešinės \\(\\langle v| A^{\\dagger}\\). Viršuje \\(X\\) operatorius turi tokią savybę – jo ermitinė jungtis yra lygi jam pačiam, tad \\(X = X^{\\dagger}\\). Taip pat atkreipiame dėmesį į tokio tipo operaciją: \\[\\begin{equation} \\langle u | A | v \\rangle = a_{uv}\\,. \\tag{2.72} \\end{equation}\\] Dėl daugybos asociatyvumo šią operaciją galime atlikti dviem būdais: \\(\\langle u|A|v\\rangle = \\langle u|\\big(A|v\\rangle\\big) = \\big(\\langle u|A\\big)|v\\rangle\\). Naryje \\(\\langle u|\\big(A|v\\rangle\\big)\\) operatorius \\(A\\) veikia vektorių \\(|v\\rangle\\) iš kairės, grąžindamas bendrai kitą vektorių, sakykime, \\(A|v\\rangle = |g\\rangle\\). Iš to gaunamas vidinės sandaugos \\(\\langle u|g\\rangle\\) rezultatas – skaičius \\(a_{uv}\\). Antruoju būdu naryje \\(\\big(\\langle u|A\\big)|v\\rangle\\) pirmiausiai atliekama \\(\\langle u|A\\) ir toliau – vidinė sandauga su \\(|v\\rangle\\). 2.6 Unitariniai ir ermitiniai operatoriai Unitariniai operatoriai yra plačiausiai naudojama ir aptinkama operatorių klasė kvantinėje kompiuterijoje. Šie operatoriai matematiškai apibūdina kvantinių loginių vartų efektą – jie transformuoja vektoriais nusakomas kubitų būsenas į kitas būsenas. Unitarinis operatorius \\(U\\) pasižymi savybe šia savybe: \\[\\begin{equation} U^{\\dagger}U = UU^{\\dagger} = I\\,. \\tag{2.73} \\end{equation}\\] Tai parodo, kad unitarinio operatoriaus sandauga su jo ermitine jungtimi \\(U^{\\dagger}\\) yra lygi vienetiniam operatoriui. Vadinasi, \\(U^{\\dagger}\\) yra atvirkštinis \\(U\\) operatoriui (rašoma \\(U^{\\dagger}= U^{-1}\\)), ir todėl galima visada atstatyti pradinį vektorių: \\(U^{\\dagger}U|v\\rangle = I|v\\rangle = |v\\rangle\\). Unitariniai operatoriai turi kitą svarbią savybę – veikdami vektorių \\(|v\\rangle\\) transformuoja jį į kitą vektorių, tačiau nekeičia vektoriaus ilgio. Dėl šios priežasties veikiantys du skirtingus vektorius unitariniai operatoriai išsaugo jų vidinės sandaugos reikšmę. Imkime du, nebūtinai ortogonaliuosius, vektorius \\(|v\\rangle\\) ir \\(|u\\rangle\\). Minėtas \\(U\\) savybes galime paprastai parodyti: \\[\\begin{equation} \\langle u|U^{\\dagger}U|v\\rangle = \\langle u|I|v\\rangle = \\langle u|v\\rangle\\,. \\tag{2.74} \\end{equation}\\] Jeigu \\(|v\\rangle\\) yra normuotasis vektorius, \\(U\\) išlaiko normuotumą \\(\\langle v|U^{\\dagger}U |v\\rangle = 1\\). Tad unitarinių operatorių efektas gali būti apibūdintas kaip vektorių posūkis vektorių erdvėje. Jeigu \\(U\\) veikia visus bazinius vektorius jų rinkinyje, tada naujai gauti vektoriai nusako kitą transformuotą bazinių vektorių rinkinį (angl. basis transformation). Kita svarbi operatorių klasė kvantinėje kompiuterijoje yra ermitiniai operatoriai (angl. hermitian operator). Operatorių tikrinių vektorių (angl. eigenvector) ir tikrinių verčių (angl. eigenvalue) konceptai leidžia geriau suprasti ermitinių ir unitarinių operatorių savybes bei jų vartojimą. Vektorius \\(|\\lambda\\rangle\\) yra vadinamas tiesinio operatoriaus \\(K\\) tikriniu vektoriumi, o \\(\\lambda\\) yra su šiuo vektoriumi susieta tikrinė vertė (skaičius), jeigu tenkinama lygybė: \\[\\begin{equation} K|\\lambda\\rangle = \\lambda |\\lambda\\rangle\\,. \\tag{2.75} \\end{equation}\\] Atkreipiame dėmesį, kad bendroje situacijoje operatorius, veikdamas vektorių, pakeičia jį į kitą vektorių. Tačiau jeigu \\(|\\lambda\\rangle\\) yra \\(K\\) operatoriaus vienas iš tikrinių vektorių, tada operatoriaus veiksmas šiam vektoriui yra lygus vektoriaus \\(|\\lambda\\rangle\\) ir skaičiaus \\(\\lambda\\) sandaugai – pats vektorius nepakinta. Operatoriaus tikrinės vertės \\(\\lambda\\) tenkina charakteristinę determinantinę lygtį \\(\\det(K - \\lambda I) = 0\\). Charakteristinė lygtis yra bendrai \\(n\\) laipsnio polinomas \\(p(\\lambda) = 0\\), todėl egzistuoja \\(n\\) skaičius tikrinių verčių \\((\\lambda_1 , \\lambda_2 ,\\ldots , \\lambda_n )\\), tenkinančių šią lygtį. Tikriniai vektoriai \\(|\\lambda_i \\rangle\\) yra randami antrame žingsnyje iš lygties \\((K - \\lambda_i I)|\\lambda_i \\rangle = 0\\), žinant su jais asocijuotas tikrines vertes \\(\\lambda_i\\). Ermitinių operatorių tikrinės vertės \\(\\lambda_i\\) yra visada realieji skaičiai. Tai galima lengvai parodyti pradedant nuo \\(K|\\lambda\\rangle = \\lambda |\\lambda\\rangle\\) ir įvertinant šios lygties ermitinę jungtį \\(\\big(K|\\lambda\\rangle\\big)^{\\dagger} = \\langle\\lambda|K^{\\dagger} = \\langle\\lambda|K = \\langle\\lambda|\\lambda^{*}\\). Tad: \\[\\begin{equation} \\langle\\lambda |K|\\lambda\\rangle = \\lambda^{*}\\langle\\lambda |\\lambda\\rangle = \\lambda\\langle\\lambda |\\lambda\\rangle\\,. \\tag{2.76} \\end{equation}\\] Matome, kad \\(\\lambda^{*} = \\lambda\\), ir todėl \\(\\lambda\\) gali būti tik realusis skaičius. Su skirtingomis tikrinėmis vertėmis \\(\\lambda_i\\) asocijuoti tikriniai vektoriai \\(|\\lambda_i\\rangle\\) yra ortogonalieji, \\(\\langle\\lambda_i |\\lambda_j \\rangle = 0\\) (jeigu \\(i \\neq j\\)). Imdami operatoriaus \\(K\\) du tikrinius vektorius \\(|\\lambda_1 \\rangle\\) ir \\(|\\lambda_2 \\rangle\\) bei su jais susietas vertes \\(\\lambda_1\\) ir \\(\\lambda_2\\), galime paprastai parodyti ortogonalumą: \\[\\begin{equation} \\langle\\lambda_2 |K|\\lambda_1 \\rangle = \\lambda_1 \\langle\\lambda_2 |\\lambda_1 \\rangle = \\lambda_2 \\langle\\lambda_2 |\\lambda_1 \\rangle \\rightarrow (\\lambda_1 - \\lambda_2 )\\langle\\lambda_2 |\\lambda_1\\rangle = 0\\,. \\tag{2.77} \\end{equation}\\] Matome, kad jeigu \\(\\lambda_2 \\neq \\lambda_1\\), tada \\(\\langle\\lambda_2 |\\lambda_1 \\rangle = 0\\). Ermitinių operatorių tikrinių verčių realumas ir tikrinių vektorių ortogonalumas yra naudojamas kvantinėje mechanikoje nusakyti stebimiems fizikiniams dydžiams. Siekdami išsamiai aprašyti sistemą reikalaujame, kad ortogonaliųjų tikrinių vektorių skaičius atitiktų visų fiziškai skirtingų kvantinių būsenų skaičių. Jeigu turime \\(K\\) ermitinę matricą \\((d\\times d)\\) dydžio, operuojančią \\(d\\) dimensijų kompleksinių vektorių erdvėje, tada galime būti tikri, kad rasime \\(d\\) tikrinių \\(K\\) matricos vektorių. Ortogonalieji ir normuotieji \\(K\\) operatoriaus tikriniai vektoriai gali būti naudojami kaip baziniai vektoriai toje vektorių erdvėje apibūdinti būsenoms, o fizikiniai dydžiai yra natūraliai nusakomi tikrinėmis vertėmis – realiaisiais skaičiais. Vienalaikio diagonalizavimo teorema (angl. simultaneous diagonalization theorem) nusako, kad jeigu du operatoriai yra komutatyvūs \\([A, B] = 0\\), tada šie operatoriai dalijasi tais pačiais tikriniais vektoriais (su galimai skirtingomis tikrinėmis vertėmis). Mat pasitaiko atvejų, kai du ar daugiau operatoriaus tikrinių vektorių yra susieti su ta pačia tikrine verte \\(\\lambda\\). Tokie vektoriai yra lietuviškai vadinami išsigimusiais (angl. degenerate). Išsigimusiuosius tiesiškai nepriklausomus vektorius visada galima užrašyti forma, kurioje jie yra vienas kitam ortogonalūs. Tad \\(n\\) skaičius išsigimusių tikrinių vektorių su ta pačia tikrine verte \\(\\lambda\\) apibūdina \\(n\\) dimensijų išsigimusį poerdvį. Kvantinės mechanikos praktikoje dažnai galima rasti papildomą operatorių (ar operatorius), kuris taip pat dalijasi tais pačiais tikriniais vektoriais (yra komutatyvusis), tačiau turi skirtingas tikrines vertes šiems vektoriams. Kartu jie leidžia panaikinti išsigimimą ir taip unikaliai atskirti fiziškai skirtingas būsenas. Kitaip nei ermitinių operatorių, unitarinių operatorių tikrinės vertės \\(\\lambda\\) gali būti kompleksiniai skaičiai. Jų tikrinių verčių modulis yra visada lygus vienetui, \\(|\\lambda| = 1\\). Todėl unitarinių operatorių tikrinės vertės turi bendrą formą \\(\\lambda = \\mathrm{e}^{\\mathrm{i}\\theta}\\); \\(\\theta\\) yra realusis skaičius. Kvantinėje kompiuterijoje dažnai aptinkami \\(X\\), \\(Y\\) ir \\(Z\\) yra ermitiniai operatoriai (\\(X = X^{\\dagger}\\), \\(Y = Y^{\\dagger}\\), \\(Z = Z^{\\dagger}\\)), bet tuo pačiu ir unitariniai (nes, pavyzdžiui, \\(ZZ^{\\dagger} = I\\)). Dėl to jie gali atlikti loginių vartų vaidmenį ir kartu apibūdinti fizines sistemos stebimas savybes. Vieno kubito baziniai vektoriai \\(|0\\rangle\\) ir \\(|1\\rangle\\) buvo pasirinkti neatsitiktinai, jie yra Pauli-\\(Z\\) operatoriaus tikriniai vektoriai. Pauli-\\(Z\\) operatoriaus tikrines vertes \\(\\lambda_0\\) ir \\(\\lambda_1\\), susietas su \\(|0\\rangle\\) ir \\(|1\\rangle\\), galime patikrinti taip: \\[\\begin{equation} \\lambda_0 = \\langle 0|Z|0 \\rangle = 1\\langle 0|0\\rangle = 1\\,,\\quad \\lambda_1 = \\langle 1|Z|1 \\rangle = -1\\langle 1|1\\rangle = -1\\,. \\tag{2.78} \\end{equation}\\] Akivaizdu, kad Pauli-\\(Z\\) tikriniai vektoriai \\(|0\\rangle\\) ir \\(|1\\rangle\\) nėra \\(X\\) ir \\(Y\\) operatorių tikriniai vektoriai. Šį dėsningumą pirmiausia matome iš to, kad \\(X\\) ir \\(Y\\) operatoriai veikdami \\(|0\\rangle\\) ir \\(|1\\rangle\\) pakeičia šiuos vektorius, pavyzdžiui, \\(X|0\\rangle = |1\\rangle\\). Formaliai, Pauli \\(X\\), \\(Y\\), \\(Z\\) operatoriai yra tarpusavyje nekomutatyvūs ir todėl neturi bendrų tikrinių vektorių. Pauli-\\(X\\) ir \\(Y\\) operatorių tikriniai vektoriai yra jau minėti: \\[\\begin{align} |0_x \\rangle = &amp; \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\\\ \\end{bmatrix}\\,,\\quad |1_x \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -1 \\\\ \\end{bmatrix}\\,; \\tag{2.79}\\\\ |0_y \\rangle = &amp; \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ \\mathrm{i} \\\\ \\end{bmatrix}\\,,\\quad |1_y \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -\\mathrm{i} \\\\ \\end{bmatrix}\\,. \\tag{2.80} \\end{align}\\] Pauli-\\(X\\) ir \\(Y\\) operatorių tikrinės vertės yra taip pat 1 ir -1, pavyzdžiui, \\(\\lambda_{0x} = \\langle 0_x |X|0_x \\rangle = 1\\), \\(\\lambda_{1x} = \\langle 1_x |X|1_x \\rangle = -1\\). Operatoriai, turintys identiškas tikrines vertes, yra unitariškai ekvivalentiški (angl. unitary equivalent). Tai reiškia, kad jie gali būti transformuojami vienas į kitą panaudojus tam tikrus unitarinius operatorius \\(U\\), \\(A = UBU^{\\dagger}\\). Ši operacija matricos reprezentacijoje atlieka operatoriaus \\(B\\) perteikimą kitais baziniais vektoriais. Panašiai kaip baziniai vektoriai leidžia išreikšti bet kuriuos kitus vektorius toje vektorių erdvėje, visos \\((2\\times 2)\\) dydžio unitarinės matricos \\(U\\) gali būti išreikštos Pauli matricų \\(\\{I, X, Y, Z\\}\\) suma su atitinkamais koeficientais: \\[\\begin{equation} U = c_I I + c_x X + c_y Y + c_z Z\\,. \\tag{2.81} \\end{equation}\\] Čia \\(c_I\\) yra realusis skaičius, \\((c_x\\), \\(c_y\\), \\(c_z\\) – kompleksiniai skaičiai, kurie kartu tenkina lygybę: \\[\\begin{equation} |c_I|^2 + |c_x|^2 + |c_y|^2 + |c_z|^2 = 1\\,. \\tag{2.82} \\end{equation}\\] Unitariniai ir ermitiniai operatoriai priklauso platesnei operatorių grupei, vadinamai normaliaisiais operatoriais (angl. normal operators). Normalieji operatoriai pasižymi \\(AA^{\\dagger}=A^{\\dagger}A\\), o jų tikriniai vektoriai, susieti su skirtingomis tikrinėmis vertėmis, yra ortogonalieji. Toliau matysime, kad normaliuosius operatorius galima paprastai išreikšti taikant vadinamąją spektrinę dekompoziciją. 2.7 Diadinė operatorių dekompozicija Šiame poskyryje pateikiame būdą išreikšti operatoriams taikant bra ir ket vektorių matematinę konstrukciją, vadinama išorine sandauga (angl. outer product), dar žinoma kaip diadinė (angl. dyad) dekompozicija. Ši matematinė konstrukcija itin supaprastina abstraktų operatorių ir vektorių veikimo skaičiavimą kvantinėje kompiuterijoje nereikalaujant naudoti matricų reprezentacijų. Pirmiausiai atkreipiame dėmesį, kad bendrą matricą galima visada išreikšti kitų matricų suma (nebūtinai unikalia). Imkime šį \\((2\\times 2)\\) matricos pavyzdį: \\[\\begin{equation} \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\\\ \\end{bmatrix} = a\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\\\ \\end{bmatrix} + b\\begin{bmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\\\ \\end{bmatrix} + c\\begin{bmatrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} + d\\begin{bmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix}\\,. \\tag{2.83} \\end{equation}\\] Kiekviena iš keturių \\((2\\times 2)\\) matricų yra vektoriaus stulpelio ir vektoriaus eilutės, vadinamosios išorinės sandaugos, rezultatas, \\((2\\times 1)(1\\times 2)(2\\times 2)\\). Pavyzdžiui, šios išorinės sandaugos rezultatas yra antra matrica: \\[\\begin{equation} \\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix}\\lbrack 0\\: 1\\rbrack = \\begin{bmatrix} 1 \\cdot 0\\ &amp; 1 \\cdot 1 \\\\ 0 \\cdot 0 &amp; 0 \\cdot 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\\\ \\end{bmatrix} = |1\\rangle\\langle 0|\\,. \\tag{2.84} \\end{equation}\\] Tai priešinga vidinei vektorių sandaugai, kuri gaunama sudauginus eilutę ir stulpelį, o jos rezultatas yra skaičius. Prisiminę, kad vektorius stulpelis nusako ket, o eilutė bra, matome, kad viršuje pavyzdyje pateikta išorinė sandauga ir matrica gali būti užrašoma glaustai \\(|1\\rangle\\langle 0|\\). Čia \\(|1\\rangle\\) ir \\(\\langle 0|\\) yra kubito Pauli-\\(Z\\) ket (bra) baziniai vektoriai. Todėl bet kokia \\((2\\times 2)\\) matrica yra išreiškiama diadine dekompozicija taip: \\[\\begin{equation} \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\\\ \\end{bmatrix} = a|0\\rangle\\langle 0| + b|1\\rangle\\langle 0| + c|0\\rangle\\langle 1| + d|1\\rangle\\langle 1|\\,. \\tag{2.85} \\end{equation}\\] Apžvelkime diadų bendruosius principus ir jų taikymą. Imkime du vektorius \\(|\\nu\\rangle\\) ir \\(|\\omega\\rangle\\), priklausančius \\(V\\) vektorių erdvei. Jų išorinė sandauga užrašoma \\(|\\nu\\rangle\\langle\\omega|\\) ir yra operatorius, veikiantis \\(V\\) erdvėje. Galime patikrinti, kad diada yra tiesinis operatorius, veikdami ja vektorius \\(a|\\psi\\rangle\\) ir \\(b|\\phi\\rangle\\): \\[\\begin{equation} \\begin{aligned} |\\nu\\rangle\\langle\\omega|\\big(a|\\psi\\rangle + b|\\phi\\rangle\\big) = &amp; a|\\nu\\rangle\\langle\\omega|\\psi\\rangle + b|\\nu\\rangle\\langle\\omega|\\phi\\rangle = az|\\nu\\rangle + bc|\\nu\\rangle \\\\ = &amp; (az + bc)|\\nu\\rangle\\,. \\end{aligned} \\tag{2.86} \\end{equation}\\] Diada veikiant vektorių yra gaunamas kitas vektorius, analogiškai kaip veikiant vektorių operatoriumi. Matome, kad diada \\(|\\nu\\rangle\\langle\\omega|\\) pasuka vektorius \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\) į \\(|\\nu\\rangle\\) vektoriaus kryptį, priklauso nuo to, ar jie persikloja su \\(|\\omega\\rangle\\). Persiklojimą atspindi skaičius, gautas vidinėje sandaugoje, \\(z = \\langle\\omega|\\psi\\rangle\\), \\(c = \\langle\\omega|\\phi\\rangle\\). Dėl daugybos asociatyvumo į \\(|\\nu\\rangle\\langle\\omega|\\psi\\rangle\\) galime žvelgti dviem būdais, nes \\(|\\nu\\rangle\\big(\\langle\\omega|\\psi\\rangle\\big) = \\big(|\\nu\\rangle\\langle\\omega|\\big)|\\psi\\rangle\\). Pirmuoju būdu nusakoma vektoriaus ir skaičiaus sandauga, antruoju – vektoriaus veikimas operatoriumi. Diada \\(|\\nu\\rangle\\langle\\omega|\\) taip pat gali operuoti virš bra vektoriaus iš dešinės, pavyzdžiui, naryje \\(\\langle\\psi|\\nu\\rangle\\langle\\omega|\\). Šiuo atveju vidinė sandauga atliekama su \\(|\\nu\\rangle\\), o bra \\(\\langle\\psi|\\) būtų pasuktas į \\(\\langle\\omega|\\). Diados \\(D = |\\nu\\rangle\\langle\\omega|\\) ermitinė jungtis yra: \\[\\begin{equation} D^{\\dagger} = |\\omega\\rangle\\langle\\nu|\\,. \\tag{2.87} \\end{equation}\\] Vienetinis \\(V\\) vektorių erdvės operatorius \\(I\\) yra išreiškiamas diadomis naudojant šios erdvės bazinių vektorių \\(\\big\\{|m\\rangle\\big\\}\\) rinkinį ir visus juos susumuojant: \\[\\begin{equation} I = \\sum_m |m\\rangle\\langle m|\\,. \\tag{2.88} \\end{equation}\\] Atkreipiame dėmesį, kad vienodi bra ir ket simboliai diadoje nurodo matricos pagrindinės įstrižainės elementus \\(a_{mm}\\). Visi tiesiniai operatoriai turi diadinę dekompoziciją. Šią dekompoziciją galime formaliai išreikšti įterpę \\(A\\) operatorių tarp vienetinių operatorių ir panaudodami vienetinio operatoriaus diadines dekompozicijas: \\[\\begin{equation} \\begin{aligned} A = &amp; IAI = \\sum_{m,n} |m\\rangle\\langle m|A|n\\rangle\\langle n| = \\sum_{m,n} \\langle m|A|n\\rangle |m\\rangle\\langle n| \\\\ = &amp; \\sum_{m,n} a_{mn}|m\\rangle\\langle n|\\,. \\end{aligned} \\tag{2.89} \\end{equation}\\] Čia \\(a_{mn} = \\langle m|A|n\\rangle\\) yra jau matyta operacija. Ji įvardija matricos elementą \\(a_{mn}\\), \\(m\\) eilutėje ir \\(n\\) stulpelyje, pasirinktoje vektorių bazėje. Pauli operatorius ir Hadamardo transformaciją galima paprastai išreikšti diadomis vektorių \\(\\big\\{|0\\rangle , |1\\rangle\\big\\}\\) bazėje: \\[\\begin{align} X = &amp; \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} = |0\\rangle\\langle 1| + |1\\rangle\\langle 0|\\,; \\tag{2.90} \\\\ Y = &amp; \\begin{bmatrix} 0 &amp; -\\mathrm{i} \\\\ \\mathrm{i} &amp; 0 \\\\ \\end{bmatrix} = - \\mathrm{i}|0\\rangle\\langle 1| + \\mathrm{i}|1\\rangle\\langle 0|\\,; \\tag{2.91}\\\\ Z = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; - 1 \\\\ \\end{bmatrix} = |0\\rangle\\langle 0| - |1\\rangle\\langle 1|\\,; \\tag{2.92}\\\\ I = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix} = |0 \\rangle\\langle 0| + |1\\rangle\\langle 1|\\,; \\tag{2.93}\\\\ H = &amp; \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; - 1 \\\\ \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\langle 0| + |1\\rangle\\langle 0| + |0\\rangle\\langle 1| - |1\\rangle\\langle 1|\\big) \\,. \\tag{2.94} \\end{align}\\] Pavyzdžiui, Hadamardo matricos elementai \\(h_{01} = 1\\), \\(h_{11} = -1\\). Iliustruodami diadų naudojimą, pateikiame \\(X|1\\rangle\\) bei \\(YX|0\\rangle\\): \\[\\begin{align} X|1\\rangle = &amp; |1\\rangle\\langle 0|1\\rangle + |0\\rangle\\langle 1|1\\rangle = |0\\rangle\\,; \\tag{2.95} \\\\ YX|0\\rangle = &amp; \\big( -\\mathrm{i}|0\\rangle\\langle 1| + \\mathrm{i}|1\\rangle\\langle 0|\\big)\\big(|0\\rangle\\langle 1| + |1\\rangle\\langle 0|\\big)|0\\rangle\\nonumber \\\\ = &amp; -\\mathrm{i}|0\\rangle\\langle 0|0\\rangle + \\mathrm{i}|1\\rangle\\langle 1|0\\rangle = - \\mathrm{i}|0\\rangle\\,. \\tag{2.96} \\end{align}\\] Taikant bazinių vektorių ortogonalumą, vidinės sandaugos \\(\\langle 0|0\\rangle = 1\\), \\(\\langle 1|0\\rangle = 0\\). Atkreipiame dėmesį, kad čia svarbus operatorių veikimo eiliškumas, kadangi Pauli operatoriai yra tarpusavyje nekomutatyvūs. Normaliuosius operatorius (\\(AA^{\\dagger}=A^{\\dagger}A\\)), kuriems priklauso unitariniai ir ermitiniai operatoriai, galima visada išreikšti vadinamąja spektrine dekompozicija (angl. spectral operator decomposition): \\[\\begin{equation} A = \\sum_k \\lambda_k |k\\rangle\\langle k| = \\sum_k \\lambda_k P_k\\,. \\tag{2.97} \\end{equation}\\] Skaičius \\(\\lambda_k\\) yra operatoriaus \\(A\\) tikrinė vertė, asocijuota su tikriniu vektoriumi \\(|k\\rangle\\). Tikrinių verčių rinkinys \\(\\{\\lambda_k\\}\\) yra operatoriaus \\(A\\) spektras. Čia \\(P_k = |k\\rangle\\langle k|\\) nusako svarbią, vadinamąją projekcinių operatorių (angl. projection operator) klasę. Jie atlieka projekciją į poerdvį, susietą su tikrine verte \\(\\lambda_k\\), kurį dengia su ja susieti tikriniai vektoriai \\(|k\\rangle\\). Tai matome iš išraiškos: \\[\\begin{equation} P_k |v\\rangle = |k\\rangle\\langle k|v\\rangle = \\langle k|v\\rangle |k\\rangle = a|k\\rangle\\,. \\tag{2.98} \\end{equation}\\] Čia \\(a = \\langle k|v\\rangle\\) nusako persiklojimą \\(|v\\rangle\\) vektoriaus išilgai \\(|k\\rangle\\), kitaip tariant – jo projekciją. Jeigu sistemoje nėra \\(|k\\rangle\\) tikrinių vektorių išsigimimo, tada šis poerdvis yra 1 dimensijos, dengiamas \\(|k\\rangle\\) vektoriaus. Kitos projekcinių operatorių savybės yra: \\[\\begin{align} \\sum_k P_k = &amp; I\\,; \\tag{2.99}\\\\ P_i P_j = &amp; P_i \\delta_{ij}\\,. \\tag{2.100} \\end{align}\\] Pirmoji savybė, vadinamoji pilnumo lygtis (angl. completenes equation) teigia, kad susumavę visus vektorių erdvės projekcinius operatorius gausime vienetinį operatorių \\(I\\). Antroji savybė rodo, kad dviejų skirtingų projekcinių operatorių sandauga yra nulinė (\\(i \\neq j\\)), arba lygia pačiam operatoriui (\\(i = j\\)). Taip yra todėl, kad skirtingi \\(P_k\\) atlieka vektorių projekcijas į ortogonaliuosius poerdvius. Verta paminėti, kad unitariniai operatoriai \\(U\\) turi spektrinę dekompoziciją, kurios forma yra: \\[\\begin{equation} U = \\sum_k \\mathrm{e}^{\\mathrm{i}\\varphi_k}|k\\rangle\\langle k|\\,. \\tag{2.101} \\end{equation}\\] Čia \\(\\varphi_k\\) yra realusis skaičius ir, kaip minėta, tikrinės vertės yra fazės faktoriai \\(\\lambda_k = \\mathrm{e}^{\\mathrm{i}\\varphi_k}\\). Matome, kad projekcinių operatorių dekompozicijoje yra tik matricos pagrindinės įstrižainės elementai (diagonalioji matrica). Tokią formą turi viršuje diadomis išreikštas Pauli-\\(Z\\) operatorius, kadangi dekompozijoje buvo naudojami jo tikriniai vektoriai \\(\\big\\{|0\\rangle , |1\\rangle\\big\\}\\). Identiškai atrodytų ir Pauli-\\(X\\) bei \\(Y\\) operatoriai, jeigu operatorių diadinėje dekompozicijoje išreikštume juos su jų tikriniais vektoriais: \\[\\begin{align} X = &amp; |0_x\\rangle\\langle 0_x| - |1_x\\rangle\\langle 1_x|\\,; \\tag{2.102}\\\\ Y = &amp; |0_y\\rangle\\langle 0_y| - |1_y\\rangle\\langle 1_y|\\,. \\tag{2.103} \\end{align}\\] 2.8 Matricos pėdsakas Matricos pėdsakas (angl. trace) yra operacija, kuri sudeda visus matricos pagrindinės įstrižainės elementus \\(a_{mm} = \\langle m|A|m\\rangle\\): \\[\\begin{equation} \\mathrm{Tr}(A) = \\sum_m \\langle m|A|m\\rangle = \\sum_m a_{mm}\\,. \\tag{2.104} \\end{equation}\\] Operatoriaus pėdsakas yra apibrėžtas kaip šio operatoriaus matricos reprezentacijos pėdsakas. Matricos pėdsakas nepriklauso nuo to, su kokiais baziniais vektoriais išreiškiamas operatorius. Įterpdami vienetinį operatorių \\(I = \\sum_i |i\\rangle\\langle i|\\) išreikštą \\(\\big\\{|i\\rangle\\big\\}\\) vektorių bazėje į išraišką viršuje gauname: \\[\\begin{equation} \\begin{aligned} \\mathrm{Tr}(A) = &amp; \\sum_m \\langle m|A|m\\rangle = \\sum_{m,i} \\langle m|i\\rangle\\langle i|A|m\\rangle \\\\ = &amp; \\sum_{m,i} \\langle i|A|m\\rangle\\langle m|i\\rangle = \\sum_i \\langle i|A|i\\rangle\\,. \\end{aligned} \\tag{2.105} \\end{equation}\\] Visi trys Pauli operatoriai \\(X\\), \\(Y\\), \\(Z\\) turi nulinį pėdsaką. Pavyzdžiui: \\[\\begin{align} \\mathrm{Tr}(Y) = &amp; \\mathrm{Tr}\\left( \\begin{bmatrix} 0 &amp; -\\mathrm{i} \\\\ \\mathrm{i} &amp; 0 \\\\ \\end{bmatrix} \\right) = 0 + 0 = 0\\,; \\tag{2.106}\\\\ \\mathrm{Tr}(Z) = &amp; \\mathrm{Tr}\\left( \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; - 1 \\\\ \\end{bmatrix} \\right) = 1 + ( -1) = 0\\,.\\tag{2.107} \\end{align}\\] Matricos pėdsakas turi šias savybes: \\[\\begin{align} \\mathrm{Tr}(A + B) = &amp; \\mathrm{Tr}(A) + \\mathrm{Tr}(B)\\,;\\tag{2.108}\\\\ \\mathrm{Tr}(zA) = &amp; z\\mathrm{Tr}(A)\\,;\\tag{2.109}\\\\ \\mathrm{Tr}(AB) = &amp; \\mathrm{Tr}(BA)\\,.\\tag{2.110} \\end{align}\\] Pirmoje eilutėje užrašyta savybė yra vadinamasis tiesiškumas; antroje eilutėje \\(z\\) – skaičius. Trečia savybė nusako matricos pėdsako cikliškumą. Pavyzdžiui, \\(\\mathrm{Tr}(ABC) = \\mathrm{Tr}(BCA) = \\mathrm{Tr}(CAB)\\). Taip pat galima lengvai patikrinti, kad diados \\(|m\\rangle\\langle n|\\) pėdsakas yra \\(\\mathrm{Tr}\\big(|m\\rangle\\langle n|\\big) = \\langle n|m\\rangle = \\delta_{nm}\\). 2.9 Tenzorinė vektorių sandauga Norint apibūdinti sudėtinę kvantinę sistemą, sudarytą iš daugiau nei vieno kubito, pasitelkdami tenzorinę sandaugą formaliai konstruojame didesnę jų būsenas talpinančią vektorių erdvę. Imkime kaip pavyzdį du kubitus. Kiekvienas iš jų individualiai yra nusakytas identiškose 2 dimensijų kompleksinėse vektorių erdvėse, vadinsime jas \\(V\\) ir \\(U\\). Sistema, sudaryta iš dviejų kubitų, nusakoma erdvėje, kuri yra tenzorinė šių vektorių erdvių sandauga \\(V\\otimes U\\), žymima ženklu \\(\\otimes\\). Šios vektorių erdvės dimensija \\(d\\) yra \\(V\\) ir \\(U\\) dimensijų sandauga, \\(d = 2\\times 2 = 4\\). Bendrai \\(n\\) kubitų erdvė nusakoma \\(n\\) skaičiumi 2 dimensijų sandaugomis, tai yra \\(2^n\\) dimensijų erdvė. \\(V\\otimes U\\) erdvės elementai yra individualių erdvių vektorių tenzorinės sandaugos, \\(|v\\rangle\\otimes|u\\rangle\\), ir jų tiesinės kombinacijos. Galime 2 kubitų vektorius išreikšti tiesinėje algebroje, imkime: \\[\\begin{equation} |v\\rangle = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}\\,,\\quad |u\\rangle = \\begin{bmatrix} c \\\\ d \\\\ \\end{bmatrix}\\,. \\tag{2.111} \\end{equation}\\] Tada jų tenzorinė sandauga \\(|v\\rangle\\otimes|u\\rangle\\) yra: \\[\\begin{equation} |v\\rangle\\otimes|u\\rangle = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}\\otimes\\begin{bmatrix} c \\\\ d \\\\ \\end{bmatrix} = \\begin{bmatrix} a\\begin{bmatrix} c \\\\ d \\\\ \\end{bmatrix} \\\\ b\\begin{bmatrix} c \\\\ d \\\\ \\end{bmatrix} \\end{bmatrix} = \\begin{bmatrix} ac \\\\ ad \\\\ bc \\\\ bd \\\\ \\end{bmatrix}\\,. \\tag{2.112} \\end{equation}\\] Gautas vektorius stulpelis yra sudarytas iš keturių elementų. Naudodami \\(V\\) ir \\(U\\) vektorių erdvių bazinius vektorius galime iš jų suformuoti \\(V\\otimes U\\) erdvę dengiančius bazinius vektorius. Tokia erdvė yra 4 dimensijų, tad turėtume rasti keturis bazinius vektorius. Skaičiuojamasis ortogonalus 2 kubitų rinkinys yra sudarytas iš \\(V\\) ir \\(U\\) erdvių \\(\\big\\{|1\\rangle , |0\\rangle\\big\\}\\) bazinių vektorių tenzorinių sandaugų \\(|0\\rangle\\otimes|0\\rangle\\), \\(|1\\rangle\\otimes|0\\rangle\\), \\(|0\\rangle\\otimes|1\\rangle\\), \\(|1\\rangle\\otimes|1\\rangle\\): \\[\\begin{equation} \\begin{aligned} |0\\rangle\\otimes|0\\rangle = &amp; \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix}\\,,\\quad |1\\rangle\\otimes|0\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix}\\,,\\\\ |0\\rangle\\otimes|1\\rangle = &amp; \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix}\\,,\\quad |1\\rangle\\otimes|1\\rangle = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}\\,. \\end{aligned} \\tag{2.113} \\end{equation}\\] Skaičiuojamasis \\(n\\) kubitų bazinių vektorių rinkinys analogiškai bus sudarytas iš visų skirtingų \\(2^n\\) tenzorinių 1 kubito bazinių vektorių sandaugų kombinacijų. Kiekvienas toks vektorius stulpelis turės \\(2^n\\) elementų, kuriame vienas iš elementų bus 1, o visi likusieji \\(n - 1\\) elementai 0. Kai nėra rizikos suklaidinti skaitytoją, stengsimės supaprastinti vektorių simboliką praleisdami \\(\\otimes\\) ir sujungdami tenzorinę vektoriaus išraišką į vieną skaičių eilutę. Pavyzdžiui, 2 kubitų bazinių vektorių rinkinys identiškai rašomas \\(\\big\\{|00\\rangle , |10\\rangle , |01\\rangle, |11\\rangle\\big\\}\\). Literatūroje taip pat galima sutikti naudojamą tenzorinės vektorių sandaugos žymėjimą su praleistu tenzoriaus ženklu, pavyzdžiui, \\(|\\psi\\rangle|\\varphi\\rangle = |\\psi\\rangle\\otimes |\\varphi\\rangle\\). Šioje knygoje vartojame tik du būdus – įterpdami \\(\\otimes\\) tarp vektorių arba sujungdami juos vienu vektoriaus simboliu. Pateikiame pagrindines aritmetines operacijas su vektoriais išreikštais tenzorinėmis sandaugomis. Sandauga su skaičiumi: \\[\\begin{equation} z\\big(|\\psi\\rangle\\otimes|\\phi\\rangle\\big) = \\big(z|\\psi\\rangle\\big)\\otimes|\\phi\\rangle = |\\psi\\rangle\\otimes\\big(z|\\phi\\rangle\\big)\\,. \\tag{2.114} \\end{equation}\\] Tenzorinė dviejų vektorių sandauga, kai vienas vektorius yra išreikštas kitų dviejų sudėtimi (superpozicijoje): \\[\\begin{equation} \\big(|\\psi\\rangle + |u\\rangle\\big)\\otimes |\\phi\\rangle = |\\psi\\rangle\\otimes|\\phi\\rangle + |u\\rangle\\otimes|\\phi\\rangle\\,. \\tag{2.115} \\end{equation}\\] Dualusis tenzorinis vektorius (bra) yra formuojamas taip: \\[\\begin{equation} \\big(|\\psi\\rangle\\otimes|\\phi\\rangle\\big)^{\\dagger} = \\langle\\psi|\\otimes \\langle\\phi|\\,. \\tag{2.116} \\end{equation}\\] Naudojame susitarimą, kuriame išlaikomas simbolių \\((\\phi, \\psi, u\\ldots)\\) eiliškumas ir tik pakeičiama skliaustelių forma iš ket į bra. Atliekant įvairias operacijas yra svarbu sekti, kuriai vektorių erdvei priskirtas posistemės vektorius tenzorinėje sandaugoje. Mat vidinė vektorių sandauga yra apibrėžta tik tarp tos pačios vektorių erdvės elementų. Imkime dvi tenzorines dviejų kubitų būsenas \\(|\\psi\\rangle\\otimes|\\phi\\rangle\\) ir \\(|v\\rangle\\otimes|u\\rangle\\), kai \\(|\\psi\\rangle , |v\\rangle \\in V\\) bei \\(|\\phi\\rangle , |u\\rangle \\in U\\). Vidinė sandauga atliekama tarp vektorių, priklausančių tai pačiai posistemei: \\[\\begin{equation} \\big(\\langle u|\\otimes\\langle\\omega|\\big)\\big(|\\psi\\rangle\\otimes|\\phi\\rangle\\big) = \\langle u|\\psi\\rangle\\langle\\omega |\\phi\\rangle\\,. \\tag{2.117} \\end{equation}\\] Rezultatas bus vėlgi bendrai kompleksinis skaičius, kuris yra dviejų skaičių sandauga \\(\\langle u|\\psi\\rangle\\langle\\omega|\\phi\\rangle = cz\\), gauta iš šių dviejų vidinių sandaugų: \\(\\langle u|\\psi\\rangle = c\\), \\(\\langle\\omega |\\phi\\rangle = z\\). 2.10 Tenzorinė operatorių sandauga Operatoriai, gauti iš 1 kubito operatorių tenzorinių sandaugų, formaliai leidžia apibūdinti didesnės kubitų sistemos transformacijas. Dviejų 1 kubito operatorių tenzorinę sandaugą \\(A\\otimes B\\), veikiančią \\(V\\otimes U\\) vektorių erdvėje, galime išreikšti matricos forma taip: \\[\\begin{equation} A\\otimes B = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\\\ \\end{bmatrix}\\otimes\\begin{bmatrix} e &amp; f \\\\ g &amp; h \\\\ \\end{bmatrix} = \\begin{bmatrix} aB &amp; bB \\\\ cB &amp; dB \\\\ \\end{bmatrix} = \\begin{bmatrix} \\begin{matrix} ae &amp; af \\\\ ag &amp; ah \\\\ \\end{matrix} &amp; \\begin{matrix} be &amp; bf \\\\ bg &amp; bh \\\\ \\end{matrix} \\\\ \\begin{matrix} ce &amp; cf \\\\ cg &amp; ch \\\\ \\end{matrix} &amp; \\begin{matrix} de &amp; df \\\\ dg &amp; dh \\\\ \\end{matrix} \\\\ \\end{bmatrix}\\,. \\tag{2.118} \\end{equation}\\] Atkreipiame dėmesį į blokinę struktūrą bei \\((4\\times 4)\\) matricos dydį. Tokio matricos dydžio ir tikimės iš operatoriaus, veikiančio 4 dimensijų erdvėje, nusakančioje dviejų kubitų būsenas. Iš unitariųjų operatorių \\(A\\) ir \\(B\\) sukonstruotas operatorius \\(A\\otimes B\\) yra taip pat unitarusis. Tai galima parodyti formaliai prisimenant, kad unitariojo operatoriaus ir jo ermitinės jungties sandauga yra vienetinis operatorius: \\[\\begin{equation} (A\\otimes B)(A\\otimes B)^{\\dagger} = (A\\otimes B)(A^{\\dagger}\\otimes B^{\\dagger}) = AA^{\\dagger}\\otimes BB^{\\dagger} = I\\otimes I = I\\,. \\tag{2.119} \\end{equation}\\] Kitos operatorių, išreikštų tenzorinėmis sandaugomis, savybės: \\[\\begin{align} A\\otimes(B + C) = &amp; A\\otimes B + A\\otimes C\\,;\\tag{2.120}\\\\ (A\\otimes B)(C\\otimes D) = &amp; (AC\\otimes BD)\\,;\\tag{2.121}\\\\ \\mathrm{Tr}(A\\otimes B) = &amp; \\mathrm{Tr}(A)\\mathrm{Tr}(B)\\,.\\tag{2.122} \\end{align}\\] Iliustruodami tenzorinės operatorių sandaugos naudojimą, imkime dviejų kubitų sistemą, kuriai atliekama pirmam kubitui Pauli-\\(X\\), o antram Pauli-\\(Z\\) transformacijos: \\[\\begin{equation} X\\otimes Z\\big(|v\\rangle\\otimes|u\\rangle\\big) = X|v\\rangle\\otimes Z|u\\rangle\\,. \\tag{2.123} \\end{equation}\\] Tai yra tiesinis operatorius, o \\(X\\) ir \\(Z\\) veikia atitinkamo kubito vektorių erdvėje. Šią operaciją galime perteikti ir naudodami tiesinę algebrą: \\[\\begin{equation} \\begin{aligned} X\\otimes Z\\big(|0\\rangle\\otimes|1\\rangle\\big) = &amp; \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}\\begin{bmatrix} 1 \\\\ 0 \\\\ \\end{bmatrix}\\otimes\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\\\ \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix}\\otimes\\begin{bmatrix} 0 \\\\ -1 \\\\ \\end{bmatrix} \\\\ = &amp; \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ -1 \\\\ \\end{bmatrix}\\,. \\end{aligned} \\tag{2.124} \\end{equation}\\] Arba, pirmiau išskleidę tenzorines sandaugas, randame tą patį: \\[\\begin{equation} \\begin{aligned} X\\otimes Z\\big(|0\\rangle\\otimes|1\\rangle\\big) = &amp; \\begin{bmatrix} 0 \\cdot Z &amp; 1 \\cdot Z \\\\ 1 \\cdot Z &amp; 0 \\cdot Z \\\\ \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -1 &amp; 0 &amp; 0 \\end{bmatrix}\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix} \\\\ = &amp; \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ -1 \\\\ \\end{bmatrix}\\,. \\end{aligned} \\tag{2.125} \\end{equation}\\] Galime parodyti, kad operatorių \\(A\\otimes B\\), veikiančių \\(V\\otimes U\\) erdvėje, tikrinės vertės yra individualių operatorių \\(A\\) ir \\(B\\) tikrinių verčių sandaugos. Imkime \\(A|k\\rangle = \\lambda_k |k\\rangle\\) ir \\(B|l\\rangle = \\lambda_l |l\\rangle\\), kai \\(\\lambda_k\\) ir \\(\\lambda_l\\) yra atitinkamų operatorių tikrinės vertės, asocijuotos su jų tikriniais vektoriais \\(|k\\rangle\\) bei \\(|l\\rangle\\). Tada: \\[\\begin{equation} (A\\otimes B)\\big(|k\\rangle\\otimes |l\\rangle\\big) = A|k\\rangle\\otimes B|l\\rangle = \\lambda_k |k\\rangle\\otimes\\lambda_l |l\\rangle = \\lambda_k\\lambda_l \\big(|k\\rangle\\otimes |l\\rangle\\big)\\,. \\tag{2.126} \\end{equation}\\] Matome, kad \\(A\\otimes B\\) operatoriaus tikriniai vektoriai yra \\(\\big\\{|k\\rangle\\otimes |l\\rangle\\big\\}\\) vektorių rinkinys, o tikrinės vertės \\(\\{\\lambda_k \\lambda_l\\}\\). Jeigu \\(A\\) yra \\((n\\times n)\\) matrica, o \\(B\\) \\((p\\times p)\\), kai \\(n\\) ir \\(p\\) gali būti vienodi arba skirtingi, tada egzistuoja \\(np\\)-skaičius tikrinių vektorių ir \\(\\big\\{|k\\rangle\\otimes |l\\rangle\\big\\}\\) rinkinys pateikia juos visus. Šie vektoriai yra tarpusavyje ortogonalūs: \\[\\begin{equation} \\big(\\langle k&#39;|\\otimes\\langle l&#39;|\\big)\\big(|k\\rangle\\otimes|l \\rangle\\big) = \\langle k&#39;|k\\rangle\\langle l&#39;|l\\rangle = \\delta_{k&#39;k}\\delta_{l&#39;l}\\,. \\tag{2.127} \\end{equation}\\] Ir todėl gali būti naudojami kaip bazinių vektorių rinkinys. Toliau imkime normalųjį operatorių \\(A\\), išreikštą spektrine dekompozicija: \\[\\begin{equation} A = \\sum_k \\lambda_k |k\\rangle\\langle k| = \\sum_k \\lambda_k P_k\\,. \\tag{2.128} \\end{equation}\\] Tenzorinė dviejų normaliųjų operatorių sandauga \\(A\\otimes B\\) taip pat gali būti išreiškiama naudojant šių dviejų operatorių projekcinius operatorius: \\[\\begin{equation} \\begin{aligned} A\\otimes B = &amp; \\sum_k \\lambda_k |k\\rangle\\langle k|\\otimes \\sum_l \\lambda_l |l\\rangle\\langle l| = \\sum_{k,l} \\lambda_k \\lambda_l |k\\rangle\\langle k|\\otimes |l\\rangle\\langle l| \\\\ \\equiv &amp; \\sum_m \\lambda_m |m\\rangle\\langle m|\\,. \\end{aligned} \\tag{2.129} \\end{equation}\\] Tai nusako diagonaliąją matricą, o \\(\\big\\{|kl\\rangle \\equiv |k\\rangle\\otimes |l\\rangle \\equiv |m\\rangle\\big\\}\\) yra bazinių vektorių rinkinys, dengiantis \\(V\\otimes U\\) erdvę. Čia \\(A\\otimes B\\) operatoriaus tikrinės vertės, asocijuotos su tikriniais vektoriais \\(\\big\\{|m\\rangle\\big\\}\\), yra \\(A\\) ir \\(B\\) operatorių tikrinių verčių sandaugos, \\(\\lambda_m = \\lambda_k \\lambda_l\\). Pavyzdžiui, Pauli-\\(Z\\) operatorių tenzorinė sandauga taikant spektrinę dekompoziciją išreiškiama: \\[\\begin{equation} \\begin{aligned} Z\\otimes Z = &amp; |0\\rangle\\langle 0|\\otimes |0\\rangle\\langle 0| - |1\\rangle\\langle 1|\\otimes |0\\rangle\\langle 0| - |0\\rangle\\langle 0|\\otimes |1\\rangle\\langle 1| + |1\\rangle\\langle 1|\\otimes |1\\rangle\\langle 1| \\\\ = &amp; |00\\rangle\\langle 00| - |10\\rangle\\langle 10| - |01\\rangle\\langle 01| + |11\\rangle\\langle 11| \\\\ = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\,. \\end{aligned} \\tag{2.130} \\end{equation}\\] Matome, kad yra tik dvi skirtingos operatoriaus \\(Z\\otimes Z\\) tikrinės vertės, \\(\\lambda_k \\lambda_l \\in (1, -1)\\), ir keturi tikriniai vektoriai, \\(|0\\rangle\\otimes |0\\rangle\\), \\(|1\\rangle\\otimes |0\\rangle\\), \\(|0\\rangle\\otimes |1\\rangle\\), \\(|1\\rangle\\otimes |1\\rangle\\). Tad su šiomis tikrinėmis vertėmis susieti poerdviai yra dvigubai išsigimę. Kvantinėje kompiuterijoje dažnai aptinkami operatoriai, kurie vienu metu keičia tik vieno kubito būseną. Pavyzdžiui, operatorius trečiam kubitui 4 kubitų registre, atliekantis Pauli-\\(Y\\) vartus, nekeičiant kitų, yra išreiškiamas \\(I\\otimes I\\otimes Y\\otimes I\\). Operatoriai, turintys formą \\(A\\otimes B\\otimes C\\otimes D\\cdots\\), yra vadinami lokaliaisiais, kadangi jie atlieka operacijas su atskirais kubitais nepriklausomai nuo kitų kubitų būsenos. Bendresnio pobūdžio, vadinamosios nelokaliosios transformacijos, yra nusakomos lokaliųjų operatorių sumomis, pavyzdžiui, veikiančios du kubitus \\(A\\otimes B + C\\otimes D\\). 2.11 Operatorių funkcijos Kvantinėje kompiuterijoje dažnai sutinkamos transformacijos, nusakomos matricų funkcijomis. Kitaip nei įprastinės funkcijos, kurių reikšmės bei vertės yra skaičiai, matricų funkcijų reikšmės bei vertės yra matricos. Laimei, kvantinėje kompiuterijoje visos matricos, naudojamos atlikti būsenų transformacijoms, priklauso normaliųjų operatorių klasei. Šiuos operatorius galime perteikti spektrine dekompozicija: \\[\\begin{equation} A = \\sum_k \\lambda_k |k \\rangle\\langle k| = \\sum_k \\lambda_k P_k\\,. \\tag{2.131} \\end{equation}\\] Analitinės normaliųjų operatorių funkcijos \\(f(A)\\) tada randamos paprasta žinoma formule: \\[\\begin{equation} f(A) = \\sum_k f(\\lambda_k)P_k\\,. \\tag{2.132} \\end{equation}\\] Operatoriaus funkcija \\(f\\) yra įvertinama imant operatoriaus \\(A\\) tikrines vertes \\(\\lambda_k\\), kaip jos reikšmes, kurios daugina atitinkamus projekcinius operatorius \\(P_k\\). Pavyzdžiui, dažnai algoritmuose aptinkama ermitinio operatoriaus \\(A\\) eksponentė, \\(f(\\alpha A) = \\mathrm{e}^{\\mathrm{i}\\alpha A}\\), kai \\(\\alpha\\) – realusis skaičius: \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\alpha A} = \\sum_k \\mathrm{e}^{\\mathrm{i}\\alpha\\lambda_k}P_k\\,. \\tag{2.133} \\end{equation}\\] Šiuo principu galime rasti, pavyzdžiui, Pauli-\\(Z\\) operatoriaus (\\(\\lambda_0 = 1\\), \\(\\lambda_1 = -1\\)) eksponentę \\(f(\\alpha A) = \\mathrm{e}^{\\mathrm{i}\\alpha Z}\\): \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\alpha Z} = \\mathrm{e}^{\\mathrm{i}\\alpha}|0\\rangle\\langle 0| + \\mathrm{e}^{-\\mathrm{i}\\alpha}|1\\rangle\\langle 1| = \\begin{bmatrix} \\mathrm{e}^{\\mathrm{i}\\alpha} &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\alpha} \\\\ \\end{bmatrix}\\,. \\tag{2.134} \\end{equation}\\] Kitas būdas rasti matricos eksponentę yra taikant Teiloro eilutę (angl. Taylor series): \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\alpha Z} = \\sum_{j = 0}^{\\infty} \\frac{(\\mathrm{i}\\alpha Z)^j}{j!}\\,. \\tag{2.135} \\end{equation}\\] Atkreipiame dėmesį, kad Pauli operatoriai pasižymi savybe \\(Z^j = Z\\), kai \\(j\\) – nelyginis skaičius, ir \\(Z^j = I\\), kai \\(j\\) – lyginis skaičius. Sugrupavę lyginius bei nelyginius narius ir panaudodami kosinusų bei sinusų Teiloro eilutes randame: \\[\\begin{equation} \\begin{aligned} \\mathrm{e}^{\\mathrm{i}\\alpha Z} = &amp; \\left( I - \\frac{\\alpha^{2}I}{2!} + \\frac{\\alpha^{4}I}{4!} - \\cdots \\right) + \\left( \\mathrm{i}\\alpha Z - \\frac{\\mathrm{i}\\alpha^{3}Z}{3!} + \\frac{\\mathrm{i}\\alpha^{5}Z}{5!} - \\cdots \\right) \\\\ = &amp; \\cos(\\alpha)I + \\mathrm{i}\\sin(a)Z\\,. \\end{aligned} \\tag{2.136} \\end{equation}\\] Perteikdami \\(I\\) ir \\(Z\\) matricų forma bei taikydami Oilerio formulę prieiname prie tos pačios išraiškos: \\[\\begin{equation} \\begin{aligned} \\cos(\\alpha)I + \\mathrm{i}\\sin(a)Z = &amp; \\begin{bmatrix} \\cos(\\alpha) + \\mathrm{i}\\sin(a) &amp; 0 \\\\ 0 &amp; \\cos(\\alpha) - \\mathrm{i}\\sin(a) \\\\ \\end{bmatrix} \\\\ = &amp; \\begin{bmatrix} \\mathrm{e}^{\\mathrm{i}\\alpha} &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\alpha} \\\\ \\end{bmatrix}\\,. \\end{aligned} \\tag{2.137} \\end{equation}\\] Taikydami spektrinę dekompoziciją galime taip pat rasti ir normaliųjų operatorių tenzorinės sandaugos funkcijas. Jos turi turi identiškas formas, pavyzdžiui, dviejų operatorių \\(A\\otimes B\\) funkcija: \\[\\begin{equation} f(A\\otimes B) = \\sum_{k,l} f(\\lambda_k \\lambda_l )P_k \\otimes P_l\\,. \\tag{2.138} \\end{equation}\\] Funkcijos \\(f\\) argumentai yra \\(P_k\\) ir \\(P_l\\) operatorius atitinkančių tikrinių verčių sandaugos \\(\\lambda_k \\lambda_l\\). Imkime Pauli-\\(Z\\) operatorių eksponentę \\(f(A\\otimes B) = \\mathrm{e}^{\\mathrm{i}\\alpha Z\\otimes Z}\\): \\[\\begin{equation} \\begin{aligned} \\mathrm{e}^{\\mathrm{i}\\alpha Z\\otimes Z} = &amp; \\mathrm{e}^{\\mathrm{i}\\alpha}|0\\rangle\\langle 0|\\otimes |0\\rangle\\langle 0| + \\mathrm{e}^{-\\mathrm{i}\\alpha}|1\\rangle\\langle 1|\\otimes |0\\rangle\\langle 0| \\\\ &amp; + \\mathrm{e}^{-\\mathrm{i}\\alpha}|0\\rangle\\langle 0|\\otimes |1\\rangle\\langle 1| + \\mathrm{e}^{\\mathrm{i}\\alpha}|1\\rangle\\langle 1|\\otimes |1\\rangle\\langle 1| \\\\ = &amp; \\begin{bmatrix} \\mathrm{e}^{\\mathrm{i}\\alpha} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\alpha} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\alpha} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}\\alpha} \\end{bmatrix}\\,. \\end{aligned} \\tag{2.139} \\end{equation}\\] "],["kvantines-mechanikos-pagrindai.html", "3 skyrius. Kvantinės mechanikos pagrindai 3.1 Kvantinės mechanikos postulatai 3.2 Kvantinis supynimas 3.3 Tankio operatorius 3.4 EPR paradoksas", " 3 skyrius. Kvantinės mechanikos pagrindai Kvantinė mechanika yra šiuo metu bendriausia fizikinė teorija ir iš principo pritaikoma nuo subatominio lygio iki kasdieninių daiktų skalės. Siekiant paaiškinti kvantinius reiškinius ši teorija buvo suformuluota naudojant tiesinės algebros matematinę struktūrą, kurios elementus pristatėme ankstesniame skyriuje. Šiame skyriuje pateikiame kvantinės mechanikos postulatus. Postulatai yra taikomi siekiant sujungti abstraktų šios teorijos matematinį formalizmą su stebimu fiziniu pasauliu ir suteikia pagrindines taisykles, kuriomis remiantis perteikiami skaičiavimai kvantiniame kompiuteryje. 3.1 Kvantinės mechanikos postulatai I postulatas – kvantinės būsenos. Uždaros kvantinės sistemos būsena yra visiškai nusakoma normuotuoju vektoriumi \\(|\\psi\\rangle\\) Hilberto vektorių erdvėje. Kvantinė būsena, aprašyta \\(|\\psi\\rangle\\) vektoriumi, atspindi visą informaciją, kurią galima sužinoti apie kvantinę sistemą. Hilberto erdvė \\((\\mathcal{H})\\) – tai kompleksinių vektorių erdvė su matematiškai apibrėžta vidine sandauga \\(\\langle\\psi|\\psi\\rangle\\). Reikalavimas, kad vektorius \\(|\\psi\\rangle\\) būtų normuotasis, išreiškiamas \\(\\langle\\psi|\\psi\\rangle = 1\\). Kiekvienai fizinei sistemai priskiriame atskirą \\(\\mathcal{H}\\) erdvę, kurioje galime aprašyti jos visas būsenas. Kvantinė mechanika nenurodo, kokia yra specifinės kvantinės sistemos Hilberto erdvė, tai bendrai gali būti nelengva užduotis sudėtingose sistemose. Tačiau kubito \\(\\mathcal{H}\\) erdvė yra viena iš paprasčiausių: tai 2 dimensijų kompleksinė vektorių erdvė. Jeigu \\(|\\psi\\rangle\\), \\(|\\phi\\rangle\\) yra du vektoriai, priklausantys tai pačiai \\(\\mathcal{H}\\) erdvei, tada \\(|u\\rangle = a|\\psi\\rangle + b|\\phi\\rangle\\) yra kita galima tos pačios sistemos būsena, vadinamoji superpozicija. Būsenų normuotumas naudojant amplitudes išreiškiamas \\(\\langle u|u\\rangle = |a|^2 + |b|^2 + 2\\mathrm{Re}(a^{*}b\\langle\\psi|\\phi\\rangle) = 1\\). Jeigu \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\) yra ortogonalieji vektoriai, tada trečiasis narys, nusakantis interferenciją tarp būsenų \\(2\\mathrm{Re}(a^{*}b\\langle\\psi |\\phi\\rangle) = 0\\), iškrenta iš lygybės ir randame \\(\\langle u|u\\rangle = |a|^2 + |b|^2\\). Pirmąjį postulatą galima matematiškai tiksliau perfrazuoti sakant, kad kvantinės būsenos yra nusakomos spinduliu. Spindulys čia reiškia klasę vektorių, kurie vienas nuo kito skiriasi tik globalia faze \\(\\mathrm{e}^{\\mathrm{i}\\theta}\\). Kadangi globali fazė nėra stebima matavimuose, visos kvantinės būsenos, besiskiriančios tik fazės nariu, yra tarpusavyje ekvivalenčios. Pavyzdžiui, vektoriai \\(|\\psi\\rangle\\) ir \\(\\mathrm{e}^{\\mathrm{i}\\theta}|\\psi\\rangle\\) nusako identišką būseną. Matome, kad dėl kompleksinės jungties naudojimo vidinėje sandaugoje globalios fazės narys pradingsta: \\[\\begin{equation} \\langle\\psi |\\mathrm{e}^{-\\mathrm{i}\\theta}\\mathrm{e}^{\\mathrm{i}\\theta}|\\psi\\rangle = \\mathrm{e}^{0}\\langle\\psi |\\psi\\rangle = 1\\,. \\tag{3.1} \\end{equation}\\] Atitinkamai ir matavimų metu jis nėra stebimas. Tačiau svarbu pabrėžti skirtumą tarp globalios ir santykinės fazės. Santykinė fazė yra fiziškai svarbi ir jos įtaka stebima matavimų rezultatuose. Matematiškai, globali fazė superpozicijos būsenoje daugina abu narius kartu, pavyzdžiui, \\(|\\psi\\rangle = \\mathrm{e}^{\\mathrm{i}\\theta}\\big(a|0\\rangle + b|1\\rangle\\big)\\). O štai santykinė fazė atrodytų bendrai taip: \\(|\\psi\\rangle = a|0\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta}b|1\\rangle\\). Kaip pavyzdį imkime Pauli-\\(X\\) bazinių vektorių būsenas \\(|0_x\\rangle\\) ir \\(|1_x\\rangle\\), kurios nusako \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijas bei skiriasi santykine faze: \\[\\begin{equation} |0_x\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\,,\\quad |1_x\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\,. \\tag{3.2} \\end{equation}\\] Akivaizdu, kad šios dvi būsenos yra skirtingos, o tiksliau – ortogonalios, nes \\(\\langle 0_x |1_x \\rangle = 0\\). II(a) postulatas – būsenų evoliucija laike. Kvantinės sistemos, izoliuotos nuo išorinių sąveikų, evoliucija laike yra nusakoma unitarine transformacija. Sistemos būsena \\(|\\psi(t_0)\\rangle\\) laiku \\(t_0\\) yra susiejama su būsena \\(|\\psi(t_1)\\rangle\\) vėlesniu laiku \\(t_1\\) unitarine transformacija \\(U(t_0, t_1)\\): \\[\\begin{equation} |\\psi(t_1)\\rangle = U(t_0, t_1)|\\psi(t_0)\\rangle\\,. \\tag{3.3} \\end{equation}\\] Antrasis postulatas nusako, kad žinant pradinę uždaros sistemos būseną laiku \\(t_0\\), galima tiksliai ir unikaliai pasakyti, kokia bus sistemos būsena laiku \\(t_1\\), \\(|\\psi(t_1)\\rangle\\). Matematiškai tai yra sandauga tarp unitariojo operatoriaus \\(U(t_0, t_1)\\), nulemiančio laiko evoliuciją, ir būseną laiku \\(t_0\\) nusakančio vektoriaus \\(|\\psi(t_0)\\rangle\\). Kitaip tariant, uždarų kvantinių sistemų, kaip ir klasikinių, evoliucija laike yra deterministinė. Unitarinėse evoliucijose nėra tikimybėmis nusakomų būsenų kitimų. Toliau pateikiame antrojo postulato versiją, naudojančią Šriodingerio lygtį (angl. Schrödinger equation), kuri yra labiau tinkama apibūdinti fizikinėms sąveikoms. II(b) postulatas – Uždaros kvantinės sistemos būsena laike yra nusakoma Šriodingerio lygtimi: \\[\\begin{equation} \\mathrm{i}\\hbar\\frac{d|\\psi(t)\\rangle}{dt} = H|\\psi(t)\\rangle\\,. \\tag{3.4} \\end{equation}\\] Šriodingerio diferencialinėje lygtyje \\(\\hbar\\) yra Planko konstanta, \\(\\mathrm{i}\\) – menamasis vienetas, \\(H\\) – uždaros sistemos hamiltonianas (deja, čia vartojame tą pačia raidę, kaip ir Hadamardo transformacijai). Hamiltonianas – ermitinis operatorius, kurio tikrinės vertės yra sistemos energijos lygmenys. Pavyzdžiui, jeigu \\(|k\\rangle\\) yra \\(H\\) operatoriaus tikrinis vektorius, tada yra tenkinama lygybė \\(H|k\\rangle = \\lambda_k|k\\rangle\\), kurioje tikrinė vertė \\(\\lambda_k\\) nusako būsenos \\(|k\\rangle\\) energiją. Sąryšis tarp antrojo postulato dviejų versijų slypi Šriodingerio lygties integracijoje laiko intervale nuo \\(t_0\\) iki \\(t_1\\). Neprarasdami bendrumo darome prielaidą, kad šiuo laiko intervalu hamiltonianas nekinta. Tada, atlikę integraciją laike, gauname: \\[\\begin{equation} |\\psi(t_1)\\rangle = \\mathrm{e}^{-\\frac{\\mathrm{i}H(t_1 - t_0)}{\\hbar}} |\\psi(t_0)\\rangle\\,. \\tag{3.5} \\end{equation}\\] Palyginę su unitarinės evoliucijos laike forma, matome jos bendrą išraišką: \\[\\begin{equation} U(t_0, t_1) = \\mathrm{e}^{-\\frac{\\mathrm{i}H(t_1 - t_0)}{\\hbar}}\\,. \\tag{3.6} \\end{equation}\\] Kadangi hamiltonianas yra ermitinis operatorius, ši operatoriaus eksponentė nusako unitarųjį operatorių. Kvantiniame kompiuteryje be išorinių sąveikų kubito bendra būsena \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\) laike nekinta, tad \\(U(t) = I\\) efektyviai nusako vienetinį operatorių. Kvantiniai loginiai vartai fiziniame lygmenyje yra laike atliekama kubito būsenos transformacija. Hamiltonianas tuo laiko intervalu yra „įjungiamas” pridedant sąveikas, nusakančius narius, vadinamąsias sistemos perturbacijas. Algoritmas nusako seką sistemos perturbacijų, trunkančių tam tikrus laiko intervalus \\(\\Delta t\\). Pavyzdžiui, laiko intervale \\(\\Delta t= t_1 - t_0\\) gali būti atliekama kubito sąveika su elektromagnetinio lauko pulsu, toliau gali sekti kitas pulsas, taip atliekant seką skirtingų unitarinių transformacijų \\(\\cdots U(t_1, t_2 )U(t_0, t_1 )|\\psi(t_0)\\rangle\\). Analizuojant algoritmus loginiu lygmeniu laiko kintamųjų (svarbių fiziniame lygmenyje) neberašome, kadangi \\(U(t)\\) yra perteikiamas jo suminį efektą baziniams vektoriams išreiškiančiu efektyviu unitariniu operatoriumi \\(U(t) \\rightarrow U\\). Be loginius vartus nusakančių sąveikų kvantiniame kompiuteryje galima išskirti dar dviejų tipų sąveikas, kuriose sistema traktuojama kaip nebeuždara. Pirmasis tipas – tai nepageidaujamos ir nekontroliuojamos sąveikos su išorinėmis kvantinėmis sistemomis. Jos įveda nežinomas unitarines transformacijas ir nenuspėjamai paveikia kubitų būsenas. Vienintelė tikra uždara kvantinė sistema yra (veikiausiai) pati visata. Kai sakoma, kad kubitai apibūdina uždaras kvantines sistemas, turima omenyje, kad išorinės sąveikos yra itin retos ir todėl galima gerai aproksimuoti jas esant uždaras. Antrojo tipo sąveika yra su makroskopiniais įrenginiais, naudojamais pamatuoti kvantinei būsenai. Pastaruoju atveju sistemos evoliucijos laike negalime nusakyti taikydami antrąjį postulatą (net ir išplėtus tai, ką vadiname uždara sistema), nes jos dinamika tampa nedeterministinė. Trečiasis postulatas nusako, kaip kvantinė sistema keičiasi atlikus jos būsenos matavimą. III postulatas – fizikinių dydžių matavimai. Kiekvienam stebimam kvantinės sistemos fizikiniam dydžiui egzistuoja ermitinis operatorius \\(P\\), veikiantis tos sistemos Hilberto erdvėje. Atlikus fizikinio dydžio matavimą galimi rezultatai yra viena iš \\(P\\) operatoriaus tikrinių verčių \\(\\lambda_k\\). Tikimybė \\(p(\\lambda_k)\\) gauti \\(\\lambda_k\\) pamatavus sistemą esančią būsenoje \\(|\\psi\\rangle\\) randama \\(p(\\lambda_k) = \\langle\\psi|P_k |\\psi\\rangle = \\big|\\langle k |\\psi\\rangle\\big|^2\\); čia \\(P_k\\) yra projekcinis operatorius \\(P_k = |k\\rangle\\langle k|\\). Kvantinės sistemos būsena iš karto po matavimo yra \\(P\\) operatoriaus tikrinis vektorius \\(|k\\rangle\\), susietas su rasta tikrine verte \\(\\lambda_k\\). Šiame postulate nurodomas būdas apskaičiuoti tikimybes yra dar žinomas kvantinėje mechanikoje kaip Borno taisyklė (angl. Born rule). Kvantinė mechanika nepasako, kokie ermitiniai operatoriai susieti su fizikiniais dydžiais. Analizuojant fizinės sistemos savybes ir matavimo konfigūraciją vis dėlto galima tokius operatorius aprašyti. Selektyvus matavimas, naudojantis projekcinius operatorius, yra dažniausiai aptinkamas būsenų matavimo būdas kvantinėje kompiuterijoje. Kaip minėjome antrame skyriuje, ermitinis operatorius gali būti išreikštas spektrine dekompozicija: \\[\\begin{equation} P = \\sum_k \\lambda_k P_k\\,. \\tag{3.7} \\end{equation}\\] Projekcinis operatorius \\(P_k\\) atlieka vektoriaus projekciją į ortogonalų poerdvį, asocijuotą su tikrine verte \\(\\lambda_k\\). Kubito būsenos \\(|\\psi\\rangle\\) selektyvusis matavimas pasitelkiant \\(P_k\\) nusako tikimybę gauti būtent \\(\\lambda_k\\) rezultatą. Būseną po \\(P_k\\) projekcinio matavimo, vadinsime ją bendrai \\(|\\varphi\\rangle\\), galima formaliai rasti: \\[\\begin{equation} |\\varphi\\rangle = \\frac{P_k|\\psi\\rangle}{\\sqrt{\\langle\\psi |P|\\psi\\rangle}} = \\frac{|k\\rangle\\langle k|\\psi\\rangle}{\\sqrt{p(\\lambda_k)}} = \\frac{a_k |k\\rangle}{\\sqrt{p(\\lambda_k)}}\\,. \\tag{3.8} \\end{equation}\\] Skaitiklyje, \\(P_k|\\psi\\rangle\\) atlieka \\(|\\psi\\rangle\\) būsenos projekciją į \\(|k\\rangle\\) vektoriaus poerdvį, o vidinė sandauga \\(\\langle k|\\psi\\rangle= a_k\\) nusako šių vektorių persiklojimą. Vardiklyje esantis narys, \\(\\sqrt{p(\\lambda_k)} = \\sqrt{|a_k|^2} = |a_k|\\), atlieka užduotį sunormuoti vektorių \\(a_k|k\\rangle\\). Dažniausiai susidursime su projekciniais matavimais į ortogonalias kubitų \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenų poerdvius (1 dimensijos poerdviai), susietus su tikrinėmis vertėmis \\(\\lambda_0 = 1\\) ir \\(\\lambda_1 = -1\\), atitinkamai. Tai atlieka Pauli-\\(Z\\) operatorius, kurį galima išreikšti: \\[\\begin{equation} Z = \\sum_k \\lambda_k P_k = \\lambda_0 |0\\rangle\\langle 0| + \\lambda_1 |1\\rangle\\langle 1| = |0\\rangle\\langle 0| - |1\\rangle\\langle 1|\\,. \\tag{3.9} \\end{equation}\\] Projekcinį matavimą, naudojant Pauli-\\(Z\\), čia vadinsime pakaitomis „standartiniu”, „Pauli-\\(Z\\) operatoriaus matavimu”, arba „matavimu vektorių \\(\\big\\{|0\\rangle, |1\\rangle\\big\\}\\) bazėje”. Be Pauli-\\(Z\\) taip pat kvantinių ryšių protokoluose galima aptikti Pauli-\\(X\\) operatoriaus matavimą. Projekciniais operatoriais jį išreiškiame: \\[\\begin{equation} X = \\sum_k \\lambda_k P_k = \\lambda_0|0_x\\rangle\\langle 0_x| + \\lambda_1 |1_x\\rangle\\langle 1_x| = |0_x \\rangle\\langle 0_x| - |0_x \\rangle\\langle 0_x|\\,. \\tag{3.10} \\end{equation}\\] Čia \\(\\big\\{|0_x \\rangle, |1_x \\rangle\\big\\}\\) yra Pauli-\\(X\\) tikriniai vektoriai, į kurių dengiamą poerdvį atliekama \\(|\\psi\\rangle\\) būsenos projekcija. Grįžtant prie standartinių Pauli-\\(Z\\) matavimų, jeigu kubitas yra \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenoje, bet ne jų superpozicijoje, tada projekcinis matavimas užtikrina, kad šią būseną ir rasime, o pats matavimas būsenos nepakeičia. Pavyzdžiui, jeigu \\(|\\psi\\rangle = |1\\rangle\\), tada tikimybė rasti \\(|1\\rangle\\) yra \\(p(-1)\\): \\[\\begin{equation} p(-1) = \\langle 1|1\\rangle\\langle 1|1\\rangle = \\big|\\langle 1|1\\rangle\\big|^2 = 1\\,, \\tag{3.11} \\end{equation}\\] ir būsena iškart po matavimo \\(|\\varphi\\rangle\\): \\[\\begin{equation} |\\varphi\\rangle = \\frac{|1\\rangle\\langle 1|1\\rangle}{\\sqrt{\\big|\\langle 1|1\\rangle\\big|^2}} = |1\\rangle\\,, \\tag{3.12} \\end{equation}\\] Pakartoję tą patį kubito būsenos matavimą esame užtikrinti, kad rasime vėl tą pačią būseną kaip ir po pirmojo matavimo. Mat formaliai projekcinis operatorius šiuo atveju nepakeičia būsenos \\(P_k|k\\rangle = |k\\rangle\\), \\(k \\in \\{ 0, 1\\}\\). Panagrinėkime, kaip matavimas veikia bendrą normuotą kubito būseną, esančią superpozicijoje \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\). Jeigu norime sužinoti, kokia tikimybė rasti kubitą būsenoje \\(|1\\rangle\\), tam vėl renkamės \\(P_1 = |1\\rangle\\langle 1|\\) projekcinį operatorių. Trečiasis postulatas formaliai parodo, kaip vektorių amplitudės yra susietos su matavimo rezultatų tikimybėmis. Randame: \\[\\begin{equation} \\begin{aligned} p(-1) = &amp; \\langle\\psi |1\\rangle\\langle 1|\\psi\\rangle \\\\ = &amp; b^{*}b\\langle 1|1\\rangle\\langle 1|1\\rangle + a^{*}a\\langle 0|1\\rangle\\langle 1|0\\rangle + a^{*}b\\langle 0|1\\rangle\\langle 1|1\\rangle + b^{*}a\\langle 1|1\\rangle\\langle 1|0\\rangle \\\\ = &amp; b^{*}b = |b|^2\\,. \\end{aligned} \\tag{3.13} \\end{equation}\\] Viršuje pritaikėme kubito būsenų ortogonalumą, tad nariai \\(\\langle 1|0\\rangle = \\langle 0|1\\rangle = 0\\). Kaip ir tikėjomės, tikimybė rasti kubitą \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenoje yra lygi tos būsenos amplitudės (kompleksiniam) kvadratui. Po šio matavimo, kubito būsena yra: \\[\\begin{equation} |\\varphi\\rangle = \\frac{|1\\rangle\\langle 1|\\psi\\rangle}{\\sqrt{|b|^{2}}} = \\frac{b|1\\rangle}{|b|}= \\mathrm{e}^{\\mathrm{i}\\theta}|1\\rangle = |1\\rangle\\,. \\tag{3.14} \\end{equation}\\] Gavome \\(|1\\rangle\\) su koeficientu \\(b/|b|\\) ir pasinaudojome sąlyga, kad kompleksinį skaičių \\(b\\) galima išreikšti \\(b = |b|\\mathrm{e}^{\\mathrm{i}\\theta}\\). Kadangi kvantinių būsenų vektoriai yra nusakomi iki globalios fazės, narys \\(\\mathrm{e}^{\\mathrm{i}\\theta}\\) gali būti praleidžiamas galutinėje išraiškoje. Atitinkamai naudotume \\(P_0 = |0\\rangle\\langle 0|\\) norint apskaičiuoti tikimybę rasti kubitą \\(|0\\rangle\\) būsenoje, o \\(p(1) = |a|^2\\). Viršuje atliktas matavimas bendrai kubito būsenai, esančiai \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijoje parodo, kad po matavimo ši superpozicija yra sugriaunama. Tai literatūroje dar vadinama kvantinės būsenos suirimu. Po superpozicijos suirimo būsena tampa \\(|0\\rangle\\) su tikimybe \\(|a|^2\\), arba \\(|1\\rangle\\) su tikimybe \\(|b|^2\\). Tai reiškia, kad jeigu daug kartų pakartosime šį eksperimentą atlikdami kubito paruošimą į identišką pradinę būseną bei matavimus, statistinis rezultatas bus nusakomas \\(p(\\lambda_{k})\\). Kvantinėje mechanikoje tik būsenos, kurios yra viena kitai ortogonalios, gali būti patikimai atskirtos. Jeigu dvi būsenos, nusakytos \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\) vektoriais, yra skirtingos, bet ne ortogonalios \\(\\langle\\psi|\\phi\\rangle \\neq 0\\), tai reiškia, kad jos iš dalies persikloja. Kitaip tariant, \\(|\\phi\\rangle\\) būsena turi savyje statmeną ir lygiagretų komponentą \\(|\\psi\\rangle\\) vektoriaus atžvilgiu. Dėl esamo lygiagretaus komponento atsiranda tikimybė, kad \\(|\\phi\\rangle\\) būsenos matavimo metu bus rasta \\(|\\psi\\rangle\\) būsena. Tai yra viena iš priežasčių, kodėl kvantinėje kompiuterijoje naudojami ortogonalieji baziniai vektoriai bei projekciniai matavimai į ortogonaliuosius poerdvius. Viršuje pateikėme selektyvų matavimo būdą, kuris figūruoja kvantinėje kompiuterijoje. Be šio būdo, galima sutikti eksperimentinėje fizikoje labiau įprastą neselektyvų būsenų matavimo metodą (angl. non-selective measurement). Jis suteikia matuojamo fizikinio dydžio, nusakomo tikrinėmis vertėmis \\(\\lambda_k\\), vidurkį (angl. expectation value). Pavyzdžiui, 1 kubito atveju, atlikę jo bendros superpozicijos būsenos \\(|\\psi\\rangle\\) Pauli-\\(Z\\) matavimus \\(n\\) kartų, rastume \\(\\lambda_1\\) tikrinę vertę ir \\(m\\) kartų \\(\\lambda_{-1}\\). Tad šių tikrinių verčių vidurkis \\(\\langle\\psi |Z|\\psi\\rangle\\) yra: \\[\\begin{equation} \\langle\\psi |Z|\\psi\\rangle = \\frac{n\\lambda_1 + m\\lambda_{-1}}{n + m} = p(1)\\lambda_1 + p(-1)\\lambda_{-1}\\,. \\tag{3.15} \\end{equation}\\] Viršuje pateikta formulė, kurią taikytume atlikdami eksperimentą. Apibūdinsime, kaip formaliai apskaičiuojame \\(\\langle\\psi |Z|\\psi\\rangle\\). Matuojamą fizikinį dydį nusako ermitinis operatorius \\(P\\), turintis \\(\\lambda_k\\) tikrines vertes, susietas su vektoriais \\(|k\\rangle\\). Viršuje naudojome Pauli-\\(Z\\) operatorių, \\(P = Z\\). Imkime normuotą, nebūtinai kubito, superpozicijos būseną \\(|\\psi\\rangle\\): \\[\\begin{equation} |\\psi\\rangle = \\sum_k a_k |k\\rangle\\,. \\tag{3.16} \\end{equation}\\] Čia \\(|\\psi\\rangle\\) yra išreikšta \\(P\\) operatoriaus tikriniais vektoriais \\(|k\\rangle\\) su amplitudėmis \\(a_k\\). Daug kartų atlikę operatoriaus \\(P\\) neselektyvųjį matavimą, trumpai užrašant \\(\\langle P\\rangle\\), identiškai paruoštai būsenai \\(|\\psi\\rangle\\), randame: \\[\\begin{equation} \\begin{aligned} \\langle P\\rangle = &amp; \\langle\\psi |P|\\psi\\rangle = \\left(\\sum_{k&#39;} a_{k&#39;}^{*}\\langle k&#39;|\\right) \\left(\\sum_k \\lambda_k P_k \\right) \\left(\\sum_{k&#39;&#39;} a_{k&#39;&#39;}|k&#39;&#39;\\rangle\\right) \\\\ = &amp; \\sum_k |a_k |^2 \\lambda_k\\,. \\end{aligned} \\tag{3.17} \\end{equation}\\] Viršuje formaliai panaudojome \\(\\langle k&#39;|P_k |k&#39;&#39;\\rangle = \\delta_{k&#39;k}\\delta_{kk&#39;&#39;}\\) panaikindami du suminius indeksus. Tad vidurkis yra nulemtas tikimybių \\(p(\\lambda_k)=|a_k |^2\\), nusakančių rasti \\(|k\\rangle\\) būsenas, sietinas su atitinkamomis tikrinėmis vertėmis \\(\\lambda_k\\). Tai identiška išraiška tai, kurią naudojome aprašyti eksperimente apskaičiuojamą 1 kubito \\(\\langle\\psi |Z|\\psi\\rangle\\). IV postulatas – sudėtinės sistemos. Sudėtinės kvantinės sistemos būsenų erdvė yra nusakoma ją sudarančių individualių posistemės erdvių tenzorių sandauga, \\(\\mathcal{H}^{\\otimes n} = \\mathcal{H}_1\\otimes\\mathcal{H}_2\\otimes\\cdots\\mathcal{H}_n\\), o sistemos būsena yra tenzorinė vektorių sandauga, \\(|\\psi\\rangle = |\\phi_1 \\rangle\\otimes|\\phi_2 \\rangle\\otimes\\cdots\\otimes |\\phi_n \\rangle\\). Vektorių, išreikštų tenzorinėmis sandaugomis superpozicija, pavyzdžiui, \\(|\\psi\\rangle = a|\\phi_1 \\rangle\\otimes\\cdots\\otimes|\\phi_n \\rangle + b|\\phi_1 \\rangle\\otimes\\cdots\\otimes|\\phi_n \\rangle\\), yra kita galima būsena \\(\\mathcal{H}^{\\otimes n}\\) erdvėje. Ketvirtasis postulatas praplečia pirmąjį postulatą ir formaliai nusako, kaip matematiškai aprašyti sudėtinės sistemos būsenas. Sistemos, sudarytos iš \\(n\\) kubitų būsenos, vektorius yra nusakomas \\(2^n\\) dimensijų Hilberto vektorių erdvėje. Ši erdvė yra formuojama iš individualių posistemės erdvių taikant tenzorių sandaugą, kuri žymima simboliu \\(\\otimes\\). Matematinį formulavimą bei sudėtinių sistemų transformacijas jau trumpai apibendrinome antrame skyriuje. Norint supaprastinti simboliką, vietoj \\(|\\phi_1 \\rangle\\otimes|\\phi_2 \\rangle\\otimes\\cdots\\) galime rašyti \\(|\\phi_1 \\phi_2\\cdots \\rangle\\). Kaip pavyzdį imkime 2 kubitų sistemą. Naudojant skaičiuojamąjį bazinių vektorių rinkinį, {\\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\), \\(|11\\rangle\\)}, galima išreikšti bet kokią kubito \\(|\\psi\\rangle\\) būseną 4 dimensijų Hilberto erdvėje pritaikius jų tiesinę sumą: \\[\\begin{equation} |\\psi\\rangle = a|00\\rangle + b|01\\rangle + c|10\\rangle + d|11\\rangle\\,. \\tag{3.18} \\end{equation}\\] Čia naudojame kubitų numeraciją \\(|k_1 k_2 \\rangle\\). Kadangi kvantinės būsenos yra nusakomos normuotais vektoriais, amplitudžių modulių kvadratų suma susideda į vienetą: \\[\\begin{equation} |a|^2 + |b|^2 + |c|^2 + |d|^2 = 1\\,. \\tag{3.19} \\end{equation}\\] Atlikus 2 kubitų matavimus \\(|\\psi\\rangle\\) būsenoje, tikimybę rasti bitų sekas, nurodytas baziniuose vektoriuose, galima nuskaityti tiesiogiai iš prie jų prišlietų amplitudžių. Rasime \\(|00\\rangle\\) su tikimybe \\(|a|^2\\), \\(|01\\rangle\\) su \\(|b|^2\\) ir kitas analogiškai. Norėdami apskaičiuoti tikimybę rasti, pavyzdžiui, vien tik pirmą kubitą būsenoje \\(|1\\rangle\\), formaliai pasitelkiame trečiąjį postulatą apskaičiuoti \\(\\langle\\psi |P_1^1 |\\psi\\rangle\\). Dirbdami 2 kubitų erdvėje naudojame \\(P_1^1 = |1\\rangle\\langle 1|\\otimes I\\) projekcinį operatorių, kuris per \\(\\otimes\\) ženklą nusako, kad projekcinis matavimas į poerdvį, dengiamą \\(|1\\rangle\\) būsenos, bus atliekamas su pirmuoju kubitu: \\[\\begin{equation} \\langle\\psi |P_1^1 |\\psi\\rangle = \\big(\\langle 10| c^{*} + \\langle 11|d^{*}\\big) \\big(c|10\\rangle + d|11\\rangle\\big) = |c|^2 + |d|^2\\,. \\tag{3.20} \\end{equation}\\] Normuotą būseną \\(|\\varphi\\rangle\\) po šio matavimo randame: \\[\\begin{equation} |\\varphi\\rangle = \\frac{P_1^1 |\\psi\\rangle}{\\sqrt{\\langle\\psi |P_1^1 |\\psi\\rangle}} = \\frac{c|10\\rangle + d|11\\rangle}{\\sqrt{|c|^2 + |d|^2}}\\,. \\tag{3.21} \\end{equation}\\] Norėdami nusakyti, kokia tikimybė rasti \\(|\\psi\\rangle\\), pavyzdžiui, \\(|01\\rangle\\) būsenoje, naudotume \\(P_{0,1}^{1,2} = |0\\rangle\\langle 0|\\otimes|1\\rangle\\langle 1| = |01\\rangle\\langle 01|\\) projekcinį operatorių. Kvantinės mechanikos postulatas, nusakantis sistemos evoliuciją laike, yra analogiškai taikomas ir sudėtinėse sistemose. Pavyzdžiui, jeigu unitarusis operatorius \\(U_1\\) nusako pirmo kubito evoliuciją laike, o \\(U_2\\) antro, tai \\(U = U_1 \\otimes U_2\\) formaliai aprašo sudėtinės 2 kubitų sistemos \\(|\\chi\\rangle = |\\phi_1 \\rangle\\otimes|\\phi_2 \\rangle\\) unitarinę evoliuciją: \\[\\begin{equation} U|\\chi\\rangle = (U_1 \\otimes U_2 )|\\phi_1 \\rangle\\otimes|\\phi_2 \\rangle = U_1 |\\phi_1 \\rangle\\otimes U_2|\\phi_2 \\rangle\\,. \\tag{3.22} \\end{equation}\\] Viršuje pateikti \\(U_1 \\otimes U_2\\) operatoriai yra vadinami lokaliaisiais, kadangi jie transformuoja individualius posistemės kubitus nepriklausomai nuo kitų būsenos. Bendresnio pobūdžio išplėstiniai operatoriai yra išreiškiami naudojant lokaliųjų operatorių sumas. Pavyzdžiui, 2 kubitų \\(U = U_1 \\otimes U_2 + I\\otimes U_1\\): \\[\\begin{equation} U|\\chi\\rangle = U_1 |\\phi_1 \\rangle\\otimes U_2 |\\phi_2 \\rangle + |\\phi_1 \\rangle\\otimes U_1 |\\phi_2 \\rangle\\,. \\tag{3.23} \\end{equation}\\] Išplėstiniai operatoriai gali perteikti fizines sąveikas tarp atskirų kubitų ir yra svarbūs realizuojant universalius kvantinių loginių vartų rinkinius. Dėl sąveikų tarp kubitų gali atsirasti kvantinis supynimas, kuris aptariamas toliau. 3.2 Kvantinis supynimas Klasikinėje fizikoje sistemą galima išsamiai aprašyti nusakant, kokioje būsenoje yra jos atskiros posistemės. Kvantinėje fizikoje galimos ir tokios būsenos, kuriose atskiros posistemės praranda individualią reikšmę ir sistema elgiasi efektyviai kaip vienas darinys. Tokios kvantinės sistemos yra supintosios, jų neįmanoma išsamiai apibūdinti sužinant, kokioje būsenoje yra atskiros posistemės. Sudėtinės kubitų sistemos būseną galima klasifikuoti įvertinant, ar jos posistemės yra supintosios, ar vis tik galima aprašyti kiekvieną kubitą individualiai. Jeigu sudėtinės sistemos vektorių galima faktorizuoti į atskirus kubitus, pavyzdžiui, \\(|\\kappa\\rangle = |\\phi_1 \\rangle\\otimes|\\phi_2 \\rangle\\), tokia sistema nėra supintoji. Kad tai parodytume formaliau, imkime du kubitus būsenose: \\(|\\phi_1 \\rangle = e|0\\rangle + f|1\\rangle\\) ir \\(|\\phi_2 \\rangle = g|0\\rangle + h|1\\rangle\\). Šių dviejų kubitų sudėtinė būsena yra nusakyta jų tenzorių sandauga: \\[\\begin{equation} \\begin{aligned} |\\phi_1 \\phi_2 \\rangle = &amp; \\big(e|0\\rangle + f|1\\rangle\\big)\\otimes \\big(g|0\\rangle + h|1\\rangle\\big) \\\\ = &amp; eg|00\\rangle + eh|01\\rangle + fg|10\\rangle + fh|11\\rangle\\,. \\end{aligned} \\tag{3.24} \\end{equation}\\] Tokia būsena leidžia interpretaciją, nusakančią, kad pirmas kubitas yra \\(|\\phi_1 \\rangle\\) būsenoje, o antras \\(|\\phi_2 \\rangle\\). Tai yra dviejų klasikinių bitų būsenos kvantinis atitikmuo. Tolesnę būseną taip pat galima faktorizuoti: \\[\\begin{equation} |\\tau\\rangle = a|00\\rangle + b|10\\rangle\\,, \\tag{3.25} \\end{equation}\\] nes \\(|\\phi_1 \\phi_2 \\rangle\\) būsenoje galima rasti koeficientus \\(h = 0\\), \\(a = eg\\), \\(b = fg\\). Vienas supintosios būsenos pavyzdys būtų: \\[\\begin{equation} |\\chi\\rangle = a|00\\rangle + b|11\\rangle\\,. \\tag{3.26} \\end{equation}\\] Atkreipiame dėmesį, kad neįmanoma rasti {\\(e\\), \\(f\\), \\(g\\), \\(h\\)} koeficientų \\(|\\phi_1 \\phi_2 \\rangle\\) būsenoje, kuri leistų išreikšti \\(|\\chi\\rangle\\). Šios būsenos neįmanoma faktorizuoti, ir todėl individualių kubitų būsenos yra neapibrėžtos. Supintuosiuose kubituose dalis informacijos yra laikoma kvantinėse koreliacijose tarp kubitų. Kadangi šios informacijos fundamentaliai negalime priskirti nei vienam, nei kitam kubitui, sakoma, kad ji yra delokalizuota. Kad iliustruotume koreliacijų vaidmenį, panagrinėkime sudėtinės 2 kubitų sistemos būsenų matavimus. Imkime viršuje minėtas dvi būsenas, faktorizuojamą \\(|\\tau\\rangle\\) ir supintą \\(|\\chi\\rangle\\). Atlikime pirmo kubito projekcinius matavimus naudodami \\(P_0^1 = |0\\rangle\\langle 0|\\otimes I\\) ir \\(P_1^1 = |1\\rangle\\langle 1|\\otimes I\\). Pradėdami nuo faktorizuojamos būsenos \\(|\\tau\\rangle\\), norime nusakyti, kokia yra tikimybė rasti pirmą kubitą \\(|0\\rangle\\) būsenoje: \\[\\begin{equation} \\langle\\tau |P_0^1 |\\tau\\rangle = |a|^2\\,. \\tag{3.27} \\end{equation}\\] Bendra 2 kubitų būsena, vadinsime ją \\(|\\tau&#39;\\rangle\\), po šio matavimo yra: \\[\\begin{equation} |\\tau&#39;\\rangle = \\frac{P_0^1 |\\tau\\rangle}{\\sqrt{\\langle\\tau |P_0^1 |\\tau\\rangle}} = |0\\rangle\\otimes |0\\rangle\\,. \\tag{3.28} \\end{equation}\\] Tą patį pakartokime nusakyti, kokia tikimybė rasti pirmą kubitą \\(|1\\rangle\\) būsenoje, bei galutinę 2 kubitų būseną: \\[\\begin{align} \\langle\\tau |P_1^1 |\\tau\\rangle = &amp; |b|^2 \\tag{3.29} \\\\ |\\tau&#39;\\rangle = &amp; \\frac{P_1^1 |\\tau\\rangle}{\\sqrt{\\langle\\tau |P_1^1 |\\tau\\rangle}} = |1\\rangle\\otimes |0\\rangle\\,. \\tag{3.30} \\end{align}\\] Akivaizdu, kad nepriklausomai nuo to, ar pirmas kubitas randamas \\(|0\\rangle\\), ar \\(|1\\rangle\\) būsenoje, tai nepaveikia antro kubito būsenos, kuri lieka visada \\(|0\\rangle\\). Tačiau atlikę tuos pačius matavimus su supintąja kubitų būsena \\(|\\chi\\rangle\\) matome, kad radus pirmą kubitą \\(|0\\rangle\\) būsenoje (\\(|a|^2\\) tikimybė), galutinė būsena yra \\(|0\\rangle\\otimes |0\\rangle\\); tai parodo, kad antras kubitas yra užtikrintai \\(|0\\rangle\\). O štai radus pirmą kubitą \\(|1\\rangle\\) būsenoje (\\(|b|^2\\) tikimybė), galutinė būsena yra \\(|1\\rangle\\otimes |1\\rangle\\), tad antras kubitas yra \\(|1\\rangle\\) būsenoje. Nesvarbu, kurį kubitą matuosime pirmą, supintojoje būsenoje po atlikto \\(P_0^1\\) ar \\(P_1^1\\) matavimo antrojo kubito būsena tampa tiksliai žinoma. Be viršuje pateikto 2 kubitų bazinių vektorių skaičiuojamojo rinkinio, Belo 2 kubitų bazinių vektorių rinkinys (angl. Bell basis) yra taip pat dažnai aptinkamas. Visos būsenos jame yra supintosios ir tarpusavyje ortogonalios: \\[\\begin{align} |\\chi^{+}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\,,\\quad |\\chi^{-}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle - |11\\rangle\\big)\\,; \\tag{3.31}\\\\ |\\eta^{+}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|01\\rangle + |10\\rangle\\big)\\,,\\quad |\\eta^{-}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle - |10\\rangle\\big)\\,.\\tag{3.32} \\end{align}\\] Įsivaizduokime situaciją, kurioje Evelina paruošia vieną iš keturių Belo būsenų ir nusiunčia vieną kubitą Agnei, o kitą Benui, neatskleisdama, kokia tai Belo būsena. Ar Agnė ir Benas, turėdami galimybę atlikti matavimus su savo individualiais kubitais, gali pasakyti, kokia tai Belo būsena? Sakykime, kad Agnė ir Benas abu atlieka matavimus su kubitais ir perduoda vienas kitam savo rezultatus, rasdami \\(|00\\rangle\\) būseną. Tad jie gali spėti, kad tai buvo \\(|\\chi^{+}\\rangle\\) arba \\(|\\chi^{-}\\rangle\\), tačiau kuri iš šių dviejų – žinoti tiksliai neįmanoma. Šis neapribrėžtumas atspindi faktą, kad supintojoje kubitų būsenoje dalis informacijos yra laikoma kvantinėse koreliacijose, kurios vien lokaliais atskirų sistemų matavimais pasiekti neįmanoma. Belo baziniai vektoriai yra visi supintieji – tai akivaizdu iš jų būsenos išraiškų. Vis dėlto įvertinti, ar pateikta išraiška nusako supintus kubitus, ne visada paprasta net ir 2 kubitų būsenose. Kaip pavyzdį imkime šią būseną: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{2}\\big(|00\\rangle + |01\\rangle + |10\\rangle - |11\\rangle\\big)\\,. \\tag{3.33} \\end{equation}\\] Ją galimą pergrupuoti taip: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{2}\\Big\\lbrack\\big(|0\\rangle + |1\\rangle)\\otimes |0\\rangle + \\big(|0\\rangle - |1\\rangle\\big)\\otimes |1\\rangle\\Big\\rbrack\\,. \\tag{3.34} \\end{equation}\\] Matome, kad atlikę antro kubito matavimą, rasime \\(|0\\rangle\\) arba \\(|1\\rangle\\) su lygiomis 1/2 tikimybėmis. Tačiau pirmo kubito būsena lieka superpozicijoje \\(1/\\sqrt{2}\\big(|0\\rangle + |1\\rangle\\big)\\), jeigu antro būsena randama \\(|0\\rangle\\), arba \\(1/\\sqrt{2}\\big(|0\\rangle - |1\\rangle\\big)\\), jeigu antro kubito būsena \\(|1\\rangle\\). Kitaip nei Belo būsenose, šiuo atveju pirmas 2 kubitų būsenos \\(|\\psi\\rangle\\) matavimas neleidžia tiksliai sužinoti, kokia bus rasta kito kubito būsena (vektorių {\\(|0\\rangle\\), \\(|1\\rangle\\)} bazėje). Būsena \\(|\\psi\\rangle\\) vis dėlto yra supintoji, ją gavome atlikę \\(|\\chi^{+}\\rangle\\) lokalią unitariąją pirmo kubito transformaciją (Hadamardo transformaciją), kuri pakeičia {\\(|0\\rangle\\), \\(|1\\rangle\\)} Pauli-\\(Z\\) bazinius vektorius į Pauli-\\(X\\) bazinius {\\(|0_x \\rangle\\), \\(|1_x \\rangle\\)}. Šie yra išreikšti \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijomis. Sakome, kad \\(|\\psi\\rangle\\) ir \\(|\\chi^{+}\\rangle\\) yra lokaliai unitariškai ekvivalenčios (angl. local unitary equivalence). Svarbu atsiminti, kad lokalios unitariosios transformacijos negali nei panaikinti, nei įvesti kvantinio supynimo tarp kubitų. Kvantinis supynimas išlieka sistemoje, nebent ji yra veikiama nelokalios unitariosios transformacijos arba atliekamas lokalus projekcinis matavimas. Nusakyti, ar pateikta kvantinė 2 kubitų būsena yra supintoji, galima taikant minėtą tenzorinę faktorizaciją bei vadinamąją Šmito dekompoziciją (angl. Schmidt decomposition). Tačiau, kitaip nei 2 kubituose, \\(n\\) kubitų registre (\\(n &gt; 2\\)) galimos ir tokios būsenos, kuriose tik dalis kubitų yra tarpusavyje supinti. Vis dar nėra standartinio būdo, kaip tiksliai klasifikuoti supynimą didesnėse kvantinėse sistemose. 3.3 Tankio operatorius Praktikoje kvantinių sistemų pakartotinis būsenų paruošimas gali būti ne itin tikslus dėl įrangos netikslumų ar klasikinių atsitiktinių procesų. Pavyzdžiui, termioninėje elektronų emisijoje (angl. thermionic electron emission) volframo metalas yra pakaitinamas iki itin didelės temperatūros, kuri suteikia elektronams pakankamai kinetinės energijos, kad šie galėtų pasprukti iš medžiagos. Tačiau neįmanoma iš anksto tiksliai nuspėti kiekvieno pasprukusio elektrono galutinę kinetinę energiją, galime nusakyti tik jų statistinį pasiskirstymą. Šiuo atveju, mūsų informacija apie elektronų energijos būseną yra neišsami; galime tik pasakyti, kad su klasikine tikimybe \\(p_i\\) (realusis skaičius, \\(0 \\leq p_i \\leq 1)\\) elektronas \\(i\\) bus rastas būsenoje \\(|\\psi_i \\rangle\\). Jeigu užtikrintai žinoma, kad kvantinė sistema yra tam tikroje būsenoje \\(|\\psi_k \\rangle\\), tokia būsena vadinama grynąja (angl. pure state). Remiantis klasikinėmis tikimybėmis, tai reiškia \\(p_{i = k} = 1\\) ir \\(p_{i \\neq k} = 0\\). Visas galimų sistemos būsenų (nebūtinai ortogonaliųjų) rinkinys su atitinkamomis tikimybėmis rasti tam tikrą būseną, \\(\\{ p_i, |\\psi_i \\rangle\\}\\), yra vadinamas grynųjų būsenų ansambliu (angl. ensemble of pure states). Reikalaujame, kad susumavus visas tikimybes \\(p_i\\) jos susidėtų į vienetą, \\(\\sum_i p_i = 1\\). Žinant grynąsias būsenas \\(|\\psi_i \\rangle\\) ir klasikines tikimybes \\(p_i\\), kurias nustato atitinkamas eksperimentinis paruošimo metodas, vėl galima apskaičiuoti pavienių kvantinių sistemų būsenų matavimo tikimybes. Pavyzdžiui, jeigu norėtume atlikti selektyvų kinetinės energijos matavimą termioninių elektronų ansambliui \\(\\{ p_i , |\\psi_i \\rangle\\}\\), tikimybė \\(p(E_k)\\), kad rasime elektroną su energija \\(E_k\\), yra: \\[\\begin{equation} p(E_k) = \\sum_i p_i \\langle \\psi_i |P_k |\\psi_i \\rangle = \\sum_i p_i p_i (E_k)\\,. \\tag{3.35} \\end{equation}\\] Čia \\(P_k\\) atlieka projekciją į būsenų su energija \\(E_k\\) poerdvį, o \\(\\langle\\psi_i |P_k |\\psi_i \\rangle = p_i (E_k)\\) nusako tikimybę, kad atlikus grynosios būsenos \\(|\\psi_i \\rangle\\) energijos matavimą bus rasta energija \\(E_k\\). Išraiškoje matome dvi tikimybes – klasikinę tikimybę \\(p_i\\) bei grynai kvantinio pobūdžio tikimybę \\(p_i (E_k)\\), kuri atsiranda dėl būsenos matavimo proceso. Kvantinei tikimybei negalime priskirti informacijos trūkumo interpretacijos, šis procesas yra fundamentaliai nenuspėjamas. Termioninių elektronų emisija yra vienas iš galimų kvantinių sistemos būsenų paruošimo būdų. Kadangi, kaip ir grynųjų būsenų atveju, galime tiksliai apibūdinti pavienių ansamblio kvantinių sistemų matavimo rezultatus, taip paruoštos kvantinės sistemos būseną formaliai vadiname statistiniu grynųjų būsenų mišiniu (angl. mixed state). Būsenų mišinio neįmanoma apibūdinti vektoriumi ar vidutiniu vektoriumi Hilberto erdvėje. Norint pilnai aprašyti tokią kvantinę sistemą – apimti klasikines tikimybes bei kvantines amplitudes būsenų mišinyje, formaliai yra pasitelkiamas tankio operatorius (angl. density operator), arba jo realizacija tiesinėje algebroje – tankio matrica (angl. density matrix). Visi kvantinės mechanikos postulatai gali būti paprastai performuluojami taikant tankio operatorius vietoj grynąsias būsenas nusakančių vektorių. Tai yra bendriausio pobūdžio kvantinės mechanikos formalizmas. Kadangi apibūdindami kvantinės kompiuterijos ir ryšių principus šioje knygoje daugiausia naudosime grynąsias būsenas, čia pateikiame tik pagrindines tankio operatorių savybes. Tankio operatorius, \\(\\rho\\), nusakantis bendriausią kvantinės sistemos būseną, turi šią matematinę išraišką: \\[\\begin{equation} \\rho = \\sum_i p_i |\\psi_i \\rangle\\langle\\psi_i|\\,. \\tag{3.36} \\end{equation}\\] Čia \\(|\\psi_i \\rangle\\langle\\psi_i |\\) yra projekcinis operatorius į normuotojo \\(|\\psi_i \\rangle\\) vektoriaus dengiamą poerdvį, šalia prišlietos klasikinės tikimybės \\(p_i\\) susideda \\(\\sum_i p_i = 1\\). Grynosios būsenos irgi aprašomos tankio operatoriumi, šiuo atveju \\(p_i = 1\\) tam tikram \\(|\\psi_i \\rangle\\) ir todėl: \\[\\begin{equation} \\rho = |\\psi_i \\rangle\\langle\\psi_i|\\,. \\tag{3.37} \\end{equation}\\] Pavyzdžiui, kubito, esančio grynojoje superpozicijos būsenoje \\(|\\psi\\rangle = \\big(|0\\rangle + |1\\rangle\\big)/\\sqrt{2}\\), tankio operatorius ir jo realizacija matrica, naudojant \\(\\{|0\\rangle , |1\\rangle\\}\\) bazinius vektorius, yra: \\[\\begin{equation} \\rho = |\\psi\\rangle\\langle \\psi| = \\frac{1}{2}\\big(|0\\rangle\\langle 0| + |0\\rangle\\langle 1| + |1\\rangle\\langle 0| + |1\\rangle\\langle 1|\\big) = \\frac{1}{2}\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\\\ \\end{pmatrix}\\,. \\tag{3.38} \\end{equation}\\] O štai kubito būsenų mišinio, kuriame yra lygios klasikinės tikimybės rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\), tankio operatorius yra: \\[\\begin{equation} \\rho = \\frac{1}{2}|0\\rangle\\langle 0| + \\frac{1}{2}|1\\rangle\\langle 1| = \\frac{1}{2}\\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{pmatrix} = \\frac{1}{2}I\\,. \\tag{3.39} \\end{equation}\\] Tankio operatorius \\(\\rho = \\frac{1}{2}I\\) nusako maksimaliai sumaišytą būseną (angl. maximally mixed state). Kitaip tariant, turima informacija apie tokią sistemos būseną yra mažiausia, kokia tik gali būti. Tankio operatorius \\(\\rho\\) yra ermitinis operatorius (\\(\\rho = \\rho^{\\dagger}\\)), nes \\(p_i\\) yra realieji skaičiai. Taip pat, \\(\\rho\\) yra neneigiamasis operatorius \\(\\rho \\geq 0\\), nes panaudojus bet kokį vektorių \\(|\\varphi\\rangle\\) Hilberto erdvėje, \\(\\langle\\varphi |\\rho |\\varphi\\rangle \\geq 0\\): \\[\\begin{equation} \\langle\\varphi |\\rho |\\varphi\\rangle = \\langle\\varphi| \\left(\\sum_i p_i |\\psi_i \\rangle\\langle \\psi_i|\\right)|\\varphi\\rangle = \\sum_i p_i \\big|\\langle\\varphi |\\psi_i \\rangle\\big|^{2} \\geq 0\\,. \\tag{3.40} \\end{equation}\\] Kadangi \\(|\\psi\\rangle\\) visada galime išreikšti pasirinktais baziniais vektoriais, \\(|\\psi\\rangle = \\sum_k a_k |k\\rangle\\), nėra unikalaus būdo perteikti tankio matricai. Viršuje nurodytą grynąją būseną galėtume perteikti pasitelkdami patį \\(|\\psi\\rangle\\) kaip vieną iš bazinių vektorių rinkinyje: {\\(|\\psi\\rangle = |0_x \\rangle = \\big(|0\\rangle + |1\\rangle\\big)/\\sqrt{2}\\), \\(|1_x \\rangle = \\big(|0\\rangle - |1\\rangle\\big)/\\sqrt{2}\\)}. Šiuo atveju, tankio matrica turėtų išraišką: \\[\\begin{equation} \\rho = |\\psi\\rangle\\langle\\psi| = |0_x \\rangle\\langle 0_x| = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\\\ \\end{pmatrix}\\,. \\tag{3.41} \\end{equation}\\] Iš tiesų, kadangi \\(\\rho\\) yra ermitinis operatorius, galima visada \\(\\rho\\) išreikšti diagonaliąja matrica. Vis dėlto yra keletas būdų grynąsias būsenas matematiškai atskirti nuo mišriųjų. Vienas būdas – pasitelkiant matricos pėdsaką. Tankio matricos pėdsakas yra: \\[\\begin{equation} \\mathrm{Tr}(\\rho) = \\sum_i p_i \\mathrm{Tr}\\big(|\\psi_i \\rangle\\langle \\psi_i|\\big) = \\sum_i p_i = 1\\,. \\tag{3.42} \\end{equation}\\] O štai tankio matricos kvadrato pėdsakas: \\[\\begin{equation} \\mathrm{Tr}(\\rho^2 ) = \\sum_{i,j} p_i p_j \\mathrm{Tr}\\big(|\\psi_i \\rangle \\langle\\psi_i |\\psi_j \\rangle\\langle\\psi_j |\\big) = \\sum_i p_i^2 \\leq 1\\,. \\tag{3.43} \\end{equation}\\] Viršuje panaudojome \\(\\langle\\psi_i|\\psi_j \\rangle = \\delta_{ij}\\) bei \\(0 \\leq p_i \\leq 1\\). Lygybė tenkinama, jeigu \\(p_i = 1\\) su tam tikru \\(i\\) ir lygi nuliui su visais kitais. Todėl grynosios būsenos tenkina sąlygą: \\(\\mathrm{Tr}(\\rho^2 ) = \\mathrm{Tr}(\\rho) = 1\\), na o mišriosios – sąlygą: \\(\\mathrm{Tr}(\\rho) = 1\\) ir \\(\\mathrm{Tr}(\\rho^2 ) &lt; 1\\). Toks būdas atskirti mišriąsias ir grynąsias būsenas yra paprastas, nes matricos pėdsakas nepriklauso nuo bazinių vektorių, kuriais išreiškiama matrica. Diagonaliojoje reprezentacijoje grynosios būsenos visada turi tik vieną matricos elementą, o štai mišrioji – daugiau negu vieną. Dėl to dažnai sakoma, kad diagonalieji tankio matricos elementai įvardija statistinę būsenų populiaciją. Nediagonalieji elementai (angl. off-diagonal) suteikia informacijos apie koherencijos buvimą, nes jie yra kvantinių būsenų amplitudžių sandaugos, \\(a_k a_l^{*}\\). Tai matėme anksčiau perteikdami superpozicijos būsenos \\(|\\psi\\rangle = \\big(|0\\rangle + |1\\rangle\\big)/\\sqrt{2}\\) tankio matricą. Dekoherencijos procesas yra sietinas su nediagonaliųjų tankio matricos elementų sunykimu ir artėjimu prie maksimaliai sumaišytos būsenos. Toliau panagrinėsime, kaip formaliai apskaičiuoti kvantinės sistemos, apibūdintos tankio operatoriumi \\(\\rho\\), selektyvaus matavimo tikimybes. Grįžkime prie anksčiau pateikto selektyvaus matavimo termioninių elektronų ansambliui \\(\\{p_{i}, |\\psi_i \\rangle\\}\\), nusakytam mišria būsena \\(\\rho = \\sum_i p_i |\\psi_i \\rangle\\langle\\psi_i|\\). Įterpdami vienetinį operatorių \\(I = \\sum_j |j\\rangle\\langle j|\\) tarp \\(\\langle\\psi_i|\\) ir \\(P_k\\) randame: \\[\\begin{equation} \\begin{aligned} p(E_k) = &amp; \\sum_i p_i \\langle\\psi_i |P_k |\\psi_i\\rangle = \\sum_{i,j} p_i \\langle j|P_k |\\psi_i \\rangle\\langle\\psi_i|j\\rangle = \\sum_j \\langle j|P_k \\rho |j\\rangle \\\\ = &amp; \\mathrm{Tr}(P_k \\rho)\\,. \\end{aligned} \\tag{3.44} \\end{equation}\\] Tad tikimybė \\(p(E_k)\\) randama atlikus projekcinės ir tankio matricų sandaugos pėdsaką. Įterpę \\(I\\) tarp \\(P_k\\) ir \\(|\\psi_i \\rangle\\) matytume, kad \\(\\mathrm{Tr}(P_k \\rho) = \\mathrm{Tr}(\\rho P_k )\\); tai dar kartą parodo matricų pėdsako cikliškumo savybę. Selektyvus matavimas, pavyzdžiui, norint nusakyti tikimybę \\(p(1)\\) rasti kubitą \\(|0\\rangle\\) būsenoje, gali būti atliktas pasitelkiant \\(P_1 = |0\\rangle\\langle 0|\\) projekcinį operatorių: \\[\\begin{equation} \\begin{aligned} p(1) = &amp; \\mathrm{Tr}(\\rho P_1 ) = \\mathrm{Tr}\\left( \\sum_i p_i |\\psi_i \\rangle\\langle\\psi_i |P_1 \\right) = \\sum_i p_i \\big|\\langle 0 |\\psi_i \\rangle\\big|^2 \\\\ = &amp; \\sum_i p_i |a_{i,0}|^2\\,. \\end{aligned} \\tag{3.45} \\end{equation}\\] Selektyvus būsenų mišinio matavimas, jeigu nėra būsenų išsigimimo, sukuria galutinę grynąją būseną. Tai išplaukia iš trečiojo kvantinės mechanikos postulato ir yra vienas būdas, kaip paruošti grynąsias būsenas. O štai neselektyvus P operatoriaus matavimas būsenų mišiniui apskaičiuojamas iš \\(\\langle P\\rangle = \\mathrm{Tr}(\\rho P)\\) ir bendrai sukuria kitą būsenų mišinį. Kvantinių sistemų, aprašytų tankio operatoriumi, evoliucija laike nuo \\(t_0\\) iki \\(t_1\\) nusakoma unitariniu operatoriumi \\(U(t_0 ,t_1)\\) taip: \\[\\begin{equation} \\rho (t_1 ) = U(t_0 ,t_1)\\rho (t_0 )U^{\\dagger}(t_0 ,t_1 ) = \\sum_i p_i U(t_0 ,t_1 )|\\psi_i (t_0) \\rangle\\langle \\psi_i (t_0 )| U^{\\dagger}(t_0 ,t_1 )\\,. \\tag{3.46} \\end{equation}\\] Norint apibūdinti loginių vartų \\(U\\) efektą pradinei būsenai, apibūdintai tankio matrica \\(\\rho\\), glaustai rašome: \\[\\begin{equation} \\rho&#39; = U\\rho U^{\\dagger}\\,. \\tag{3.47} \\end{equation}\\] II(b) postulatas, nusakantis sistemos evoliuciją Šriodingerio lygtimi, yra paprastai performuluojamas taikant fon Noimano–Luivilio (angl. von Neumann–Liouville) lygtį: \\[\\begin{equation} \\mathrm{i}\\hbar\\frac{d\\rho(t)}{dt} = \\lbrack H,\\rho(t) \\rbrack\\,. \\tag{3.48} \\end{equation}\\] Lygtyje \\(H\\) nusako sistemos hamiltonianą, skliausteliai indikuoja \\(H\\) ir \\(\\rho\\) komutatorių. Sudėtinę kvantinę sistemą, kurios būsena yra faktorizuojama, galima išreikšti tenzorine tankio operatorių sandauga, \\(\\rho = \\rho_1\\otimes\\rho_2\\otimes\\rho_3\\otimes\\cdots\\); čia \\(\\rho_i\\) nusako posistemės \\(i\\) būseną. Jeigu tankio matricos išreikšti tenzorine posistemių sandauga neįmanoma, \\(\\rho \\neq \\rho_1\\otimes\\rho_2\\), tokia sistema yra supintoji. Imkime kaip pavyzdį 2 kubitų supintą grynąją būseną \\(|\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\). Jos tankio operatorius ir matrica, vektorių {\\(|0\\rangle\\), \\(|1\\rangle\\)} bazėje yra: \\[\\begin{equation} \\begin{aligned} \\rho = &amp; |\\chi^{+}\\rangle\\langle\\chi^{+}| = \\frac{1}{2}\\big(|00\\rangle\\langle 00| + |00\\rangle\\langle 11| + |11\\rangle\\langle 00| + |11\\rangle\\langle 11|\\big) \\\\ = &amp; \\frac{1}{2}\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\,. \\end{aligned} \\tag{3.49} \\end{equation}\\] Tankio operatorių formalizmas suteikia būdą aprašyti posistemės būseną nepriklausomai nuo to, ar sudėtinė sistema yra supinta, ar faktorizuojama. Tam pasitelkiamas dalinis matricų pėdsakas (angl. partial trace), kuriame atliekamas pėdsakas tik vienai iš pasirinktų posistemių. Imkime, kad \\(\\rho_{AB}\\) nusako dviejų sistemų \\(A\\) ir \\(B\\) tankio matricą, tada: \\[\\begin{equation} \\mathrm{Tr}_A (\\rho_{AB}) = \\rho_{B}\\,,\\quad \\mathrm{Tr}_B (\\rho_{AB}) = \\rho_{A}\\,. \\tag{3.50} \\end{equation}\\] Gautas darinys \\(\\rho_A\\) arba \\(\\rho_B\\) yra vadinamas redukuota tankio matrica (angl. reduced density matrix) ir nusako atitinkamos posistemės būseną. Formaliai tariant, dalinis pėdsakas yra operatorius, veikiantis tik vieną posistemę. Pavyzdžiui, jeigu \\(\\rho_{AB} = |a_1 \\rangle\\langle a_2|\\otimes |b_1\\rangle\\langle b_2|\\), tada: \\[\\begin{equation} \\mathrm{Tr}_A(\\rho_{AB}) = \\sum_j \\big(\\langle j|\\otimes I\\big)\\rho_{AB} \\big(|j\\rangle\\otimes I\\big) = \\mathrm{Tr}\\big(|a_1 \\rangle\\langle a_2|\\big) |b_1 \\rangle\\langle b_2|\\,. \\tag{3.51} \\end{equation}\\] Kaip ir tikėtasi, faktorizuojama būsenos \\(\\rho_{AB}\\) redukuota tankio matrica yra \\(|b_1\\rangle\\langle b_2|\\) (iki globalios konstantos). Grįžtant prie supintosios 2 kubitų grynosios būsenos \\(\\rho = |\\chi^{+}\\rangle\\langle\\chi^{+}|\\), įdomu įvertinti jos redukuotą tankio matricą \\(\\rho_{1}\\) arba \\(\\rho_{2}\\). Atlikdami dalinį pėdsaką pirmąjam kubitui randame: \\[\\begin{equation} \\rho_2 = \\mathrm{Tr}_1(\\rho) = \\sum_{j = 0,1} \\big(\\langle j|\\otimes I\\big)\\rho\\big(|j\\rangle\\otimes I\\big) = \\frac{1}{2}\\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{pmatrix} = \\frac{1}{2}I\\,. \\tag{3.52} \\end{equation}\\] Matome, kad redukuota tankio matrica apibūdina maksimaliai sumaišytą būseną, nepaisant to, kad sudėtinės sistemos \\(\\rho\\) būsena yra grynoji (žinoma užtikrintai). Tai – dar vienas supintųjų kvantinių būsenų skiriamasis ženklas. 3.4 EPR paradoksas Į kvantinių koreliacijų įtaką supintųjų būsenų matavimui atkreipė dėmesį ir A. Einšteinas, su kolegomis 1935 metais publikavęs žinomą darbą, dabar vadinamą EPR paradoksu (angl. Einstein-Podolsky-Rosen paradox). Čia pateikiame jų įsivaizduojamo eksperimento versiją, pasiūlytą Davido Bohmo ir naudojančią dviejų lygių kvantinę sistemą (kubitus). Įsivaizduokime, kad yra paruošiama supintoji 2 kubitų būsena, pavyzdžiui, ši: \\[\\begin{equation} |\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\,. \\tag{3.53} \\end{equation}\\] Pirmas fizinis kubitas paliekamas Žemėje, o antras nusiunčiamas į tolimą planetą pavadinimu \\(W\\). Nors šių supintųjų kubitų būsena yra grynoji ir tiksliai žinoma, tačiau pavienių kubitų būsenos neapibrėžtos. Atlikus matavimą yra lygios tikimybės rasti pirmą kubitą \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenoje. Tačiau pamatavus pirmą kubitą Žemėje ir radus, pavyzdžiui, \\(|1\\rangle\\) būseną, antro kubito būsena planetoje \\(W\\) bus taip pat užtikrintai rasta \\(|1\\rangle\\), (\\(|\\chi^{+}\\rangle \\rightarrow |11\\rangle\\)). Einšteinas su kolegomis čia įžvelgė potencialų prieštaravimą reliatyvumo teorijai, kadangi vienos sistemos būsenos matavimas akimirksniu paveikia kitos sistemos būseną, nepaisant atstumo tarp jų. Kvantinė mechanika, EPR kompanijos požiūriu, negali būti išsami teorija, apibūdinanti gamtą. Nors jų argumentai neįtikino fizikų bendruomenės, tačiau tai buvo svarbus darbas, atkreipiantis dėmesį į kvantinės mechanikos įvariuose kontekstuose pasikartojančias keistąsias savybes. Norėdami iliustruoti EPR paradoksui artimą gyvenimišką pavyzdį imkime, kad Benas turi dvi identiškas dėžutes ir vienoje iš jų paslepia raudoną kamuolį, o kitoje – mėlyną. Agnė ir Benas žino, kad dėžutėse yra dviejų skirtingų spalvų kamuoliai, tačiau tik Benas žino, kuriose jie paslėpti. Agnės požiūriu, tikimybė atidarius pasirinktą dėžutę rasti vieną ar kitą kamuolį yra \\(p=0.5\\). Tačiau atidariusi vieną dėžutę ji automatiškai žinos, kokios spalvos kamuolys yra kitoje. Šiuo atveju Agnės nežinojimas apie išankstinį Beno kamuolių išdėstymą jai suteikė koreliacijos pagrindą, panašų į atsirandantį dėl kubitų supynimo. Sekant Pagal šį klasikinį pavyzdį vienas argumentas paaiškinti EPR paradoksą būtų agituojant, kad kubitai kažkaip susimokė nuo pat pradžių ir jų būsena vis dėlto buvo \\(|00\\rangle\\) arba \\(|11\\rangle\\), tačiau mes šios informacijos neturėjome. Norėdami patikrinti tokį argumentą, galime žvelgti į EPR paradoksą kitu būdu. Kaip pamename, kvantinę būseną visada galima išreikšti bet kuriais kitais pageidaujamais baziniais vektoriais, nieko ypatingo nėra išraiškoje \\(\\{|0\\rangle , |1\\rangle\\}\\). Vietoj anksčiau naudotų Pauli-\\(Z\\), imkime Pauli-\\(X\\) bazinius vektorius \\(\\{|0_x\\rangle , |1_x\\rangle\\}\\). Perteikę jais \\(|\\chi^{+}\\rangle\\) randame: \\[\\begin{equation} |\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0_x \\rangle\\otimes |0_x\\rangle + |1_x \\rangle\\otimes|1_x \\rangle\\big)\\,. \\tag{3.54} \\end{equation}\\] Šiuo atveju, \\(|\\chi^{+}\\rangle\\) turi identišką formą, kaip ir naudojant Pauli-\\(Z\\) bazinius vektorius. Taip pat galime pasirinkti skirtingą matavimo būdą. Su pirmu kubitu būsenoje \\(|\\chi^{+}\\rangle\\) galime atlikti ne standartinius Pauli-\\(Z\\) operatoriaus matavimus: \\(P_0^1 = |0\\rangle\\langle 0|\\otimes I\\) ir \\(P_1^1 = |1\\rangle\\langle 1|\\otimes I\\), bet pasirinkti Pauli-\\(X\\): \\(P_{0x}^1 = |0_x \\rangle\\langle 0_x|\\otimes I\\) ir \\(P_{1x}^1 = |1_x \\rangle\\langle 1_x|\\otimes I\\). Fiziškai tai galėtų reikšti, kad fotono poliarizacijos būseną matuojame ne išilgai su horizontaliąja–vertikaliąja poliarizacijos ašimis, tačiau pasukę šias abi matavimo kryptis \\(45^{\\circ}\\) kampu (įstrižoji poliarizacija). Vėlgi matome, kad atlikus \\(P_{0x}^1\\) ir \\(P_{1x}^1\\) būsenai \\(|\\chi^{+}\\rangle\\) yra lygios tikimybės rasti pirmą kubitą \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\) būsenoje. Galutinės dviejų kubitų būsenos po tokio matavimo tampa: \\[\\begin{equation} |\\chi^{+}\\rangle \\rightarrow \\frac{P_{0x}^1|\\chi^{+}\\rangle}{\\sqrt{ \\langle\\chi^{+}|P_{0x}^1 |\\chi^{+}\\rangle}} = |0_x \\rangle\\otimes |0_x \\rangle\\,. \\tag{3.55} \\end{equation}\\] Arba: \\[\\begin{equation} |\\chi^{+}\\rangle \\rightarrow \\frac{P_{1x}^1|\\chi^{+}\\rangle}{\\sqrt{ \\langle\\chi^{+}|P_{1x}^1 |\\chi^{+}\\rangle}} = |1_{x} \\rangle\\otimes|1_x \\rangle\\,. \\tag{3.56} \\end{equation}\\] Tai, kokį matavimo būdą pasirinksime pirmam kubitui Žemėje, nulems, kokia bus antro kubito būsena planetoje \\(W\\). Jeigu renkamės Pauli-\\(Z\\) operatoriaus matavimus, tada antro kubito būsenos galimi variantai bus \\(|0\\rangle\\) arba \\(|1\\rangle\\), o jeigu renkamės Pauli-\\(X\\), jie bus \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\). Tačiau kubitas negali būti apibrėžtoje Pauli-\\(X\\) ir Pauli-\\(Z\\) bazinių vektorių būsenoje vienu metu, nes šie operatoriai yra nekomutatyvūs ir todėl neturi bendrų bazinių vektorių. Tad, jeigu kubitai buvo \\(|00\\rangle\\) arba \\(|11\\rangle\\) būsenoje nuo pat pradžių (bet mes to nežinojome), pirmo kubito matavimo būdo pasirinkimas negali turėti įtakos antram kubitui. Antraip matavimo krypties pasirinkimas turėtų būti komunikuojamas akimirksniu, greičiau už šviesos greitį. EPR paradoksas jau buvo patvirtintas ne kartą eksperimentuose naudojant supintąsias fotonų būsenas. Atstumai tarp dviejų lokacijų, kuriose susinchronizuotai tuo pačiu metu buvo matuojamos supintųjų fotonų būsenos, buvo tokie, kad šviesai neužtektų laiko komunikuoti matavimo rezultatus, kažkaip juos paveikiant. Pagal kvantinės mechanikos standartinę (ortodoksinę) interpretaciją, neįmanoma žinoti, kuris kvantinis „kamuolys” yra kurioje dėžutėje. Būsena \\(|\\chi^{+}\\rangle\\) nusako, kad jie yra abiejuose dėžutėse vienu metu. Tad pagal standartinę interpretaciją, EPR paradoksas neprieštarauja reliatyvumo teorijai, nes neįmanoma nuspėti, kokie bus pirmo kubito individualių matavimų rezultatai, žinomos tik tikimybės rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\). Todėl nusiųsti informaciją, užkoduotą kubitų būsenose, greičiau už šviesos greitį į planetą \\(W\\) neįmanoma, nes tiesiog negalime suformuluoti žinutės – jos turinys bus atsitiktinis. Tik patikrinę Žemėje ir planetoje \\(W\\) atliktų rezultatų statistiką matysime koreliaciją tarp matavimo rezultatų. Na, o norint palyginti rezultatus, tektų komunikuoti šviesos greičiu arba lėčiau, jeigu keliautume į planetą \\(W\\). "],["kvantiniai-loginiai-vartai-grandines.html", "4 skyrius. Kvantiniai loginiai vartai ir grandinės 4.1 Vieno kubito loginiai vartai 4.2 Kvantinių grandinių lygybės ir atvirkštiniai loginiai vartai 4.3 Kubitų būsenų matavimas 4.4 Dviejų kubitų loginiai vartai CNOT 4.5 Tofoli loginiai vartai 4.6 SWAP ir Fredkin loginiai vartai 4.7 Bendro tipo sąlyginiai loginiai vartai \\(\\boldsymbol{cU}\\) 4.8 Bendro tipo būsenų matavimai 4.9 Universalių loginių vartų rinkinys", " 4 skyrius. Kvantiniai loginiai vartai ir grandinės Šiame skyriuje pateikiame įprastinių kvantinių loginių elementų arsenalą. Juos pasitelkus formuojami žemiausio loginio lygio kvantiniai algoritmai. Matysime, kaip loginės registro būsenų operacijos yra pavaizduojamos grafiškai ir kaip iš jų sekų formuojamos kvantinės grandinės. 4.1 Vieno kubito loginiai vartai Pradėkime nuo paprasčiausių loginių elementų, atliekančių 1 kubito būsenų transformacijas. Kaip pamename, kvantiniai loginiai vartai yra nusakomi unitariniais operatoriais. Tokio operatoriaus veiksmas būsenai \\(|\\psi\\rangle\\) yra pavaizduojamas grafiškai (žr. 4.1 pav.). 4.1 pav. Loginių vartų \\(U\\) veiksmas kubito būsenai \\(|\\psi\\rangle\\). Kiekvienam kubitui yra priskiriama atskira grandis – horizontali linija. Kvantinė grandis pati nedaro įtakos kubito būsenai ir nusako jo laisvą evoliuciją laike. Grandys yra skaitomos iš kairės į dešinę ir atspindi laike atliekamas loginių vartų sekas. Kairėje pusėje nusakoma pradinė kubito būsena, čia \\(|\\psi\\rangle\\), jai atliekami loginiai vartai \\(U\\) ir dešinėje išvedama pakitusi būsena \\(U|\\psi\\rangle\\). Visi 1 kubito loginiai vartai turi vieną įvedimą ir vieną išvedimą, o bendras kubitų skaičius algoritmo metu nesikeičia. Žinoma, ne visi kubitai registre turi būti panaudojami. Čia pateikiame loginius vartus ir jų efektą skaičiuojamiesiems baziniams vektoriams \\(|0\\rangle\\) ir \\(|1\\rangle\\). Norint nusakyti, kaip loginiai vartai keičia kubito būseną, esančią superpozicijoje, pakanka žinoti, kaip loginiai vartai keičia \\(|0\\rangle\\) ir \\(|1\\rangle\\) atskirai, nes operatoriai veikia tiesiniu būdu kiekvieną vektorių superpozicijoje: \\[\\begin{equation} U\\big(|0\\rangle + |1\\rangle\\big) = U|0\\rangle + U|1\\rangle\\,. \\tag{4.1} \\end{equation}\\] Skaičiavimuose galima atlikti bazinių vektorių transformaciją ir naudoti kitų bazinių vektorių rinkinį, pavyzdžiui Pauli-\\(X\\) tikrinius vektorius \\(|0_x\\rangle\\) ir \\(|1_x\\rangle\\). Svarbu prisiminti, kad loginių vartų efektas, pateiktas \\(|0\\rangle\\) ir \\(|1\\rangle\\) baziniams vektoriams, bus bendrai kitoks, jeigu tie patys vartai pritaikomi, pavyzdžiui, \\(|0_x\\rangle\\) ir \\(|1_x\\rangle\\) ir jais išreikštoms būsenoms. 4.2 pav. matome dviejų kubitų registro kvantinės grandinės pavyzdį. 4.2 pav. 2 kubitų registro kvantinė grandinė. Matomi individualius kubitus veikiantys loginiai vartai ir abu kubitus vienu metu veikiantys \\(U_3\\) Standartiškai algoritmo pradžioje kubitai yra inicijuojami į \\(|0\\rangle\\) būsenas (nurodome ket juodame fone), o atskiri kubitai sunumeruojami simboliais \\(k_1, k_2,\\ldots\\) . Viršuje kubitui \\(k_1\\) yra atliekama 1 kubito loginių vartų seka \\(U_1\\), \\(U_2\\), abu kubitus veikiantis \\(U_3\\) ir galiausiai \\(U_4\\). Atkreipiame dėmesį, kad tiesinėje algebroje pirmo kubito loginių vartų sekos efektas yra apskaičiuojamas taip: \\(U_4 U_3 U_2 U_1 |0\\rangle\\). Tai yra, pirmiausiai operatorius \\(U_1\\) iš kairės daugina dešinėje vektorių \\(|0\\rangle\\), toliau jis dauginamas su \\(U_2\\), \\(U_3\\), ir galiausiai \\(U_4\\). Ši atvirkštinė tvarka tarp matematinio skaičiavimo ir atvaizdavimo kvantinėse grandinėse gali būti klaidinanti. Kadangi tai yra plačiai paplitusi ir standartine tapusi vartosena, šį skirtumą belieka tik įsiminti. Norėdami formaliai išsamiai aprašyti parodytas logines operacijas, veikiančias du kubitus \\(|k_1\\rangle\\otimes |k_2\\rangle\\), rašytume jas taip \\((U_4\\otimes U_4)(U_3)(U_2\\otimes I)(U_1\\otimes U_1)(|0\\rangle\\otimes |0\\rangle)\\). Operatorius \\(U_3\\) veikia abu kubitus, o \\(U_2\\) atlikimo metu kubitui \\(k_2\\) nepritaikoma jokia loginė operacija (laukimo stadija) – tai nusakoma vienetiniu operatoriumi \\(I\\). Pradėsime nuo Pauli-\\(X\\), \\(Y\\) ir \\(Z\\) loginių vartų, kurių matematinės išraiškos ir savybės buvo pristatytos II skyriuje. Pauli-\\(X\\) loginiai vartai yra klasikinių NE loginių vartų atitikmuo, jie sukeičia 0 ir 1 vertes (žr. 4.3 pav.) 4.3 pav. Pauli-\\(X\\) loginių vartų efektas skaičiuojamiesiems baziniams vektoriams Pauli-\\(Y\\) vartai taip pat sukeičia 0 ir 1 vertes, tačiau dar prideda \\(\\pm \\pi/2\\) fazę (\\(\\mathrm{e}^{\\pm\\mathrm{i}\\pi/2} = \\pm\\mathrm{i}\\)), nusakomą menamuoju skaičiumi \\(\\mathrm{i}\\) (žr. 4.4 pav.) 4.4 pav. Pauli-\\(Y\\) loginių vartų efektas Pauli-\\(Z\\) vartai (žr. 4.5 pav.) nekeičia įvedamos \\(|0\\rangle\\) būsenos, tačiau prideda \\(\\pi\\) fazę \\(|1\\rangle\\) būsenai (\\(\\mathrm{e}^{\\mathrm{i}\\pi} = -1\\)). 4.5 pav. Pauli-\\(Z\\) loginių vartų efektas Hadamardo vartai (žr. 4.6 pav.) suformuoja lygią \\(|0\\rangle\\) ir \\(|1\\rangle\\) bazinių vektorių superpoziciją. 4.6 pav. Hadamardo loginių vartų efektas skaičiuojamiesiems baziniams vektoriams Kaip pamename, Blocho sferoje 1 kubito būsena yra parametrizuojama dviem kampais \\(\\theta\\) ir \\(\\varphi\\). Čia \\(\\theta\\) nusako kampą su \\(z\\) ašimi, o \\(\\varphi\\) kampas yra skaičiuojamas nuo \\(x\\) ašies imant Blocho vektoriaus projekciją į \\(x\\)–\\(y\\) plokštumą. Tačiau praktikoje atliekant Blocho vektoriaus posūkius kvantiniame kompiuteryje yra dažnai naudojami loginiai vartai, kurie nusako posūkį apie vieną iš trijų Blocho sferos (\\(x, y, z\\)) ašių. Šie loginiai vartai yra vadinami \\(R_x(\\theta)\\), \\(R_y(\\theta)\\) ir \\(R_z(\\theta)\\), parametras \\(\\theta\\) nusako, kad posūkis atliekamas apie nurodytą ašį kampu \\(\\theta\\): \\[\\begin{align} R_{x}(\\theta) \\equiv &amp; \\mathrm{e}^{-\\frac{\\mathrm{i}\\theta X}{2}} = \\cos\\left(\\frac{\\theta}{2}\\right)I - \\mathrm{i}\\sin\\left(\\frac{\\theta}{2}\\right)X = \\begin{bmatrix} \\cos(\\theta/2) &amp; -\\mathrm{i}\\sin(\\theta/2) \\\\ -\\mathrm{i}\\sin(\\theta/2) &amp; \\cos(\\theta/2) \\\\ \\end{bmatrix}\\,;\\tag{4.2}\\\\ R_y(\\theta) \\equiv &amp; \\mathrm{e}^{-\\frac{\\mathrm{i}\\theta Y}{2}} = \\cos\\left(\\frac{\\theta}{2}\\right)I - \\mathrm{i}\\sin\\left(\\frac{\\theta}{2}\\right)Y = \\begin{bmatrix} \\cos(\\theta/2) &amp; -\\sin(\\theta/2) \\\\ \\sin(\\theta/2) &amp; \\cos(\\theta/2) \\\\ \\end{bmatrix}\\,;\\tag{4.3}\\\\ R_z(\\theta) \\equiv &amp; \\mathrm{e}^{-\\frac{\\mathrm{i}\\theta Z}{2}} = \\cos\\left(\\frac{\\theta}{2}\\right)I - \\mathrm{i}\\sin\\left(\\frac{\\theta}{2}\\right)Z = \\begin{bmatrix} \\mathrm{e}^{-\\frac{\\mathrm{i}\\theta}{2}} &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{\\frac{\\mathrm{i}\\theta}{2}} \\\\ \\end{bmatrix}\\,.\\tag{4.4} \\end{align}\\] Panagrinėkime šiek tiek plačiau \\(R_z(\\theta)\\) loginius vartus (žr. 4.7 pav.), kuriuos kvantinėje grandinėje ir supaprastinta matricos bei diadų forma išreiškiame: 4.7 pav. Posūkio apie Blocho sferos \\(z\\) ašį \\(R_z(\\theta)\\) loginių vartų efektas skaičiuojamiesiems baziniams vektoriams \\[\\begin{align} R_z(\\theta) \\equiv &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{\\mathrm{i}\\theta} \\\\ \\end{bmatrix}\\,;\\tag{4.5}\\\\ R_z(\\theta) = &amp; |0\\rangle\\langle 0| + \\mathrm{e}^{\\mathrm{i}\\theta}|1\\rangle\\langle 1|\\,.\\tag{4.6} \\end{align}\\] Supaprastinome \\(R_z(\\theta)\\) išraišką iškeldami bendrą \\(\\mathrm{e}^{-\\mathrm{i}\\theta/2}\\) narį, kurį toliau ištrynėme. Šį narį 1 kubito loginiuose vartuose galima ignoruoti, kadangi jis daugina bendrą kubito būseną ir nusako įtakos neturinčią globalią fazę. Dėl šio supaprastinimo kampas, kuriuo vartais \\(R_z(\\theta)\\) pasukamas Blocho vektorius apie \\(z\\) ašį, yra, kaip nurodyta, \\(\\theta\\), o ne \\(\\theta/2\\). Kaip matome, \\(R_z(\\theta)\\) neturi įtakos \\(|0\\rangle\\) būsenai, bet prideda fazę \\(\\theta\\) būsenai \\(|1\\rangle\\). Pavyzdžiui, jeigu ši būsena būtų \\(|\\psi\\rangle = a|0\\rangle + \\mathrm{e}^{\\mathrm{i}\\alpha}b|1\\rangle\\), tada \\(R_z(\\theta)|\\psi\\rangle = a|0\\rangle + \\mathrm{e}^{\\mathrm{i}(\\alpha + \\theta)} b|1\\rangle\\), tai yra \\(\\alpha \\rightarrow \\alpha + \\theta\\). Dėl šios savybės \\(R_z(\\theta)\\) yra dažnai vadinami 1 kubito fazės vartais (angl. phase gate). Pauli-\\(Z\\) loginiai vartai yra ne kas kita, kaip \\(R_z(\\theta)\\) su \\(\\theta=\\pi\\) (iki globalios fazės). Algoritmuose taip pat dažnai naudojami \\(R_z(\\pi/4)\\) ir \\(R_z(\\pi/2)\\), kurie standartiškai yra nurodomi raidėmis \\(T\\) ir \\(S\\), atitinkamai: \\[\\begin{align} T = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\pi/4} \\\\ \\end{bmatrix}\\,;\\tag{4.7} \\\\ S = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\pi/2} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\\\ \\end{bmatrix}\\,.\\tag{4.8} \\end{align}\\] Loginiai vartai \\(S\\) yra dar vadinami \\(\\sqrt{Z}\\), kadangi \\(S^2 = Z\\). Naudojant trijų operatorių su trimis skirtingais parametrais seką, \\(R_x(\\theta)R_y(\\gamma)R_z(\\varphi)\\), galima formaliai išreikšti bet kokią 1 kubito būsenos unitariąją transformaciją \\(U_3(\\theta,\\gamma,\\varphi)\\). Tačiau praktikoje dažniau aptinkamos vadinamosios Oilerio dekompozicijos \\(N\\)-\\(M\\)-\\(N\\) (angl. Euler decomposition), kuriose \\(N,M \\in \\{ R_z, R_y, R_z\\}\\). Pavyzdžiui, \\(Z\\)-\\(Y\\)-\\(Z\\) dekompozicija, naudojanti du skirtingus rotacijos operatorius: \\[\\begin{equation} U_3(\\theta,\\gamma,\\varphi) = R_z(\\theta)R_y(\\gamma)R_z(\\varphi) = \\begin{bmatrix} \\mathrm{e}^{-\\mathrm{i}(\\theta + \\varphi)/2}\\cos(\\gamma/2) &amp; -\\mathrm{e}^{\\mathrm{i}(-\\theta + \\varphi)/2}\\sin(\\gamma/2) \\\\ \\mathrm{e}^{\\mathrm{i}(\\theta - \\varphi)/2}\\sin(\\gamma/2) &amp; \\mathrm{e}^{\\mathrm{i}(\\theta + \\varphi)/2}\\cos(\\gamma/2) \\\\ \\end{bmatrix}\\,. \\tag{4.9} \\end{equation}\\] 4.2 Kvantinių grandinių lygybės ir atvirkštiniai loginiai vartai Yra begalė būdų pasukti vektorių Blocho sferoje į norimą orientaciją naudojant skirtingus loginius vartus. Pavyzdžiui, Hadamardo transformacija gali būti išreikšta rotacijų seka apie \\(x\\), \\(y\\), \\(z\\) ašis. Keletas būdų tai atlikti: \\[\\begin{align} H = &amp; R_x(\\pi)R_y\\left(-\\frac{\\pi}{2}\\right)\\,; \\tag{4.10}\\\\ H = &amp; R_x\\left(-\\frac{\\pi}{2}\\right)R_z\\left(-\\frac{\\pi}{2}\\right)\\,.\\tag{4.11} \\end{align}\\] Antrąją išraišką iliustruojame 4.8 pav., kaip trajektoriją Blocho sferos paviršiuje, pradedant nuo \\(|0\\rangle\\) būsenos iki galutinės \\(|0_x\\rangle\\). Atkreipiame dėmesį, kad žvelgiant į teigiamą \\(x\\), \\(y\\), ar \\(z\\) ašį nuo sferos centro į jos išorę, posūkis teigiamu kampu \\(+\\theta\\) apibūdinamas prieš laikrodžio rodyklę, o neigiamas \\(-\\theta\\) pagal laikrodžio rodyklę. 4.8 pav. Ekvivalentinis \\(H\\) loginės operacijos realizavimas naudojant rotacijos loginius vartus \\(R_x\\) ir \\(R_z\\) pavaizduojant kubito \\(|0\\rangle\\) vektoriaus sukimo trajektoriją Blocho sferoje. Šalia \\(x, y, z\\) ašių pažymėti atitinkami posūkio operatoriai ir nurodytos teigiamos \\(+\\theta\\) sukimo kryptys Skirtingose kvantinių procesorių architektūrose gali būti apribotas tam tikrų 1 kubito loginių vartų naudojimas. Todėl gali atsirasti poreikis sukompiliuoti kvantinę grandinę kitomis loginių vartų sekomis ar ją supaprastinti sumažinant bendrą loginių vartų skaičių. Pateikiame keletą svarbesnių 1 kubito loginių vartų lygybių pavyzdžių: \\[\\begin{align} HXH = &amp; Z\\,,\\quad HYH = -Y\\,,\\quad HZH = X\\,; \\tag{4.12}\\\\ ZXZ = &amp; -X\\,,\\quad ZYZ = -Y\\,,\\quad ZZZ = Z\\,;\\tag{4.13} \\\\ SXS^{\\dagger} = &amp; Y\\,,\\quad SYS^{\\dagger} = -X\\,,\\quad SZS^{\\dagger} = Z\\,.\\tag{4.14} \\end{align}\\] Kaip galime pastebėti, viršuje pateikiamos tokios operatorių sekos: \\(KPK^{\\dagger} = P&#39;\\). Čia \\(P\\) ir \\(P&#39;\\) yra Pauli operatoriai {\\(X\\), \\(Y\\), \\(Z\\)}, o \\(K\\) ir ermitinė jungtis \\(K^{\\dagger}\\) yra parenkama iš vadinamosios Klifordo grupės (angl. Clifford group) operatorių. Įprasti 1 kubito Klifordo grupės operatoriai yra Pauli {\\(I\\), \\(X\\), \\(Y\\), \\(Z\\)}, taip pat \\(H\\) ir \\(S\\). Viena iš Klifordo grupės savybių yra ta, kad jie transformuoja vieną Pauli operatorių į kitą ir gali pridėti tik fazę \\(\\pm 1\\). Ši operatorių grupė yra itin svarbi kvantiniuose algoritmuose bei klaidų taisymo koduose, pagrįstuose būsenų stabilizatoriais. Atkreipiame dėmesį, kad vien Klifordo vartais \\(H\\) ir \\(S\\) galima realizuoti Pauli operatorius {\\(X\\), \\(Y\\), \\(Z\\)}: \\[\\begin{equation} HSSH = X\\,,\\quad SXS^{\\dagger} = Y\\,,\\quad SS = Z\\,. \\tag{4.15} \\end{equation}\\] Norėdami patikrinti, ar lygybės egzistuoja tarp skirtingų vartų sekų, galime jas nusakančias matricas papračiausiai sudauginti ir palyginti, ar jos vienodos, pavyzdžiui: \\[\\begin{equation} HXH = \\frac{1}{2}\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; - 1 \\\\ \\end{bmatrix} \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; - 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; - 1 \\\\ \\end{bmatrix} = Z\\,. \\tag{4.16} \\end{equation}\\] Klifordo vartais taip pat galima tarpusavyje transformuoti tolydžiai parametrizuotus loginius vartus \\(R_z(\\theta)\\) ir \\(R_x(\\theta)\\): \\[\\begin{equation} HR_z(\\theta)H = R_x(\\theta)\\,. \\tag{4.17} \\end{equation}\\] Naudodami matricų funkcijos \\(R_z(\\theta)\\) išraišką, lygybę viršuje patikriname: \\[\\begin{equation} \\begin{aligned} H\\big\\lbrack \\cos(\\theta/2)I - \\mathrm{i}\\sin(\\theta/2)Z \\big\\rbrack H = &amp; \\cos(\\theta/2)HIH - \\mathrm{i}\\sin(\\theta/2)HZH \\\\ = &amp; \\cos(\\theta/2)I - \\mathrm{i}\\sin(\\theta/2)X = R_x(\\theta)\\,. \\end{aligned} \\tag{4.18} \\end{equation}\\] Trys Pauli bei Hadamardo loginiai vartai yra ermitiniai operatoriai (\\(U=U^{\\dagger}\\)) ir todėl patys sau atvirkštiniai. Atliekant du ermitinius operatorius vieną po kito anuliuojamas jų efektas, pavyzdžiui, \\(ZZ = I\\), \\(HH = I\\). Kitaip nei Pauli ir Hadamardo vartai, dauguma kitų kvantinių loginių vartų nėra sau atvirkštiniai. Pavyzdžiui, jau minėti \\(S\\) ir \\(T\\) nėra ermitiniai operatoriai, nes \\(S\\ne S^{\\dagger}\\) ir \\(T\\ne T^{\\dagger}\\). Tačiau, kaip ir visi unitariniai operatoriai, jie turi sau atvirkštinius operatorius. Tai yra jų ermitinės jungties operatoriai, žymimi su durklu, pavyzdžiui \\(T^{\\dagger}\\) ir \\(S^{\\dagger}\\): \\[\\begin{align} T^{\\dagger} = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\pi/4} \\\\ \\end{bmatrix}\\,; \\tag{4.19}\\\\ S^{\\dagger} = &amp; \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\pi/2} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; -\\mathrm{i} \\\\ \\end{bmatrix}\\,.\\tag{4.20} \\end{align}\\] Matome, kad ermitinėje jungtyje atsiranda minuso ženklas prie nario, nusakančio kampą. Atvirkštinių vartų efektą galima interpretuoti kaip Blocho vektoriaus sukimą apie tą pačią ašį priešinga kryptimi tokiu pačiu kampu. Dėl šios priežasties atlikus operaciją \\(UU^{\\dagger}|\\psi\\rangle = I|\\psi\\rangle = |\\psi\\rangle\\) būsena nepakinta. Tai savo ruožtu reiškia, kad kvantinėse transformacijose, nusakytose unitariaisiais operatoriais, visada įmanoma grąžinti kvantinę būseną į pradinę (kitaip tariant, atsukti laiką atgal). Tam tereikia atlikti atvirkštinius loginius vartus atbuline seka. 4.3 Kubitų būsenų matavimas Norint sužinoti kubito būseną, algoritmo vykdymo metu ar jo pabaigoje atliekamas matavimas. Matavimo operacija yra žymima pusapskritimiu su rodyklyte, nukreipta į klasikinį registrą, žymimą brūkšniuota linija ir raide \\(c\\). Taip pat taikomas principas, kad algoritmo gale visi kubitai yra pamatuojami, net jeigu tai nėra parodoma simboliais kvantinės grandinės pabaigoje. Matavimai standartiškai atliekami santykinai su Pauli-\\(Z\\) operatoriaus tikriniais vektoriais, tai yra skaičiuojamaisiais baziniais vektoriais \\(|0\\rangle\\) ir \\(|1\\rangle\\). Esant šių bazinių vektorių superpozicijos būsenai, galimi matavimo rezultatai yra Pauli-\\(Z\\) tikrinės vertės +1 arba -1. Radus +1 indikuojama, kad būsena yra \\(|0\\rangle\\), bei \\(|1\\rangle\\), jeigu tikrinė vertė yra -1. Tai nusako vieną klasikinį bitą informacijos, o atlikus matavimą gautas rezultatas yra įrašomas klaisikiniame bitų registre. 4.9 pav. Loginė grandinė sukuria kubito \\(k_1\\) lygią superpoziciją ir atlieka jo būsenos matavimą. Rezultatas įrašomas klasikiniame registre \\(c\\) Grandinėje 4.9 pav. yra pateiktas vienas iš paprasčiausių praktinės svarbos kvantinių algoritmų, kuris atlieka atsitiktinių skaičių generavimą (angl. random number generator). Atlikę Hadamardo transformaciją gauname lygią superpoziciją: \\[\\begin{equation} H|0\\rangle = \\frac{1}{\\sqrt{2}}\\big( |0\\rangle + |1\\rangle \\big)\\,. \\tag{4.21} \\end{equation}\\] Pamatavus šią būseną tikimybės rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\) yra lygios: \\[\\begin{equation} \\big|\\langle 0|\\psi\\rangle\\big|^2 = \\big|\\langle 1|\\psi\\rangle\\big|^2 = \\frac{1}{2}\\,. \\tag{4.22} \\end{equation}\\] Tad po kiekvieno šio algoritmo įvykdymo yra sugeneruojama atsitiktinė dvejetainė 0 ir 1 skaičių seka. Dėl kvantinio atsitiktinumo matavimo procese, šios sekos fundamentaliai neįmanoma nuspėti. 4.4 Dviejų kubitų loginiai vartai CNOT Dviejų kubitų vartai, veikdami \\(|k_1\\rangle\\otimes |k_2\\rangle\\) būseną, atlieka sąlygines logines operacijas: „Jeigu kubitas \\(k_1\\) yra būsenoje \\(|x\\rangle\\), tada su kubitu \\(k_2\\) atliekama operacija \\(U\\)“. Čia \\(U\\) gali būti bet kokia 1 kubito būsenos unitarioji transformacija. Vienas iš plačiausiai naudojamų 2 kubitų vartų yra CNOT (angl. controlled not, trumpinys CNOT), kuriuos grandinėse vadinsime \\(cX\\). Pasirinktas pirmas kubitas yra naudojamas kaip kontrolinis (angl. control), nuo kurio būsenos priklauso ar antram, adresatiniam kubitui, bus taikomi Pauli-\\(X\\) loginiai vartai. Vartai \\(cX\\) yra iliustruojami 4.10 pav. 4.10 pav. 2 kubitų sąlyginiai loginiai vartai \\(cX\\) (arba CNOT) CNOT vartus galime išreikšti diadomis ir matricos forma: \\[\\begin{align} cX = &amp;|0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes X\\,;\\tag{4.23}\\\\ cX = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}\\,.\\tag{4.24} \\end{align}\\] Kaip pavyzdį imkime \\(cX\\), kuriame pirmas kubitas yra kontrolinis, ir pritaikykime jį \\(|1\\rangle\\otimes|0\\rangle\\) būsenai: \\[\\begin{align} cX|1\\rangle\\otimes|0\\rangle = &amp; |0\\rangle\\langle 0|1\\rangle\\otimes I|0\\rangle + |1\\rangle\\langle 1|1\\rangle\\otimes X|0\\rangle = |1\\rangle\\otimes X|0\\rangle = |1\\rangle\\otimes|1\\rangle\\,;\\tag{4.25}\\\\ cX|1\\rangle\\otimes|0\\rangle = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}\\,.\\tag{4.26} \\end{align}\\] Apibendrinus, \\(cX\\) vartų efektas 2 kubitų skaičiuojamiesiems baziniams vektoriams: \\[\\begin{align} cX|0\\rangle\\otimes|0\\rangle = &amp; |0\\rangle\\otimes|0\\rangle\\,;\\tag{4.27} \\\\ cX|0\\rangle\\otimes|1\\rangle = &amp; |0\\rangle\\otimes|1\\rangle\\,;\\tag{4.28} \\\\ cX|1\\rangle\\otimes|0\\rangle = &amp; |1\\rangle\\otimes|1\\rangle\\,;\\tag{4.29} \\\\ cX|1\\rangle\\otimes|1\\rangle = &amp; |1\\rangle\\otimes|0\\rangle\\,.\\tag{4.30} \\end{align}\\] Matome, kad kai kontrolinis kubitas yra \\(|0\\rangle\\), antro kubito būsena nesikeičia, o jeigu kontrolinis kubitas yra \\(|1\\rangle\\), antro kubito vertė apverčiama. Tai lengva pamatyti žvelgiant į diadų formą, kurioje Pauli-\\(X\\) vartai veikia kartu tik su pirmo kubito \\(|1\\rangle\\) būsena. \\(cX\\) vartų efektą baziniams vektoriams galima interpretuoti ir kaip modulio(2) bitų sudėtį (\\(0 + 0 = 0\\), \\(0 + 1 = 1\\), \\(1 + 0 = 1\\), \\(1 + 1 = 0\\)), naudojančią simbolį \\(\\oplus\\). Pritaikius \\(cX\\) tarp kubitų \\(k_1\\) ir \\(k_2\\), kurių vertės yra bet kuri iš 0 ir 1 kombinacijų, tada mod(2) sudėtis yra užrašoma antro kubito būsenoje: \\[\\begin{equation} cX|k_1 \\rangle\\otimes |k_2 \\rangle = |k_1 \\rangle\\otimes |k_1 \\oplus k_2 \\rangle\\,. \\tag{4.31} \\end{equation}\\] Galima atsakymą užrašyti ir pirmo kubito būsenoje naudojant \\(cX\\) vartus, kuriuose antras kubitas yra kontrolinis, o pirmas adresatinis. Norint aiškiau pateikti matematines lygtis gali būti pravartu indikuoti operatoriuose kontrolinį ir adresatinį kubitus. Šioje knygoje, kai bus tą pravartu daryti, CNOT vartuose nurodysime kaip pirmą skaičių kontrolinį kubitą, antrą adresatinį, pavyzdžiui \\(cX_{12}\\). Formulėse (4.23)–(4.24) pateikėme diadų ir matricų formas \\(cX_{12}\\), sukeitus juos vietomis, \\(cX_{21}\\), atitinkamai pasikeistų ir matematinės išraiškos: \\[\\begin{align} cX_{21} = &amp; I\\otimes|0\\rangle\\langle 0| + X\\otimes|1\\rangle\\langle 1|\\,;\\tag{4.32}\\\\ cX_{21} = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\,.\\tag{4.33} \\end{align}\\] Matėme, kaip 2 kubitų būsena keičiasi pritaikius \\(cX\\), kai kubitai yra viename iš bazinių vektorių. Gauti rezultatai yra identiški klasikiniams \\(cX\\) vartams. Tačiau kvantinėje kompiuterijoje kontrolinio kubito būsena gali būti \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijoje. Koks yra \\(cX\\) efektas, šiuo atveju panagrinėsime žvelgdami į 4.11 pav. grandinę. 4.11 pav. Kvantinį 2 kubitų supynimą atliekanti grandinė Po Hadamardo transformacijos kontrolinis \\(k_1\\) kubitas yra lygioje superpozicijoje. Toliau yra \\(cX\\) vartai, kurie veikia tiesiškai kiekvieną narį superpozicijos būsenoje: \\[\\begin{equation} \\begin{aligned} cX\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|0\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(cX|0\\rangle\\otimes|0\\rangle + cX|1\\rangle\\otimes|0\\rangle\\big) \\\\ = &amp; \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|0\\rangle + |1\\rangle\\otimes|1\\rangle\\big)\\,. \\end{aligned} \\tag{4.34} \\end{equation}\\] Matome, kad po šių dviejų loginių vartų sekos gavome supintą 2 kubitų būseną \\(|\\chi^{+}\\rangle\\) Belo bazinį vektorių. Naudojant Hadamardo ir \\(cX\\) vartus šia tvarka galima unikaliai konvertuoti skaičiuojamuosius 2 kubitų bazinius vektorius į Belo bazinius vektorius: \\[\\begin{equation} |00 \\rangle \\rightarrow |\\chi^{+}\\rangle\\,,\\quad |10 \\rangle \\rightarrow |\\chi^{-}\\rangle\\,,\\quad |01 \\rangle \\rightarrow |\\eta^{+}\\rangle\\,,\\quad |11 \\rangle \\rightarrow |\\eta^{-}\\rangle\\,. \\tag{4.35} \\end{equation}\\] Pavyzdžiui, norėdami paruošti Belo \\(|\\eta^{-}\\rangle\\) būseną, pirmiausia pakeičiame \\(k_1\\) ir \\(k_2\\) pradines būsenas į \\(|11\\rangle\\) naudodami Pauli-\\(X\\) vartus ir tada vėl atliekame \\(H\\) ir \\(cX\\). Kadangi \\(cX\\) operatorius yra ermitinis, atlikus vieną po kito du \\(cX\\) su tais pačiais kontroliniu ir adresatiniu kubitais, jų būsenos nepakinta. Kvantinio supynimo panaikinimas tarp dviejų kubitų taip pat yra atliekamas naudojant \\(cX\\) vartus. Pavyzdžiui, atliekant \\(cX\\) vartus supintajai \\(|\\chi^{+}\\rangle\\) Belo būsenai supynimas yra panaikinamas ir grįžtame į faktorizuojamąją būseną: \\[\\begin{equation} cX|\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes |0\\rangle\\,. \\tag{4.36} \\end{equation}\\] 4.12 pav. Kvantinį 2 kubitų supynimą atliekanti grandinė Kita gerai žinoma visiškai supinta 3 kubitų GHZ būseną (angl. Greenberger-Horne-Zeilinger) galima gauti atlikę 4.12 pav. parodytą grandinę. 4.13 pav. 2 kubitų salyginių loginių vartų \\(cX\\) variacija, kurioje antro kubito būsena keičiama, jeigu pirmojo būsena \\(|0\\rangle\\) \\[\\begin{equation} |\\mathrm{GHZ}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|000\\rangle +|111\\rangle\\big)\\,. \\tag{4.37} \\end{equation}\\] Užbaigdami šį poskyrį paminėsime naudingą \\(cX\\) loginių vartų variaciją, kurioje adresatiniam kubitui pritaikomi Pauli-\\(X\\) vartai, jeigu kontrolinio kubito būsena yra \\(|0\\rangle\\), o ne \\(|1\\rangle\\). Šio operatoriaus, vadinsime jį \\(cX_0\\), išraiška yra: \\[\\begin{equation} cX_0 = |0\\rangle\\langle 0|\\otimes X + |1\\rangle\\langle 1|\\otimes I\\,. \\tag{4.38} \\end{equation}\\] Kvantinėje grandinėje \\(cX_0\\) vartai yra žymimi su tuščiu apskritimu kontroliniame kubite, bei gali būti paprastai konvertuojami iš standartinio \\(cX\\) pasitelkiant dvejus Pauli-\\(X\\) vartus (žr. 4.13 pav.). Pirmieji Pauli-\\(X\\) sukeičia kontrolinio kubito būsenas \\(|0\\rangle \\leftrightarrow |1\\rangle\\), o antrieji atstato jas atgal po atliktų standartinių \\(cX\\). 4.5 Tofoli loginiai vartai Trijų kubitų sąlyginiai loginiai vartai, kuriuose du kubitai naudojami kaip kontroliniai, yra vadinami CCNOT (angl. controlled controlled NOT, trumpinys CCNOT) ir yra geriau žinomi, kaip Tofoli vartai (angl. Toffoli). Grandinėse juos žymėsime \\(ccX\\). Kubito vertė yra apverčiama, jeigu abu kontroliniai kubitai yra \\(|1\\rangle\\) būsenose. 4.14 pav. iliustruojame šiuos vartus, veikiančius būseną \\(|k_1\\rangle\\otimes|k_2\\rangle\\otimes|k_3\\rangle\\) su \\(k_1\\) ir \\(k_2\\) kontroliniais bei \\(k_3\\) adresatiniu kubitu. Išreiškus \\(ccX\\) vartus diadomis: \\[\\begin{equation} ccX = \\big(|00\\rangle\\langle 00| +|01\\rangle\\langle 10| + |10\\rangle\\langle 01|\\big) \\otimes I + |11\\rangle\\langle 11|\\otimes X\\,. \\tag{4.39} \\end{equation}\\] Kvantiniuose kompiuteriuose \\(ccX\\) vartai paprastai nėra elementarūs, tačiau sukompiliuojami iš 1 kubito ir 2 kubitų loginių vartų sekų. 4.14 pav. Toffoli loginiai vartai 4.6 SWAP ir Fredkin loginiai vartai Loginiai vartai SWAP, grandinėse žymimi sutrumpintai \\(W\\), veikdami tarp dviejų kubitų \\(k_1\\) ir \\(k_2\\) sukeičia jų būsenas vietomis: \\[\\begin{equation} W|\\psi_1\\rangle\\otimes |\\psi_2\\rangle = |\\psi_2\\rangle\\otimes |\\psi_1\\rangle\\,. \\tag{4.40} \\end{equation}\\] Šie loginiai vartai efektyviai sukeičia kubitus vietomis ir todėl gali būti naudojami pergrupuoti kubitus registre. Tai yra itin naudinga situacijose, kuriuose kvantinis procesorius neturi fizinės galimybės atlikti, pavyzdžiui, \\(cX\\) loginių vartų tarp tam tikrų kubitų porų. Siekiant apeiti šį apribojimą galima naudoti SWAP operacijas kaskadų principu sukeičiant kubitų pozicijas į vietas, kuriuose \\(cX\\) loginiai vartai yra leidžiami, bei vėl grąžinti kubitus į pradines pozicijas. Šiuos vartus galima išreikšti diadomis arba matricos pavidalu taip: \\[\\begin{align} W = &amp; |0\\rangle\\otimes|0\\rangle\\langle 0|\\otimes\\langle 0| + |0\\rangle\\otimes|1\\rangle\\langle 1|\\otimes\\langle 0| + |1\\rangle\\otimes|0\\rangle\\langle 0|\\otimes\\langle 1| + |1\\rangle\\otimes|1\\rangle\\langle 1|\\otimes\\langle 1| \\nonumber\\\\ = &amp; |00\\rangle\\langle 00| + |01\\rangle\\langle 10| + |10\\rangle\\langle 01| + |11\\rangle\\langle 11|\\,; \\tag{4.41} \\\\ W = &amp;\\begin{bmatrix} \\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\\\ \\end{matrix} &amp; \\begin{matrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\\\ \\end{matrix} \\\\ \\begin{matrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\\\ \\end{matrix} &amp; \\begin{matrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{matrix} \\\\ \\end{bmatrix}\\,. \\tag{4.42} \\end{align}\\] SWAP vartai iliustruojami 4.15 pav. 4.15 pav. SWAP loginiai vartai SWAP taip pat galima įkomponuoti į sąlyginius loginius vartus, kurie yra vadinami Fredkin vartais. Lygtyse juos žymėsime \\(cW\\). 4.16 pav. pavaizduoti Fredkin vartai sukeičia kubitų \\(k_2\\) ir \\(k_3\\) būsenas, jeigu kontrolinis kubitas \\(k_1\\) yra būsenoje \\(|1\\rangle\\). \\[\\begin{equation} cW = |0\\rangle\\langle 0|\\otimes I\\otimes I + |1\\rangle\\langle 1|\\otimes W\\,. \\tag{4.43} \\end{equation}\\] 4.16 pav. Fredkin, arba kontroliuojami SWAP, loginiai vartai Kaip ir Tofoli loginiai vartai, SWAP bei Fredkin paprastai nėra elementarios kubitų transformacijos fiziniame lygmenyje, tačiau yra konstruojami iš 1 kubito ir 2 kubitų loginių vartų sekų. Vienas būdas atlikti SWAP 2 kubitų būsenai naudojant \\(cX\\) vartus parodytas 4.17 pav.: 4.17 pav. SWAP loginių vartų realizavimas pasitelkiant tris cX loginius vartus 4.7 Bendro tipo sąlyginiai loginiai vartai \\(\\boldsymbol{cU}\\) Bendro tipo 2 kubitų sąlyginiuose vartuose \\(cU\\) adresatiniam kubitui pritaikoma bet kokia 1 kubito unitarinė transformacija \\(U\\), jeigu pirmas kubitas yra \\(|1\\rangle\\) būsenoje. Šiuos vartus diadų forma ir grandinėje išreiškiame: \\[\\begin{equation} cU = |0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes U\\,. \\tag{4.44} \\end{equation}\\] 4.18 pav. Bendro tipo 2 kubitų loginiai vartai \\(cU\\), kuriuose antram kubitui pritaikomi bendro tipo 1 kubito loginiai vartai \\(U\\), kontroliuojant pirmu kubitu Prieš pereidami prie kitų temų, atkreipsime dėmesį į 1 kubito globalios fazės svarbą 2 kubitų (ir bendrai \\(n\\) kubitų) loginiuose vartuose. Bendro tipo 2 kubitų transformacijose \\(cU\\) globali pavienių kubitų fazė tampa svarbi santykinė fazė tarp atskirų kubitų. Kaip matėme šio skyriaus pirmoje dalyje, bendriausio tipo 1-kubito loginius vartus \\(U_3(\\theta,\\gamma,\\varphi)\\) galime išreikšti tokia matricos forma: \\[\\begin{equation} U_3 = \\begin{bmatrix} a &amp; - b^{*} \\\\ b &amp; a^{*} \\end{bmatrix}\\,. \\tag{4.45} \\end{equation}\\] Čia \\(a\\) ir \\(b\\) yra kompleksiniai skaičiai, o matricos \\(U_3\\) determinantas \\(\\det U_3 = |a|^{2} + |b|^{2} = 1\\). Visos unitarinės \\((2 \\times 2)\\) dydžio matricos \\(U\\), kurių determinantas lygus vienetui, sudaro specialiają unitarinių matricų grupę \\(\\mathrm{SU}(2)\\). Ši grupė išsamiai apibūdina visas 1 kubito transformacijas, tačiau yra platesnės unitarinių matricų \\(\\mathrm{U}(2)\\) grupės pogrupis, \\(\\mathrm{SU}(2) \\subset \\mathrm{U}(2)\\). Unitarinę matricą \\(U\\), priklausančią \\(\\mathrm{U}(2)\\), galime išreikšti sudauginant \\(\\mathrm{SU}(2)\\) matricą \\(V\\) su fazės nariu, \\(U = \\mathrm{e}^{\\mathrm{i}\\eta}V\\). Globalios fazės narys \\(\\mathrm{e}^{\\mathrm{i}\\eta}\\), veikiantis 1 kubito būseną nedaro fizinės įtakos, nes \\(\\mathrm{e}^{\\mathrm{i}\\eta}V|\\psi\\rangle = V|\\psi\\rangle\\). Todėl jį 1-kubito transformacijose ignoruojame. Tačiau sąlyginiuose 2 kubitų loginiuose vartuose unitarinė (1 kubito) transformacija \\(U\\), pritaikoma adresatiniam kubitui, gali priklausyti \\(U \\in \\mathrm{U}(2)\\), o ne \\(U \\in \\mathrm{SU}(2)\\) grupei. Pabrėždami šį aspektą toliau pateikiame sąlyginius posūkio apie \\(z\\) ašį vartus \\(cR_z(\\theta)\\) bei fazės vartus \\(cP(\\theta)\\) (angl. controlled phase gate). Vartai \\(cR_z(\\theta)\\) pritaiko antram kubitui posūkio operatorių \\(R_z(\\theta)\\), jeigu pirmojo būsena yra \\(|1\\rangle\\). Grandinėje, diadų ir matricos formoje \\(cR_{z}(\\theta)\\) atrodo taip (žr. 4.19 pav.): 4.19 pav. Salyginiai 2 kubitų loginiai vartai \\(cR_z(\\theta)\\) \\[\\begin{align} cR_z(\\theta) = &amp; |0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes R_z(\\theta)\\,; \\tag{4.46} \\\\ cR_{z}(\\theta) = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\theta/2} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}\\theta/2} \\\\ \\end{bmatrix}\\,. \\tag{4.47} \\end{align}\\] Pritaikę \\(cR_z(\\theta)\\) 2 kubitų bazinių vektorių superpozicijos būsenai \\(|\\psi\\rangle = \\big(|00\\rangle + |10\\rangle + |01\\rangle + |11\\rangle\\big)/2\\) randame: \\[\\begin{equation} \\begin{aligned} cR_z(\\theta)|\\psi\\rangle = &amp; \\frac{1}{2}\\Big\\lbrack \\big(|00\\rangle + |01\\rangle\\big) + |1\\rangle\\otimes R_z(\\theta)\\big(|0\\rangle + |1\\rangle\\big)\\Big\\rbrack \\\\ = &amp; \\frac{1}{2}\\left\\lbrack |00\\rangle + \\mathrm{e}^{-\\mathrm{i}\\theta/2}|10\\rangle + |01\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta/2}|11\\rangle \\right\\rbrack\\,. \\end{aligned} \\tag{4.48} \\end{equation}\\] Šio skyriaus pirmoje dalyje analizuodami 1 kubito vartus \\(R_z(\\theta)\\) iškėlėme fazės narį \\(\\mathrm{e}^{-\\mathrm{i}\\theta/2}\\). Tačiau šioje situacijoje \\(\\mathrm{e}^{-\\mathrm{i}\\theta/2}\\) nusako svarbią santykinę fazę tarp 2 kubitų bazinių vektorių, o ne globalią visos 2 kubitų būsenos \\(|\\psi\\rangle\\) fazę. Globali 2 kubitų fazė būtų vėlgi būtų nusakoma \\(\\mathrm{e}^{\\mathrm{i}\\eta}\\), dauginančiu visą \\(|\\psi\\rangle\\) būseną kartu. Sąlyginiai fazės vartai \\(cP(\\theta)\\) matricos forma atrodo taip: \\[\\begin{equation} cP(\\theta) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}\\theta} \\\\ \\end{bmatrix}\\,. \\tag{4.49} \\end{equation}\\] Pritaikę juos tai pačiai visų 2 kubitų bazinių vektorių superpozicijos būsenai \\(|\\psi\\rangle\\) randame, kad fazė suteikiama tik \\(|11\\rangle\\) baziniam vektoriui: \\[\\begin{equation} cP(\\theta)|\\psi\\rangle = \\frac{1}{2}\\big\\lbrack |00\\rangle + |10\\rangle + |01\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta}|11\\rangle\\big\\rbrack\\,. \\tag{4.50} \\end{equation}\\] Vartų \\(cP(\\theta)\\) efektas skiriasi nuo \\(cR_z(\\theta)\\) santykine 2 kubitų faze, kuri yra „globali” antrojo kubito fazė. Norėdami formaliau perteikti 1 kubito „globalią” fazę \\(\\mathrm{e}^{\\mathrm{i}\\eta}\\), tokius 1 kubito fazės vartus žymime \\(\\Phi(\\eta)\\): \\[\\begin{equation} \\Phi(\\eta) = \\begin{bmatrix} \\mathrm{e}^{\\mathrm{i}\\eta} &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{\\mathrm{i}\\eta} \\\\ \\end{bmatrix} = \\mathrm{e}^{\\mathrm{i}\\eta}\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix} = \\mathrm{e}^{\\mathrm{i}\\eta}I\\,. \\tag{4.51} \\end{equation}\\] Sąlyginiai \\(c\\Phi(\\eta)\\) vartai, kurie perteikia „globalią” \\(\\mathrm{e}^{\\mathrm{i}\\eta}\\) fazę adresatinio kubito \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenoms, jeigu kontrolinis kubitas \\(|1\\rangle\\) būsenoje, yra: \\[\\begin{align} c\\Phi(\\eta) = &amp; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{\\mathrm{i}\\eta} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}\\eta} \\end{bmatrix}\\,; \\tag{4.52} \\\\ c\\Phi(\\eta) = &amp; |0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes\\Phi(\\eta) = \\big( |0\\rangle\\langle 0| + \\mathrm{e}^{\\mathrm{i}\\eta}|1\\rangle\\langle 1| \\big)\\otimes I\\,. \\tag{4.53} \\end{align}\\] Iš diadinės \\(c\\Phi(\\eta)\\) dekompozicijos galima atkreipti dėmesį, kad iš tiesų nereikia vykdyti 2 kubitų sąlyginių vartų. Šie loginiai vartai susiprastina į 1 kubito loginius vartus, veikiančius vien kontrolinį kubitą, su identitetu \\(\\otimes I\\) adresatiniam kubitui: \\[\\begin{equation} \\begin{aligned} \\Phi(\\eta/2)R_z(\\eta) = &amp; \\big(\\mathrm{e}^{\\mathrm{i}\\eta/2}|0\\rangle\\langle 0| + \\mathrm{e}^{\\mathrm{i}\\eta/2}|1\\rangle\\langle 1|\\big) \\big(\\mathrm{e}^{-\\mathrm{i}\\eta/2}|0\\rangle\\langle 0| + \\mathrm{e}^{\\mathrm{i}\\eta/2}|1\\rangle\\langle 1|\\big) \\\\ = &amp; |0\\rangle\\langle 0| + \\mathrm{e}^{\\mathrm{i}\\eta}|1\\rangle\\langle 1|\\,. \\end{aligned} \\tag{4.54} \\end{equation}\\] Tad sąlyginius 2 kubitų fazės vartus \\(c\\Phi(\\eta)\\) galime perteikti 1 kubito vartais, \\(\\Phi(\\eta/2)R_z(\\eta) \\equiv D\\): \\[\\begin{equation} c\\Phi(\\eta) = D\\otimes I\\,. \\tag{4.55} \\end{equation}\\] Dabar akivaizdu, kad sąlyginius 2 kubitų santykinės fazės vartus \\(cP(\\theta)\\) galime realizuoti pasitelkdami \\(cR_z(\\theta)\\) ir \\(c\\Phi(\\eta)\\). (4.48) lygtyje gautai būsenai \\(cR_z(\\theta)|\\psi\\rangle\\) pritaikome \\(c\\Phi(\\eta)\\) su faze \\(\\eta = \\theta/2\\): \\[\\begin{equation} c\\Phi(\\theta/2)cR_z(\\theta)|\\psi\\rangle = cP(\\theta)|\\psi\\rangle\\,. \\tag{4.56} \\end{equation}\\] Realiame kvantiniame kompiuteryje 2 kubitų sąlyginių loginių vartų asortimentas gali būti itin ribotas, o bendro tipo sąlyginiai vartai \\(cU\\) yra veikiau aukštesnio lygio loginių operacijų abstrakcija. Šios operacijos bus sudarytos iš kvantiniame kompiuteryje prieinamų elementariųjų loginių vartų. Dažnai daroma prielaida, kad iš 2 kubitų vartų yra prieinami tik \\(cX\\). Tad norint įvykdyti visas įmanomas \\(n\\) kubitų registro transformacijas universaliame kompiuteryje reikalingas būdas, kaip perteikti \\(cU\\) naudojant tik 1 kubito bendrus loginius vartus bei \\(cX\\). Pirma dekompozicija, realizuojanti \\(cU\\), yra: \\[\\begin{equation} cU = AcXBcXC\\,. \\tag{4.57} \\end{equation}\\] Čia \\(A\\), \\(B\\) ir \\(C\\) yra 1 kubito loginiai vartai, kurie veikdami būseną \\(|\\psi\\rangle\\) tenkina lygybę \\(ABC|\\psi\\rangle = I|\\psi\\rangle\\). Ši dekompozicija yra pagrįsta teiginiu, kad bet kokį 1 kubito operatorių \\(U \\in \\mathrm{SU}(2)\\) galima išreikšti \\(U = AXBXC\\). Operatoriai \\(A\\), \\(B\\), \\(C\\) turi būti rasti kiekvienam norimam \\(U\\) ir yra bendrai sudaryti iš posūkio operatorių \\(R_x(\\theta)\\), \\(R_y(\\theta)\\), \\(R_z(\\theta)\\). 4.20 pav. Sąlyginių loginių vartų \\(cU\\) realizavimas naudojant ABC dekompoziciją 4.20 pav. grandinėje matome, kad jeigu kontrolinis kubitas yra \\(|0\\rangle\\) būsenoje, tada adresatiniam kubitui pritaikomi paeiliui trys operatoriai, \\(ABC|\\psi\\rangle = I|\\psi\\rangle\\) ir todėl nepakeičia jo būsenos. O štai jeigu kontrolinis kubitas yra \\(|1\\rangle\\) būsenoje, \\(AXBXC|\\psi\\rangle = U|\\psi\\rangle\\), kaip ir norima. Taip pat, jeigu sąlyginiuose vartuose \\(cU\\) unitarusis operatorius \\(U \\in \\mathrm{U}(2)\\), tada \\((D\\otimes I)AXBXC|\\psi\\rangle = U|\\psi\\rangle\\). Papildomi fazės vartai \\(D\\), veikiantys kontrolinį kubitą šios grandinės pabaigoje, leidžia teisingai perteikti norimą santykinę 2 kubitų būsenos fazę. Loginiuose vartuose gali būti daugiau nei vienas kontrolinis kubitas. Ši aukštesnio lygio operacijų abstrakcija yra itin pravarti konstruojant logines grandines, tačiau praktikoje taip pat reikia dekompozicijos į elementarius loginius vartus jai realizuoti. 4.21 pav. pateikti 3 kubitų bendro tipo \\(ccU\\) ir jų dekompozicija naudojant elementarius \\(cX\\), 1 kubito loginius vartus \\(V\\) ir atvirkštinius \\(V^{\\dagger}\\), \\(V^{\\dagger}V = I\\). Jie yra parenkami, kad tenkintų lygybę \\(VV = U\\). Pavyzdžiui, Tofoli loginiai vartai gali būti išreikšti šia dekompozicija pasirinkus \\(V = (1 - \\mathrm{i})(I + \\mathrm{i}X)/2\\), nes \\(VV = X\\). 4.21 pav. 3 kubitų sąlyginių loginių vartų \\(ccU\\) realizavimas Tofoli loginiai vartai \\(ccX\\) yra plačiai naudojami kvantinėse grandinėse ir juos pasitelkus galima lengvai išreikšti \\(k\\) skaičiumi kubitais kontroliuojamus loginius vartus \\(c^{k}U\\). Iliustracijai, 4.22 pav. parodyta \\(ccU\\) dekompozicija, naudojanti Tofoli sekas. Šį metodą panagrinėsime detaliau. 4.22 pav. 3-kubitų sąlyginių loginių vartų ccU realizavimas pasitelkiant Tofoli loginius vartus Tofoli vartais pagrįstas metodas naudoja papildomus kubitus, vadinamus ancilomis (angl. ancilla qubits), kurios atlieka juodraščio funkciją kvantinėse grandinėse. Ancilos yra inicijuojamos į \\(|a_1 a_2 \\rangle = |00\\rangle\\) būsenas, o atlikus norimą operaciją vėl grąžinamos į pradines \\(|00\\rangle\\). Imkime konkretų pavyzdį, kuriame \\(ccU = ccP(\\theta)\\) nusako minėtus, tačiau dvigubai kontroliuojamus, sąlyginius 3 kubitų fazės vartus. Pritaikius \\(ccP(\\theta)\\) 3-kubitų registrui būsena \\(|k_1 k_2 k_3\\rangle = |111\\rangle\\) įgauna fazę, \\(\\mathrm{e}^{\\mathrm{i}\\theta}|111\\rangle\\), o štai visi kiti baziniai vektoriai nėra paveikiami. Sakysime, kad 3 kubitų registras yra pradinėje lygioje visų bazinių vektorių superpozicijoje, tad kartu su dviem ancilomis (kubitais) jų būsena formoje \\(|k_1 k_2 k_3 \\rangle\\otimes|a_1 a_2 \\rangle\\) yra: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle + |100\\rangle + |101\\rangle + |110\\rangle + |111\\rangle\\big)\\otimes |00\\rangle\\,. \\tag{4.58} \\end{equation}\\] Paskutiniai du kubitai yra minėtos ancilos, atskirtos tenzorių daugybos ženklu dėl aiškumo. Tolesniuose žingsniuose pritaikysime dvejus Tofoli loginius \\(ccX\\) vartus. Pirmasis, vadinsime jį \\(ccX_1\\), naudoja įvesties registro kubitus \\(k_1\\) ir \\(k_2\\) kaip kontrolinius, o adresatinis yra pirmasis ancila kubitas \\(a_1\\). Iš to randame: \\[\\begin{equation} \\begin{split} ccX_1|\\psi\\rangle = &amp; \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle + |100\\rangle + |101\\rangle\\big)\\otimes|00\\rangle \\\\ &amp; + \\frac{1}{\\sqrt{8}}\\big(|110\\rangle + |111\\rangle\\big)\\otimes|10\\rangle\\,. \\end{split} \\tag{4.59} \\end{equation}\\] Šie vartai parenka būsenas \\(|11k_3\\rangle\\) ir jas supina su pirmu ancila kubitu, kuriam būsena pakeičiama į \\(|1\\rangle\\). Tolesnis \\(ccX_2\\) naudoja įvesties registro kubitą \\(k_3\\) ir ancilą \\(a_1\\) kaip kontrolinį kubitą, o adresatinis yra antrasis ancila kubitas \\(a_2\\): \\[\\begin{equation} \\begin{split} (ccX_2)(ccX_1)|\\psi\\rangle = &amp; \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle + |100\\rangle + |101\\rangle\\big)\\otimes|00\\rangle \\\\ &amp; + \\frac{1}{\\sqrt{8}}|110\\rangle\\otimes|10\\rangle + \\frac{1}{\\sqrt{8}}|111\\rangle\\otimes|11\\rangle\\,. \\end{split} \\tag{4.60} \\end{equation}\\] Šie vartai supina \\(|111\\rangle\\) būseną su ancilų \\(|11\\rangle\\) būsena. Trečiame žingsnyje pritaikome sąlyginius fazės vartus \\(cP(\\theta)\\), kuriuose kontrolinis kubitas yra antra ancila \\(a_2\\), o adresatinis šiuo atveju gali būti bet kuris iš trijų įvesties kubitų, sakysime, \\(k_3\\): \\[\\begin{equation} \\begin{split} cP(\\theta)(ccX_2)(ccX_1)|\\psi\\rangle = &amp; \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle + |100\\rangle + |101\\rangle\\big)\\otimes|00\\rangle \\\\ &amp; + \\frac{1}{\\sqrt{8}}|110\\rangle\\otimes|10\\rangle + \\frac{\\mathrm{e}^{\\mathrm{i}\\theta}}{\\sqrt{8}}|111\\rangle\\otimes|11\\rangle\\,. \\end{split} \\tag{4.61} \\end{equation}\\] Šie trys loginiai žingsniai efektyviai pritaikė fazę \\(\\mathrm{e}^{\\mathrm{i}\\theta}\\) būsenai \\(|111\\rangle\\). Tolesniuose dviejuose žingsniuose pritaikome Tofoli vartus atbuline tvarka siekdami atstatyti abiejų ancila kubitų būsenas atgal į \\(|00\\rangle\\), taip paruošiant jas potencialiai tolimesniems skaičiavimams: \\[\\begin{equation} \\begin{split} (ccX_1)(ccX_2)(cP(\\theta))(ccX_2) &amp; (ccX_1)|\\psi\\rangle = \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |001\\rangle + |010\\rangle \\\\ &amp; + |011\\rangle + |100\\rangle + |101\\rangle + |110\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta}|111\\rangle\\big)\\otimes|00\\rangle\\,. \\end{split} \\tag{4.62} \\end{equation}\\] Bet kokia \\(k\\) kontroliuojamų sąlyginių loginių vartų \\(c^{k}U\\) dekompozicija, pagrįsta Tofoli vartais \\(ccX\\), paremta iliustruotu kaskadų principu. Šiam metodui reikalingi \\(2(k - 1)\\) skaičius Tofoli vartų ir papildomų \\(k - 1\\) ancila kubitų. Kvantinių ryšių protokoluose, klaidų taisymo ir kituose algoritmuose galima aptikti mišrių kvantinių-klasikinių loginių operacijų. 4.23 pav. parodytas grandinės pavyzdys, kuriame \\(cX\\) yra kontroliuojami klasikinio registro \\(c\\) būsenos. 4.23 pav. Mišri kvantinė-klasikinė loginė grandinė, kurioje \\(k_2\\) kubitui pritaikomi Pauli-\\(X\\), kontroliuojami klasikiniu registru Šioje grandinėje po Hadamardo vartų kubitas \\(k_1\\) yra lygioje būsenų superpozicijoje, o bendra būsena: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|0\\rangle\\,. \\tag{4.63} \\end{equation}\\] Atlikus būsenos matavimą su \\(k_1\\) kubitu, yra lygi tikimybė rasti jį \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenoje. Šis atsakymas yra įregistruojamas klasikiniame bitų registre \\(c\\) kaip atitinkamai 0 arba 1 bito vertė. Jeigu bito vertė yra 1, kubitui \\(k_2\\) atliekami \\(X\\) vartai ir pakeičia būseną į \\(|1\\rangle\\). Tad dviejų kubitų būsena tampa \\(|1\\rangle\\otimes|1\\rangle\\). O štai, jeigu pirmo kubito matavimo rezultatas nusako \\(|0\\rangle\\) būseną, tada galutinė abiejų kubitų būsena lieka \\(|0\\rangle\\otimes|0\\rangle\\). Grandinė generuoja mišrią kvantinę būseną, kurią galima užrašyti tankio operatoriumi: \\[\\begin{equation} \\rho = \\frac{1}{2}|00\\rangle\\langle 00| + \\frac{1}{2}|11\\rangle\\langle 11|\\,. \\tag{4.64} \\end{equation}\\] Atkreipiame dėmesį, kad \\(\\rho\\) yra nekoherentinė būsena, nes \\(1/2\\) nusako klasikines tikimybes, o ne kvantines amplitudes. Tačiau, jeigu realizuotume šią grandinę daug kartų ir atliktume Pauli-\\(Z\\) matavimus, rezultatuose matytume idealią koreliaciją tarp kubitų būsenų. Nežinant visos loginės procedūros tokiais matavimais būtų neįmanoma pasakyti, ar stebima supintoji 2 kubitų grynoji būsena nusakoma \\(\\rho = |\\chi^{+}\\rangle\\langle\\chi^{+}|\\), ar faktorizuojamoji mišrioji \\(\\rho\\). Kvantinių koreliacijų nebuvimas pasimatytų, pavyzdžiui, jeigu vietoj Pauli-\\(Z\\) matavimo atliktume nelokalųjį Belo tipo matavimą. Prie to sugrįšime kitame poskyryje. 4.8 Bendro tipo būsenų matavimai Projekciniai kubitų būsenų matavimai gali būti atliekami bet kokių vektorių bazėje. Niekaip ypatingai neišsiskiria standartiškai naudojama Pauli-\\(Z\\) bazė {\\(|0\\rangle\\), \\(|1\\rangle\\)}. Kvantinės kriptografijos protokoluose dažnai aptinkami projekciniai matavimai Pauli-\\(Z\\) ir Pauli-\\(X\\) tikrinių vektorių bazėje. Norint atlikti Pauli-\\(X\\) matavimus praktiškai, nebūtina naudoti skirtingą fizinį matavimo įrenginį. Tam tereikia standartinius Pauli-\\(Z\\) bazinius vektorius transformuoti į tuos, kurių atžvilgiu norima matuoti būsenas, ir atlikti įprastinį Pauli-\\(Z\\) matavimą. Ekvivalentiškumas čia atsiranda dėl to, kad vidinės sandaugos modulio kvadrato reikšmė, randama skaičiuojant projekcinio matavimo tikimybes, nepriklauso nuo eiliškumo: \\(\\big|\\langle\\psi |\\chi\\rangle\\big|^2 = \\big|\\langle\\chi |\\psi\\rangle\\big|^2\\). Kaip konkretų pavyzdį atlikime būsenos, išreikštos Pauli-\\(Z\\) tikriniais vektoriais \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\), projekcinius matavimus Pauli-X tikrinių vektorių bazėje: \\[\\begin{equation} |0_x\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\,,\\quad |1_x\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle - |1\\rangle\\big)\\,. \\tag{4.65} \\end{equation}\\] Hadamardo loginiai vartai atlieka norimą transformaciją tarp šių bazinių vektorių: \\(H|0\\rangle = |0_x\\rangle\\), \\(H|1\\rangle = |1_x\\rangle\\). Atlikus kubito esančio \\(|\\psi\\rangle\\) būsenoje projekcinį matavimą {\\(|0_x\\rangle\\), \\(|1_x\\rangle\\)} Pauli-\\(X\\) bazėje, tikimybės randamos \\(p = \\big|\\langle 0_x |\\psi\\rangle\\big|^2 = |a + b|^2 /2\\) ir \\(p = \\big|\\langle 1_x |\\psi\\rangle\\big|^2 = |a - b|^2 /2\\). Tą patį gauname pirmiausiai atlikę \\(|\\psi\\rangle\\) būsenos transformaciją, \\(H|\\psi\\rangle \\equiv |\\psi_x\\rangle\\), ir toliau matuodami įprastiniu būdu Pauli-\\(Z\\) bazėje: \\(\\big|\\langle 0 |\\psi_x \\rangle\\big|^2 = \\big|\\langle 0_x |\\psi\\rangle\\big|^2\\), \\(\\big|\\langle 1 |\\psi_x \\rangle\\big|^2 = \\big|\\langle 1_x |\\psi\\rangle\\big|^2\\). Kadangi pabaigoje vis tiek atliekame Pauli-\\(Z\\) matavimą, galutinės būsenos bus tikriniai vektoriai \\(|0\\rangle\\) arba \\(|1\\rangle\\). Todėl, jeigu norima pilnai imituoti Pauli-\\(X\\) matavimą, reikia atlikti dar vieną Hadamardo transformaciją gautai būsenai po matavimo. Tokiu atveju, gavus bitą 0 arba 1, galutinė būsena bus deterministiškai pakeičiama į \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\), atitinkamai. Grandinė, atliekanti Pauli-\\(X\\) matavimą \\(|0\\rangle\\) būsenai, iliustruota 4.24 pav. 4.24 pav. Grandinė, atliekanti Pauli-\\(X\\) matavimą \\(|0\\rangle\\) būsenai Atkreipiame dėmesį į praktikoje pasitaikančius iš eilės atliekamus skirtingo tipo matavimus. Pavyzdžiui, jeigu pirmiausiai \\(|0_x \\rangle\\) kubito būsenai atliksime Pauli-\\(X\\) matavimus, užtikrintai rasime \\(|0_x \\rangle\\) būseną. Tačiau Pauli-\\(Z\\) matavime rezultatas bus būsena \\(|0\\rangle\\) arba \\(|1\\rangle\\) su \\(p = 0.5\\) tikimybėmis. Po Pauli-\\(Z\\) matavimo sekantys Pauli-\\(X\\) matavimai taip pat suteiktų \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\) su \\(p = 0.5\\) tikimybe, kadangi Pauli-\\(Z\\) matavimas pakeičia \\(|0_x \\rangle\\) būseną į \\(|0\\rangle\\) arba \\(|1\\rangle\\). Tai formaliai išplaukia iš Haizenbergo neapibrėžtumo principo (angl. Heisenberg uncertainty principle), kuris teigia, kad dviejų (ar daugiau) nekomutatyvių ermitinių operatorių \\(A\\) ir \\(B\\), \\(\\lbrack A, B\\rbrack \\neq 0\\), matavimuose, pirmojo operatoriaus matavimo rezultatas turi įtakos antrojo operatoriaus matavimo rezultatams. Kaip pamename, Pauli {\\(X\\), \\(Y\\), \\(Z\\)} operatoriai yra visi tarpusavyje nekomutatyvūs. Belo projekcinis matavimo būdas (angl. Bell measurement) yra svarbus siekiant unikaliai atskirti supintąsias 2 kubitų būsenas. Vien tik 1 kubito transformacijomis ir standartiniais lokaliais matavimais neįmanoma atskleisti Belo būsenų. Šiame skyriuje minėjome, kad skaičiuojamuosius 2 kubitų bazinius vektorius galima unikaliai asocijuoti su Belo būsenomis. Belo matavimas yra pagrįstas atvirkštine kvantinio supynimo grandine, kurioje kiekviena būsena pakeičiama atgal į su ja asocijuotą 2 kubitų skaičiuojamąjį bazinį vektorių: \\[\\begin{equation} |\\chi^{+}\\rangle \\rightarrow |00\\rangle\\,,\\quad |\\chi^{-}\\rangle \\rightarrow |10\\rangle\\,,\\quad |\\eta^{+}\\rangle \\rightarrow |01\\rangle\\,,\\quad |\\eta^{-}\\rangle \\rightarrow |11\\rangle\\,. \\tag{4.66} \\end{equation}\\] Po šios transformacijos, atlikus Pauli-\\(Z\\) projekcinius matavimus su abiem kubitais galima užtikrintai sužinoti, kokia tai Belo būsena. Tai yra nedestruktyvus matavimo būdas, nes po matavimo galime vėl deterministiškai atstatyti pradinę Belo būseną. Kvantinė grandinė, atliekanti Belo matavimą, yra parodyta 4.25 pav. 4.25 pav. 2 kubitų Belo matavimas Užbaigdami šį poskyrį sugrįžtame palyginti, kokie yra Belo matavimo rezultatai šio skyriaus ankstesniame poskyryje minėtai mišriai būsenai \\(\\rho\\), kuri pasižymi klasikinėmis, o ne kvantinėmis koreliacijomis kaip grynoji supintoji būsena. Atlikę mišriąjai būsenai \\(\\rho\\) Belo matavime aptinkamą \\(cX\\) ir \\(H\\) transformacijų seką randame: \\[\\begin{equation} \\begin{aligned} (H\\otimes I)(cX)\\rho(cX)^{\\dagger}(H^{\\dagger}\\otimes I) = &amp; \\frac{1}{2}|00\\rangle\\langle 00| + \\frac{1}{2}|10\\rangle\\langle 10| \\\\ = &amp; \\frac{1}{2}\\big(|0\\rangle + |1\\rangle\\big)\\big(\\langle 0| + \\langle 1|\\big)\\otimes |0\\rangle\\langle 0|\\,. \\end{aligned} \\tag{4.67} \\end{equation}\\] Akivaizdu, kad šis tankio operatorius yra faktorizuojamas \\(\\rho = \\rho_1\\otimes\\rho_2\\). Atlikus Pauli-\\(Z\\) matavimą, antras kubitas visada bus rastas \\(|0\\rangle\\) būsenoje, nes \\(\\rho_2 = |0\\rangle\\langle 0|\\). O štai pirmas kubitas gali būti rastas \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenoje su \\(p = 0.5\\) tikimybe, tad galutinė dviejų kubitų būsena bus \\(|00\\rangle\\) arba \\(|10\\rangle\\). Čia ir matome skirtumą, nes supintajai grynąjai būsenai \\(\\rho = |\\chi^{+}\\rangle\\langle\\chi^{+}|\\) atlikus tą pačią loginių vartų seką, kubitų pora bus visada randama \\(|00\\rangle\\) būsenoje. Galimybė aptikti \\(|10\\rangle\\) būseną pradingsta dėl destruktyvios interferencijos loginėse Belo matavimo operacijose. 4.9 Universalių loginių vartų rinkinys Skirtingų loginių vartų rinkinys, leidžiantis įvykdyti bet kokią n kubitų registro būsenų transformaciją norimu tikslumu, yra vadinamas universaliu. Barenko teorema (angl. Barenco theorem) teigia, kad kvantinių loginių vartų rinkinys \\(\\big\\{ U_3(\\theta,\\gamma,\\varphi), cX\\big\\}\\) yra universalus. Todėl 1 kubito \\(U_3(\\theta,\\gamma,\\varphi)\\) bei 2 kubitų \\(cX\\) loginių vartų kombinacijomis galima įvykdyti bet kokį suformuluojamą algoritmą kvantiniame kompiuteryje. Matematiškai tai reiškia, kad bet kokią \\((2^n\\times 2^n)\\) dydžio unitarinę matricą \\(U\\), nusakančią vektoriaus transformaciją kompleksinėje \\(d = 2^n\\) dimensijų vektorių erdvėje \\(V^d\\), galima išskaidyti į paprastesnes \\((2^n \\times 2^n)\\) matricas, kurių kiekviena netrivialiai veikia tik 1 kubito (2 dimensijų) ir 2 kubitų (4 dimensijų) poerdvius. Jos yra vadinamos dviejų lygių unitariosiomis matricomis (angl. two-level unitary matrix). Tiksliau, \\(U\\) galima išskaidyti į \\(U = U_1 U_2\\cdots U_N\\), čia \\(U_i\\) yra 2 lygių unitariosios matricos, atlikti dekompozicijai reikalingas jų skaičius \\(N\\) tenkina \\(N \\leq d(d - 1)/2\\). Norint įvykdyti visas įmanomas 1 kubito unitarines transformacijas \\(U_3(\\theta,\\gamma,\\varphi)\\) reikia, kad parametrizuoti loginiai vartai galėtų tolydžiai pasukti Blocho vektorių. Tačiau nėra žinoma, kaip atlikti tolydžiąsias transformacijas su begaliniu tikslumu turint ribotus išteklius. Tai yra viena iš priežasčių, kodėl klaidų taisymo algoritmai tokie svarbūs kvantinei kompiuterijai. Praktiškai yra naudingiau pakeisti riboto tikslumo tolydžiai parametrizuotas transformacijas diskrečiosiomis, bet tiksliau sukalibruotomis transformacijomis. Solovėjaus-Kitaevo teorema (angl. Solovay-Kitaev theorem) teigia, kad tolydžias 1 kubito transformacijas galima apytikriai pakeisti naudojant vien tik \\(H\\), \\(S\\), ir \\(T\\) loginių vartų kombinacijas. Pageidaujamai mažo dydžio 1 kubito loginių vartų paklaida \\(\\varepsilon\\) (angl. arbitrarily small error) gali būti pasiekta su \\(O\\big(\\log^2(1/\\varepsilon)\\big)\\) skaičiumi loginių vartų iš šio rinkinio. Tai bendrai yra priimtinas loginių vartų skaičiaus padidėjimas. Keturių loginių vartų rinkinys {\\(H\\), \\(S\\), \\(T\\), \\(cX\\)}, vadinamas Klifordo-T grupe (angl. Clifford-T group), yra universalus ir dažnai aptinkamas praktikoje. Egzistuoja ir kitų universaliųjų rinkinių, pavyzdžiui, {\\(H\\), \\(ccX\\)} ir {\\(H\\), \\(S\\), \\(cX\\), \\(ccX\\)}. Svarbi Gotsmano-Nilo teorema (angl. Gottesman-Knill theorem) teigia, kad kvantiniai algoritmai, naudojantys vien tik Klifordo grupės 1 ir 2 kubitų loginius vartus {\\(H\\), \\(S\\), \\(cX\\)} gali būti efektyviai modeliuojami klasikiniu kompiuteriu su polinominiu laiko kompleksiškumu. Nors Klifordo grupe pagrįsti kvantiniai algoritmai gali sukurti daug įvairių supintųjų registro būsenų, tačiau šie algoritmai nesuteikia pranašumo prieš klasikinius algoritmus. Yra gerai žinoma, kad Klifordo grupė nesudaro universalaus loginių vartų rinkinio. Būtent \\(T\\) loginiai vartai, įtraukti Klifordo-T grupėje, negali būti pageidaujamai tiksliai išreikšti vien su {\\(H\\), \\(S\\), \\(cX\\)}. "],["kvantinė-informacija-ir-ryšiai.html", "5 skyrius. Kvantinė informacija ir ryšiai 5.1 Kvantinės informacijos kopijavimas 5.2 Kvantinė teleportacija 5.3 Kvantinio supynimo sukeitimas 5.4 Kvantinė kriptografija 5.5 Lokalios operacijos ir klasikiniai ryšiai 5.6 Belo nelygybės testas", " 5 skyrius. Kvantinė informacija ir ryšiai 5.1 Kvantinės informacijos kopijavimas Klasikinės informacijos kopijavimas (skaitmeniniu ar kitokiu pavidalu) yra kasdieninis dalykas. Tai atliekame kopijuodami failus kompiuterio atminties laikmenose, informacijos kopijomis yra apsikeičiama tarp kompiuterių naudojant internetą. Nors skamba paradoksaliai, tačiau kvantinės informacijos kopijavimas yra fundamentaliai neįmanomas. Uždraustojo kopijavimo teorema (angl. no-cloning theorem) nusako, kad neįmanoma sukurti nežinomos bendros kvantinės būsenos identiškos kopijos (klono). Dėl šios teoremos svarbos bei gan paprastų argumentų pateiksime jos įrodymą. Įrodymas: darome prielaidą, kad vis dėlto egzistuoja tokia unitarinė transformacija \\(U\\), kuri gali sukurti identišką nežinomos kvantinės būsenos \\(|\\psi\\rangle\\) kopiją. Kopijavimui atlikti naudojame kvantinį registrą, esantį sutartinėje būsenoje \\(|\\phi\\rangle\\), o \\(U\\) veikia tarp šio registro ir kopijuojamos kvantinės sistemos. Pagal kopijavimo apibūdinimą, \\(U\\) formaliai atlieka: \\[\\begin{equation} U|\\psi\\rangle\\otimes |\\phi\\rangle = |\\psi\\rangle\\otimes |\\psi\\rangle\\,. \\tag{5.1} \\end{equation}\\] Kitaip tariant, antrojo registro būsena yra pakeičiama į identišką pirmojo registro \\(|\\psi\\rangle\\) būsenos kopiją, \\(|\\phi\\rangle \\rightarrow |\\psi \\rangle\\). Toliau imkime bet kokias dvi normuotas būsenas \\(|\\kappa\\rangle\\) ir \\(|\\tau\\rangle\\), kurių kopijavimą norime atlikti. Kopijuojančios unitarinės transformacijos efektas šioms būsenoms individualiai yra: \\[\\begin{equation} U|\\kappa\\rangle\\otimes |\\phi\\rangle = |\\kappa\\rangle\\otimes |\\kappa\\rangle\\,,\\quad U|\\tau\\rangle\\otimes |\\phi\\rangle = |\\tau\\rangle\\otimes |\\tau \\rangle\\,. \\tag{5.2} \\end{equation}\\] Tolesniame žingsnyje įvertinkime \\(|\\kappa\\rangle\\otimes|\\kappa\\rangle\\) ir \\(|\\tau\\rangle\\otimes |\\tau\\rangle\\) būsenų vidinę sandaugą: \\[\\begin{equation} \\begin{aligned} \\big(\\langle\\kappa |\\otimes\\langle\\kappa |\\big)\\big(|\\tau\\rangle\\otimes |\\tau\\rangle\\big) = &amp; \\langle\\kappa |\\tau\\rangle^2 = \\langle\\phi|\\otimes\\langle\\kappa |U^{\\dagger}U|\\tau\\rangle\\otimes |\\phi\\rangle \\\\ = &amp; \\langle\\kappa |\\tau\\rangle\\langle\\phi |\\phi\\rangle = \\langle\\kappa |\\tau\\rangle\\,. \\end{aligned} \\tag{5.3} \\end{equation}\\] Viršuje, neprarasdami bendrumo, panaudojome unitarumą \\(U^{\\dagger}U = I\\) bei registro būsenos normuotumą \\(\\langle\\phi |\\phi\\rangle = 1\\). Tad randame šią lygtį: \\[\\begin{equation} \\langle\\kappa | \\tau\\rangle^2 = \\langle\\kappa | \\tau\\rangle\\,. \\tag{5.4} \\end{equation}\\] Tai yra formaliai kvadratinė lygtis, \\(x^2 = x\\), kuri turi du sprendinius: \\(x = 0\\) ir \\(x = 1\\). Pirmasis sprendinys (\\(x = 0\\)) nusako, kad \\(|\\kappa\\rangle\\) ir \\(|\\tau\\rangle\\) yra ortogonaliosios būsenos \\(\\langle\\kappa |\\tau\\rangle = 0\\). Antrasis sprendinys (\\(x = 1\\)) nusako, kad jos vienodos \\(\\langle\\kappa |\\tau\\rangle = 1\\), \\(\\rightarrow |\\kappa\\rangle = |\\tau\\rangle\\) (iki nesvarbios globalios fazės \\(\\mathrm{e}^{\\mathrm{i}\\alpha}\\)). Antrasis sprendinys mūsų nedomina, nes pasirinkome skirtingas būsenas, \\(|\\kappa\\rangle \\neq |\\tau \\rangle\\). Pirmasis sprendinys rodo, kad transformacija \\(U\\) gali atlikti tik ortogonaliųjų būsenų kopijavimą ir todėl prieštarauja prielaidai, kad egzistuoja universali unitarioji transformacija \\(U\\), galinti kopijuoti bet kokią būseną. Kvantiniu kompiuteriu galima kopijuoti klasikinę informaciją. Jau žinome tokį \\(U\\), kuris sugeba kopijuoti bazinių vektorių būsenas \\(|0\\rangle\\) ir \\(|1\\rangle\\), tai \\(cX\\) loginiai vartai. Tačiau \\(cX\\) negali nukopijuoti 1 kubito būsenos, kuri yra \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijoje. Imkime pirmąjį kubitą, esantį lygioje \\(|0 \\rangle\\) ir \\(|1 \\rangle\\) superpozicijoje, taip pat antrojo registro kubitą \\(|0\\rangle\\) būsenoje. Randame: \\[\\begin{equation} cX\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes |0\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle)\\,. \\tag{5.5} \\end{equation}\\] Šiuo atveju gauname supintąją Belo būseną. Tačiau, jeigu \\(cX\\) iš tiesų atliktų kopijavimą į antrojo kubito vietą, mes turėtume gauti: \\[\\begin{equation} \\frac{1}{2}\\big(|0\\rangle + |1\\rangle\\big)\\otimes\\big(|0\\rangle + |1\\rangle\\big) = \\frac{1}{2}\\big(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\\big)\\,. \\tag{5.6} \\end{equation}\\] Be unitariųjų transformacijų taip pat yra matavimų tipo nedeterministinės transformacijos. Jos irgi nėra tinkamos atlikti kopijavimą, nes matavimų rezultatai yra atsitiktiniai. 5.2 Kvantinė teleportacija Klasikinė skaitmeninė informacija ryšiuose yra perduodama siunčiant signalus tuščia erdve, elektros kabeliais bei šviesolaidžiais. Norint persiųsti kvantinę informaciją, kuri yra koduojama kubito būsenoje \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\), reikia, kad perduotume amplitudžių vertes \\(a\\) ir \\(b\\). Jeigu žinome \\(|\\psi \\rangle\\) būsenos paruošimo žingsnius, tada taip pat galime klasikiniu būdu komunikuoti būsenos loginių operacijų seką, kurią atkartojęs gavėjas turės efektyviai identišką kvantinę informaciją savo kubite. Didesnis keblumas iškyla norint persiųsti informaciją, laikomą nežinomoje kvantinėje būsenoje. Šios informacijos iš esmės sužinoti negalime, tad ir ją komunikuoti klasikiniu būdu neįmanoma. Egzistuoja keletas būdų, kaip persiųsti nežinomo turinio kvantinę informaciją. Pirmasis būdas  – kubitų fizinis apsikeitimas tarp lokacijų kvantinio ryšio priemonėmis. Kvantinis ryšys įprastai naudoja fotonus, dar vadinamus skraidančiaisiais kubitais (angl. flying qubits) ir, pavyzdžiui, jų poliarizacijos būsenas, kuriose koduojama informacija. Fotonus galima siųsti dideliais atstumais naudojant įprastus telekomunikacijoms skirtus šviesolaidžius bei tuščia erdve. Tačiau delikačios fotonų būsenos yra lengvai pažeidžiamos siunčiant juos dideliais atstumais. Atsirandanti depoliarizacijos tikimybė gali pakeisti amplitudes ir įvesti klaidas į siunčiamą informaciją. Didėjant atstumui, taip pat didėja fotonų praradimo tikimybė dėl absorbcijos ir sklaidos. Kitaip nei klasikiniuose ryšiuose, siunčiamo kvantinio signalo stiprinti neįmanoma dėl uždrausto kvantinių būsenų kopijavimo. Jeigu šie neigiami efektai nėra per daug žymūs, tada kvantinių klaidų taisymo algoritmais sėkmingo ryšio tikimybę galima itin padidinti. Kvantinė teleportacija yra praktinės svarbos metodas siunčiant informaciją, koduojamą nežinomoje kubitų būsenoje. Šis metodas nereikalauja tiesioginio dvipusio kvantinių ryšių kanalo tarp bendraujančių šalių, tačiau jos turi turėti kvantinį ryšį su joms bendru supintųjų fotonų šaltiniu. Tai leidžia persiųsti kvantinę informaciją pasitelkiant klasikinių ryšių kanalą tarp bendraujančių šalių, o supintųjų kubitų poros atlieka teleportacijos ištekliaus vaidmenį. Klasikiniu kanalu tereikia nusiųsti po du bitus informacijos siekiant teleportuoti kiekviename kubite tolydžiai kintančiose amplitudėse koduojamą informaciją. Pirmiausiai įvardinkime, ką šiame kontekste reiškia žodis „teleportacija”. Pagal kvantinę mechaniką dalelės, turinčios vienodas vidines fizikines savybes tokias kaip krūvis, masė ar sukinys, yra identiškos (angl. identical particles) ir negali būti atskirtos viena nuo kitos. Elektronai gali būti atskirti nuo pozitronų, nes pirmieji turi neigiamąjį, o antrieji – teigiamąjį krūvį; tačiau elektronai negali būti atskirti vienas nuo kito. Tad, jeigu turime du elektronus skirtingose lokacijose, tačiau identiškose sukinio būsenose, sukeitus juos vietomis fundamentaliai neįmanoma pasakyti, kad jie buvo sukeisti. Teleportacijos pavyzdys būtų, jeigu pradėdami nuo dviejų elektronų skirtingose lokacijose ir sukinio būsenose identiškai atkurtume pirmojo elektrono sukinio būseną antrajame elektrone. Teleportacija nėra ribojama vien tik vidiniams laisvės laipsniams, nors ir dažniausiai nagrinėjama jų kontekste. Šis procesas išsaugo visus fizikos principus – čia aktualūs kvantinės informacijos kopijavimo draudimas, energijos tvermė ir kad niekas negali keliauti greičiau už šviesos greitį. Fizinės sistemos akimirksniu nepradingsta ir kitur neatsiranda – tik pakeičia savo būsenas. 5.1 pav. Kvantinė \\(k_1\\) kubito būsenos \\(|\\psi\\rangle\\) teleportacija į \\(k_3\\) kubitą Standartiniame teleportacijos scenarijuje (žr. 5.1 pav.) Agnė turi kubitą \\(k_1\\) būsenoje \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\), \\(|a|^2 + |b|^2 = 1\\), kurio amplitudžių \\(a\\) ir \\(b\\) ji nežino, tačiau nori \\(|\\psi\\rangle\\) nusiųsti Benui. Agnė ir Benas turi galimybę tarpusavyje komunikuoti klasikiniu būdu ir tam naudoja bitus. Jie taip pat turi prieigą prie išorinio šaltinio, kuris proceso pradžioje sugeneruoja 2 kubitų supintą Belo būseną \\(|\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\) ir išsiunčia pirmą kubitą (\\(k_2\\)) Agnei, o antrą (\\(k_3\\)) Benui. Abu žino, kad yra gavę vieną iš \\(|\\chi^{+}\\rangle\\) būsenos kubitų. Viso proceso pabaigoje Agnės \\(|\\psi\\rangle\\) kubito būsena yra teleportuojama į Beno turimą \\(k_3\\) kubitą. Bendrą pradinę šių trijų kubitų būseną galime užrašyti taip: \\[\\begin{equation} \\begin{aligned} |\\Psi\\rangle = &amp; |\\psi\\rangle\\otimes |\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\Big\\lbrack a|0\\rangle\\otimes\\big(|00\\rangle + |11\\rangle\\big) + b |1\\rangle\\otimes\\big(|00\\rangle + |11\\rangle\\big)\\Big\\rbrack \\\\ = &amp; \\frac{1}{\\sqrt{2}}\\Big\\lbrack a\\big(|000\\rangle + |011\\rangle\\big) + b\\big(|100\\rangle + |111\\rangle\\big)\\Big\\rbrack\\,. \\end{aligned} \\tag{5.7} \\end{equation}\\] Superpozicijos būsenose kubitai yra sunumeruoti taip: \\(|k_1 k_2 k_3 \\rangle\\). Pradinėje būsenoje \\(|\\Psi \\rangle\\) nėra nei klasikinių, nei kvantinių koreliacijų tarp Agnės \\(k_1\\) kubito būsenoje \\(|\\psi\\rangle\\) ir Belo poros kubitų \\(k_2\\) ir \\(k_3\\). Agnė atlieka dvejus kvantinius loginius vartus savo turimiems kubitams. Pirmiausia ji atlieka \\(cX\\) vartus, kuriame \\(|\\psi \\rangle\\) kubitas yra „kontrolinis”. Randame naują būseną \\(|\\Psi&#39;\\rangle\\): \\[\\begin{equation} |\\Psi&#39;\\rangle = (cX_{12}\\otimes I)|\\Psi\\rangle = \\frac{1}{\\sqrt{2}}\\Big\\lbrack a\\big(|000\\rangle + |011\\rangle\\big) + b\\big(|110\\rangle + |101\\rangle\\big)\\Big\\rbrack\\,. \\tag{5.8} \\end{equation}\\] Kitame žingsnyje ji atlieka norimam nusiųsti \\(|\\psi\\rangle\\) kubitui Hadamardo transformaciją: \\[\\begin{equation} \\begin{aligned} |\\Psi&#39;&#39;\\rangle = &amp; (H\\otimes I\\otimes I)|\\Psi&#39;\\rangle \\\\ = &amp; \\frac{1}{2}\\Big\\lbrack a\\big(|000\\rangle + |011\\rangle + |100\\rangle + |111\\rangle\\big) \\\\ &amp; + b\\big(|010\\rangle + |001\\rangle - |110\\rangle - |101\\rangle\\big)\\Big\\rbrack\\,. \\end{aligned} \\tag{5.9} \\end{equation}\\] Nedarant jokių kitų transformacijų, šią būseną galima pergrupuoti atskiriant Agnės ir Beno kubitus tenzorių ženklu: \\[\\begin{equation} \\begin{split} |\\Psi&#39;&#39;\\rangle = &amp; \\frac{1}{2}\\Big\\lbrack |00\\rangle\\otimes\\big(a|0\\rangle + b|1\\rangle\\big) + |10\\rangle\\otimes\\big(a|0\\rangle - b|1\\rangle\\big) \\\\ &amp; + |01\\rangle\\otimes\\big(b|0\\rangle + a|1\\rangle\\big) + |11\\rangle\\otimes\\big( -b|0\\rangle + a|1\\rangle\\big)\\Big\\rbrack\\,. \\end{split} \\tag{5.10} \\end{equation}\\] Tai leidžia lengviau pamatyti, kad Agnei atlikus dvi minėtas transformacijas Beno kubito \\(k_3\\) būsena šioje trijų kubitų superpozicijoje jau primena \\(|\\psi\\rangle\\). Toliau Agnė atlieka savo dviejų kubitų būsenos matavimą. Ji gali rasti vieną iš keturių skirtingų dviejų bitų kombinacijų su lygiomis 0.25 tikimybėmis. Pagal tai, kurią kombinaciją Agnė aptiks savo kubituose \\(|k_1 k_2 \\rangle\\), tai automatiškai turės įtakos, kokia bus galutinė Beno kubito \\(|k_3 \\rangle\\) būsena: \\[\\begin{align} |k_1 k_2\\rangle = &amp; |00\\rangle\\rightarrow |k_3 \\rangle = a|0\\rangle + b|1\\rangle\\,;\\tag{5.11} \\\\ |k_1 k_2\\rangle = &amp; |10\\rangle\\rightarrow |k_3 \\rangle = a|0\\rangle - b|1\\rangle\\,;\\tag{5.12} \\\\ |k_1 k_2\\rangle = &amp; |01\\rangle\\rightarrow |k_3 \\rangle = b|0\\rangle + a|1\\rangle\\,;\\tag{5.13} \\\\ |k_1 k_2\\rangle = &amp; |11\\rangle\\rightarrow |k_3\\rangle = - b|0\\rangle + a|1\\rangle\\,.\\tag{5.14} \\end{align}\\] Norėdama užbaigti teleportaciją, Agnė klasikiniu kanalu nusiunčia du bitus informacijos Benui pranešti, kokį rezultatą gavo. Jeigu ji rado \\(|00\\rangle\\), siunčiami bitai 00, jeigu \\(|01\\rangle\\) – bitai 01, ir atitinkamai su kitais dviem. Jeigu Benas gavo bitus 00, jam daryti nieko nereikia, \\(|\\psi\\rangle\\) jau yra teleportuota ir jo „rankose”. Visais kitais atvejais Beno kubitas \\(k_3\\) yra susietas su norima teleportuoti būsena \\(|\\psi\\rangle\\) paprasta transformacija – Blocho vektoriaus posūkiu 180° kampu aplink \\(x\\), \\(y\\), arba \\(z\\) ašis. Pavyzdžiui, jeigu Benas gavo bitus 01, savo kubitui \\(k_3\\) jis atlieka kvantinius loginius vartus \\(X\\), kurie sukeičia amplitudes vietomis ir taip gaunama \\(|\\psi\\rangle\\). Jeigu gauti bitai yra 10, jis atlieka \\(Z\\) loginius vartus, o jeigu 11 – \\(Y\\) vartus. Panagrinėkime, kas šiame procese įvyko. Pirmiausiai matome, kad Agnės kubito \\(k_1\\) būsena \\(|\\psi\\rangle\\), esanti bendrai \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijoje, matavimo metu yra panaikinama. Pas ją lieka kubitai \\(k_1\\) ir \\(k_2\\), esantys viename iš skaičiuojamųjų bazinių vektorių. Todėl \\(|\\psi\\rangle\\) būsenos kopijavimas neįvyksta ir Agnė nesužino \\(|\\psi\\rangle\\) būsenos \\(a\\) ir \\(b\\) amplitudžių, taip patvirtinama uždraustojo kopijavimo teorema. Teleportacijoje pagrindinį vaidmenį atlieka supintoji kubitų pora, kuria Agnė ir Benas pasidalijo proceso pradžioje. Agnės atliekama \\(cX\\) transformacija tarp jos supinto kubito \\(k_2\\) bei teleportuojamo \\(k_1\\) supina ir šiuos kubitus. Taip sukuriama trijų kubitų supintoji būsena. Dėl naujai įvestų trijų kubitų kvantinių koreliacijų, Agnės atliekami Hadamardo vartai jos kubitui nelokaliai paveikia bendrą trijų kubitų būseną. Tai ir yra matoma lygtyje Beno kubito amplitudėse. Prieš Agnei atliekant savo kubitų matavimą, Beno kubitas yra superpozicijoje, sudarytoje iš keturių skirtingų būsenų. Dėl įvestų koreliacijų, Agnės matavimas nulemia Beno kubito būsenos pasikeitimą į vieną iš šių keturių galimų. Tai galime interpretuoti kaip projekcinį Belo būsenų matavimą – antri \\(cX\\) ir \\(H\\) vartai tai formaliai realizuoja. Galutinė Beno transformacija \\(k_3\\) kubitui atlieka minimalius pataisymus atstatyti \\(|\\psi\\rangle\\). Teleportacija yra praktinis būdas siųsti kvantinę informaciją ryšių tikslais ar skaičiavimams kvantinių kompiuterių tinkluose. Galime įsivaizduoti scenarijų, kuriame Agnės turimas kvantinis procesorius yra pranašesnis už Beno. Nors Beno kompiuteris turi ribotas skaičiavimų galimybes, tačiau gali patikimai atlikti Pauli-\\(X\\), \\(Y\\) ir \\(Z\\) transformacijas kubitams. Tad Benas gali atlikti jam rūpimus kvantinius skaičiavimus pas Agnę kvantiniame debesyje. Parsisiųsti \\(|\\psi\\rangle\\) būseną tolimesniam apdorojimui Benui tereikia bendros prieigos su Agne prie Belo būsenų generavimo šaltinio ir klasikinių ryšių kanalo. Teleportacijos metodas gali būti naudojamas persiųsti ne vien pavienių kubitų būsenoms, bet ir sudėtinėms kubitų supintosioms kvantinėms būsenoms. 5.2 pav. Loginė grandinė, realizuojanti kvantinę teleportaciją. Paskutiniame žingsnyje kubitui \\(k_3\\) pritaikomi sąlyginiai Pauli loginiai vartai, kontroliuojami klasikinio registro, kurio būseną nulemia pirmų dviejų kubitų matavimo rezultatai Teleportaciją galime atlikti ir kvantiniame procesoriuje tarp kubitų. Vienas būdas tai užrašyti loginiais vartais yra parodytas 5.2 pav. Matome Agnės kubitą \\(k_1\\) pradinėje \\(|\\psi\\rangle\\) būsenoje, \\(|\\chi^{+}\\rangle\\) Belo būsenos generavimą tarp \\(k_2\\) ir \\(k_3\\), bei Belo matavimą. Pagal 2 bitų kombinaciją, gautą atlikus Agnės kubitų \\(k_1\\) ir \\(k_2\\) matavimus, kubitui \\(k_3\\) pritaikomi klasiškai kontroliuojami atitinkami sąlyginiai vartai Pauli-\\(X\\), \\(Y\\), \\(Z\\), arba \\(I\\). 5.3 Kvantinio supynimo sukeitimas Norint atlikti supynimą tarp dviejų kubitų, paprastai yra naudojama 2 kubitų unitarinė transformacija, pavyzdžiui, \\(cX\\) loginiai vartai. Kvantinio supynimo sukeitimo metodas (angl. entanglement swapping) leidžia supinti vieną nuo kito nutolusius kubitus nereikalaujant jų tiesioginės tarpusavio sąveikos. Čia taip pat pasitelkiamos supintosios Belo būsenos, atliekančios svarbią rolę kvantiniuose ryšiuose, jų generatorius įprasta vadinti EPR šaltiniais (angl. EPR source, trumpinys nuo Einstein-Podolsky-Rosen). Kvantinio supynimo sukeitimas praktiškai pritaikomas kvantiniuose tinkluose, nes gali atlikti signalo kartotuvo funkciją (angl. quantum repeater). Norint išvengti signalo sumenkimo nuostolių ir padidinti atstumą tarp kvantinės komunikacijos galutinių taškų, viena išeitis yra pastatyti tarpinius signalo kartotuvus. Gavę supintus kubitus iš nutolusių EPR šaltinių kartotuvai atlieka supynimo sukeitimą (žr. 5.3 pav.). Tai leidžia efektyviai padidinti kvantinio ryšio atstumą ir realizuoti teleportaciją ar kitus protokolus, naudojančius supintąsias būsenas. 5.3 pav. Kvantinio supynimo sukeitimo protokolo iliustracija. Supintosios Belo būsenos kubitų porose \\((k_1 , k_2)\\) Supynimo sukeitimo scenarijuje dalyvauja Agnė, Benas ir Cita. Panašiai kaip ir kvantinėje teleportacijoje, Agnė ir Benas turi pasidaliję po vieną kubitą iš supintos \\(|\\chi_1^{+}\\rangle\\) Belo būsenos. Benas ir Cita taip pat turi po vieną kubitą iš antros sugeneruotos Belo būsenos \\(|\\chi_2^{+}\\rangle\\). Protokolo pradžioje tarp šių dviejų Belo porų nėra jokių koreliacijų. Kvantinio supynimo sukeitimo tikslas yra supinti Agnės ir Citos kubitus. Bendrą pradinę 4 kubitų būseną galime užrašyti taip: \\[\\begin{equation} \\begin{aligned} |\\Psi\\rangle = &amp; |\\chi_1^{+}\\rangle\\otimes|\\chi_2^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\Big\\lbrack\\big(|00\\rangle + |11\\rangle\\big)\\otimes\\big(|00\\rangle + |11\\rangle\\big)\\Big\\rbrack \\\\ = &amp; \\frac{1}{2}\\big\\lbrack |0000\\rangle + |0011\\rangle + |1100\\rangle + |1111\\rangle\\big\\rbrack\\,. \\end{aligned} \\tag{5.15} \\end{equation}\\] Superpozicijos būsenose kubitai sunumeruoti \\(|k_1 k_2 k_3 k_4 \\rangle\\). Agnės kubitas \\(k_1\\) yra supintas su Beno kubitu \\(k_2\\), Beno kubitas \\(k_3\\) yra supintas su Citos kubitu \\(k_4\\). Stebint kvantinės teleportacijos žingsnius, Benas atlieka \\(cX\\) loginius vartus tarp savo turimos kubitų poros \\(k_2\\) ir \\(k_3\\), kuriuose kubitas \\(k_2\\) atlieka „kontrolinę” rolę. Randame naują būseną \\(|\\Psi&#39;\\rangle\\): \\[\\begin{equation} |\\Psi&#39;\\rangle = (I\\otimes cX_{23}\\otimes I)|\\Psi\\rangle = \\frac{1}{2}\\big\\lbrack |0000\\rangle + |0011\\rangle + |1110\\rangle + |1101\\rangle\\big\\rbrack\\,. \\tag{5.16} \\end{equation}\\] Kitame žingsnyje Benas atlieka Hadamardo transformaciją savo kubitui \\(k_2\\): \\[\\begin{equation} |\\Psi&#39;&#39;\\rangle = (I\\otimes I\\otimes H\\otimes I)|\\Psi&#39;\\rangle\\,. \\tag{5.17} \\end{equation}\\] Norėdami lengviau pamatyti rezultatą, sugrupuosime narius \\(|\\Psi&#39;&#39;\\rangle\\) skliausteliuose: \\[\\begin{equation} \\begin{split} |\\Psi&#39;&#39;\\rangle = &amp; \\frac{1}{\\sqrt{8}}\\Big\\lbrack\\big(|0\\rangle\\otimes |00\\rangle\\otimes |0\\rangle + |1\\rangle\\otimes |00\\rangle\\otimes |1\\rangle\\big) \\\\ &amp; + \\big(|0\\rangle\\otimes |01\\rangle\\otimes |1\\rangle + |1\\rangle\\otimes |01\\rangle\\otimes |0\\rangle\\big) \\\\ &amp; + \\big(|0\\rangle\\otimes |10\\rangle\\otimes |0\\rangle - |1\\rangle\\otimes |10\\rangle\\otimes |1\\rangle\\big) \\\\ &amp; + \\big(|0\\rangle\\otimes |11\\rangle\\otimes |1\\rangle - |1\\rangle\\otimes |11\\rangle\\otimes |0\\rangle\\big)\\Big\\rbrack\\,. \\end{split} \\tag{5.18} \\end{equation}\\] Kiekvienoje šios superpozicijos būsenoje 4 kubitai yra užrašyti šia forma \\(|k_1 \\rangle\\otimes |k_2 k_3 \\rangle\\otimes |k_4 \\rangle\\). Benas galiausiai atlieka savo abiejų kubitų matavimą, taigi gali rasti vieną iš keturių kombinacijų \\(|k_2 k_3 \\rangle\\) su lygiomis 0.25 tikimybėmis. Matome, kad pagal jo rastą kubitų būseną galutinė Agnės ir Citos kubitų būsena \\(|k_1 k_4 \\rangle\\) pasikeičia: \\[\\begin{align} |k_2 k_3 \\rangle = &amp; |00\\rangle\\rightarrow |k_1 k_4 \\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big) = |\\chi^{+}\\rangle\\,;\\tag{5.19}\\\\ |k_2 k_3 \\rangle = &amp; |01\\rangle\\rightarrow |k_1 k_4 \\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle + |10\\rangle\\big) = |\\eta^{+}\\rangle\\,;\\tag{5.20}\\\\ |k_2 k_3 \\rangle = &amp; |10\\rangle\\rightarrow |k_1 k_4 \\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle - |11\\rangle\\big) = |\\chi^{-}\\rangle\\,;\\tag{5.21}\\\\ |k_2 k_3 \\rangle = &amp; |11\\rangle\\rightarrow |k_1 k_4 \\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle - |10\\rangle\\big) = |\\eta^{-}\\rangle\\,.\\tag{5.22} \\end{align}\\] Agnės ir Citos kubitai \\(|k_1 k_4 \\rangle\\) visais atvejais lieka vienoje iš supintųjų Belo būsenų. Benas matavimo rezultatus perduoda Agnei ir Citai klasikiniu būdu; tai leidžia sužinoti, kokią supintąją būseną jos turi. Kad Agnė ir Cita pakeistų savo gautą būseną į bet kurią kitą Belo būseną, jos gali atlikti atitinkamas lokalias Pauli transformacijas savo turimiems kubitams. Atkreipiame dėmesį, kad šio proceso metu kvantiniai supynimai tarp Agnės ir Beno kubitų poros \\(k_1\\) ir \\(k_2\\), taip pat Beno ir Citos kubitų \\(k_3\\) ir \\(k_4\\) yra panaikinami. 5.4 pav. Kvantinio supynimo sukeitimo realizacija loginėje grandinėje Kvantinė grandinė, atliekanti supynimo sukeitimo algoritmą, yra pavaizduota 5.4 pav. Grandinės pabaigoje įdėti klasiškai kontroliuojami loginiai vartai, atliekantys \\(k_4\\) kubito transformaciją. Ši transformacija leidžia pakeisti Agnės ir Citos supintąją būseną į bet kurią kitą Belo būseną. Kaip matysime vėliau šiame skyriuje, pakanka vienos lokaliosios transformacijos, atliekamos bet kuriam kubitui supintoje poroje, norint pakeisti jų bendrą Belo būseną į bet kurią kitą Belo būseną. 5.4 Kvantinė kriptografija Įsivaizduokime scenarijų, kuriame Agnė ir Benas ketina apsikeisti svarbia informacija. Norint užtikrinti, kad Evelina, kuri yra slapukavusi tarp jų anksčiau, nepamatytų ryšių turinio, Agnė ir Benas nusprendžia jį užšifruoti. Tokiu atveju, nors Evelina ir perimtų siunčiamą turinį, ji negalėtų suprasti, kas jame sakoma. Siekdami užšifruoti turinį Agnė ir Benas naudoja raktą. Kaip paprastą to pavyzdį imkime, kad turinys (\\(t\\)) yra išreikštas dvejetaine forma \\(t = 001011010\\), o šifravimas atliekamas sudedant kiekvieną turinio bitą modulo(2) su atitinkamu rakto \\(r = 011101100\\) bitu. Taip turinys pasikeičia į šią šifruotą seką: \\(t\\oplus r = 0101110110\\). Norint turinį iššifruoti, tereikia vėl mod(2) sudėti šifruotą turinį su tuo pačiu raktu, nes \\((t\\oplus r)\\oplus r = t\\). Agnė ir Benas gali pasirinkti, ar jie naudos privataus, ar atvirojo rakto kriptografinę sistemą. Privataus rakto kriptografijoje Agnė ir Benas susitikę pasirenka raktą, arba paprašo, kad raktą jiems perduotų trečiasis asmuo, Cita. Nors privataus rakto metodas yra saugus (naudojant pakankamai ilgą raktą), jam reikalingas apsikeitimas nėra praktiškas ir turi savo saugumo spragų. Pavyzdžiui, gali būti neįmanoma susitikti apsikeisti raktu ar tai atlikti kiekvieną kartą prieš inicijuojant ryšį. Antraip jie dar turėtų užtikrinti ilgai laikomo ir naudojamo rakto saugumą nuo įsibrovimų. Trečiojo asmens naudojimas apsikeitimui irgi neužtikrina saugumo, nes Cita gali raktą pasidalyti ar perduoti Evelinai. Atvirojo rakto kriptografijos metodas buvo sukurtas 1970-aisiais ir yra plačiai taikomas interneto tinkluose. Šiuo metodu naudojamas asimetrinis rakto pasidalijimas. Norėdama suteikti Benui galimybę saugiai nusiųsti informaciją jai, Agnė atvirai paskelbia raktą, kuriuo reikia užšifruoti siunčiamą turinį. Tačiau Agnė pas save turi kitą raktą, žinomą tik jai, kuriuo galima iššifruoti turinį užšifruotu jos viešai paskelbtu raktu. Šie raktai yra sugeneruojami automatiškai kiekvienos sesijos metu, ir tam naudojamas atsitiktinių skaičių generatorius. Atvirojo rakto kriptografijos saugumas yra pagrįstas matematiškai sunkiai apskaičiuojamomis funkcijomis. Vis dėlto yra parodyta, kad plačiai paplitusi RSA kriptografijos sistema (angl. Rivest-Shamir-Adleman), pagrįsta pirminių skaičių faktorizacija, yra efektyviai įveikiama Šoro algoritmu kvantiniuose kompiuteriuose. Agnė ir Benas tiki, kad Evelina dar neturi pakankamai galingo kvantinio kompiuterio įveikti RSA, ir todėl yra linkę naudoti šį kriptografijos protokolą. Tačiau, jeigu Evelina tokį įrenginį turės artimoje ateityje, perimtą Agnės ir Beno ryšį ji galės nuskaityti ir vėliau. Trečiasis būdas, apie kurį sužinojo Agnė ir Benas, yra naudoti privatų kvantinį rakto pasidalijimo protokolą (angl. quantum key distribution, trumpinys QKD). Šiame protokole užšifruoti ir iššifruoti turiniui taip pat naudojamas klasikinis raktas (dvejetainis kodas), tačiau rakto pasidalijimui yra naudojami kvantiniai ryšiai. Privatų rakto pasidalijimą jie gali atlikti per atvirą kanalą nebijodami, kad Evelina raktą sužinos, kadangi kvantiniuose ryšiuose rakto atskleidimas pakeičia raktą, na, o kopijuoti kvantinio rakto fundamentaliai neįmanoma. Atlikę kvantinį rakto pasidalijimą jie gali toliau naudoti klasikinį ryšių kanalą simetriškai užšifruodami ir iššifruodami siunčiamą turinį. Toliau pateikiame BB84 ir EPR kvantinius rakto pasidalijimo protokolus. 5.4.1 BB84 kvantinis rakto pasidalijimo protokolas Dvejetainio rakto persiuntimui BB84 (angl. C. Bennet ir G. Brassard, 1984) protokole yra naudojamas vienpusis kvantinis kanalas nuo Agnės iki Beno ir klasikinis dvipusis ryšių kanalas. Klasikinis kanalas yra viešas ir gali būti pasiklausomas, kvantiniu kanalu siunčiama informacija taip pat gali būti perimta. Kaip matysime, tai netrukdo inicijuoti saugų ryšį. Jeigu norimo rakto ilgis yra \\(n\\) bitų, tada Agnė, pirmiausiai naudodama atsitiktinių skaičių generatorių, sugeneruoja dvi \\(4n\\) bitų ilgio sekas, kurias vadinsime \\(a_A\\) ir \\(b_A\\). Pirmoji bitų seka \\(a_A\\) nusako patį raktą, o antroji \\(b_A\\) – kokią šifravimo sistemą naudoti kiekvienam \\(a_A\\) rakto bitui. Šias dvi vienodo ilgio sekas galima sugrupuoti poromis \\(\\{a_A , b_A\\}=\\{(a_1 , b_1 ), (a_2, b_2 ),\\ldots, (a_{4n}, b_{4n})\\}\\), pagal kurias Agnė paruoš \\(4n\\) kubitų siųsti Benui. Jeigu \\(b_A\\) bitas yra 0, tada išreikšti \\(a_A\\) bitui (kurio sugeneruota vertė yra 0 arba 1) Agnė taiko Pauli-\\(Z\\) bazinių vektorių šifravimą. Tai yra, jeigu rakto bito vertė yra \\(a_A= 0\\), jis perteikiamas kubito \\(|0\\rangle\\) būsena, o \\(a_A= 1\\) bitas perteikiamas būsena \\(|1\\rangle\\). Jeigu šifravimo bitas \\(b_A = 1\\), Agnė išreiškia atitinkamą \\(a_A\\) rakto bitą Pauli-\\(X\\) baziniais vektoriais {\\(|0_x \\rangle\\), \\(|1_x \\rangle\\)}. Taip Agnė nusiunčia Benui \\(4n\\) kubitų \\(|\\psi_{ab}\\rangle\\), kurių kiekvienas yra vienoje iš šių būsenų: \\[\\begin{align} |\\psi_{00}\\rangle = &amp; |0\\rangle\\,;\\tag{5.23} \\\\ |\\psi_{10}\\rangle = &amp; |1\\rangle\\,;\\tag{5.24} \\\\ |\\psi_{01}\\rangle = &amp; |0_x \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\,;\\tag{5.25} \\\\ |\\psi_{11}\\rangle = &amp; |1_x \\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle - |1\\rangle\\big)\\,.\\tag{5.26} \\end{align}\\] Gavęs kubitus Benas neturi informacijos, kokiose būsenose jie yra. Benas imasi atlikti kubitų būsenų matavimus ir atsitiktiniu būdu pasirenka atlikti Pauli-\\(Z\\) arba Pauli-\\(X\\) projekcinius matavimus. Kaip minėjome 4 skyriuje, norint atlikti Pauli-\\(X\\) projekcinį matavimą tereikia atlikti gautiems kubitams Hadamardo transformaciją ir toliau jiems vykdyti standartinį (Pauli-\\(Z\\)) matavimą. Atkreipiame dėmesį, kad šios keturios kubitų būsenos nėra visos viena kitai ortogonalios, todėl negali būti patikimai atskirtos atliekant tik vieno tipo matavimą. Matome, kad (atsitiktinai) atlikęs Pauli-\\(Z\\) matavimą kubitams, esantiems \\(|\\psi_{00}\\rangle\\) arba \\(|\\psi_{10}\\rangle\\) būsenose, Benas (pats nežinodamas) teisingai išmatuoja šias būsenas ir gauna sutapimą su jais, koduojamais Agnės rakto \\(a\\) bitais. Tačiau, jeigu būsenos yra \\(|\\psi_{01}\\rangle\\) arba \\(|\\psi_{11}\\rangle\\), tikimybė, kad atlikdamas Pauli-\\(Z\\) matavimą Benas teisingai iššifruos rakto bitus, tėra 0.5, kadangi \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\) yra lygios \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpozicijos. Analogiška situacija atsiranda, kai Benas atlieka Pauli-\\(X\\) matavimą. Jis gauna sutapimus su atitinkamais Agnės rakto bitais, jeigu matuoja \\(|\\psi_{01}\\rangle\\) ir \\(|\\psi_{11}\\rangle\\) būsenas, tačiau atsiranda 0.5 rakto iššifravimo paklaidos tikimybė matuojant \\(|\\psi_{00}\\rangle\\) ir \\(|\\psi_{10}\\rangle\\) būsenas. Taip atlikęs matavimus Benas sugeneruoja {\\(a_B\\), \\(b_B\\)} bitų porų seką, kurioje \\(a_B\\) bitas (0 arba 1) nusako gautą būsenos matavimo rezultatą, o \\(b_B\\) bitas užrašo, ar šis matavimas naudojo Pauli-\\(Z\\) (bito vertė 0) ar Pauli-\\(X\\) (bito vertė 1). Kitame žingsnyje Agnė ir Benas, komunikuodami per atvirą klasikinį kanalą, palygina šifravimo \\(4n\\) bitų \\(b_A\\) ir \\(b_B\\) sekas. Taip jie turėtų rasti, kad tarp jų bitų vidutiniškai \\(2n\\) buvo atsitiktiniu būdu pasirinkti vienodai. Tai reiškia, kad Beno naudojamas matavimo būdas bei Agnės bitų šifravimo būdas šiais \\(2n\\) atvejais sutapo, ir jie abu žino, kad buvo teisingai iššifruoti šie atitinkami \\(a\\) rakto bitai. Jie atsikrato \\(a_A\\) ir \\(a_B\\) bitų, kurių porose esantys \\(b_A\\) ir \\(b_B\\) nesutampa ir pasilieka likusią \\(2n\\) raktų seką (\\(a_A = a_B\\)) neatskleisdami jos. Norėdami patikrinti, kad Evelina neslapukavo perimdama Agnės siunčiamus kubitus, jiedu atsitiktinai pasirenka iš turimų \\(2n\\) rakto bitų \\(n\\) bitų ir per klasikinį kanalą palygina, ar jie sutampa. Jeigu priimtinas bitų skaičius sutampa, jiedu užbaigia rakto apsikeitimo protokolą ir gali saugiai naudoti likusius \\(n\\) bitų šifruoti ryšių turiniui. 5.5 pav. BB84 protokolo iliustracija Panagrinėkime BB84 protokolo (žr. 5.5 pav.) saugumą. Pirmiausia, uždraustojo kvantinių būsenų kopijavimo teorema garantuoja, kad Evelina negali patikimai kopijuoti Agnės siunčiamų kubitų. Jeigu tai būtų įmanoma, turėdama siunčiamų kubitų būsenų kopijas ir perėmus \\(b_A\\) ir \\(b_B\\) sekų komunikavimą tarp Agnės ir Beno ji galėtų atkurti raktą bei turinį. Sakykime, kad Evelina visgi pamėgina atlikti Agnės siunčiamų kubitų kopijavimą naudodama \\(cX\\) vartus. Jos pradinės kubitų būsenos yra \\(|0\\rangle\\), o po \\(cX\\) vartų ji toliau persiunčia Agnės kubitus Benui. Po šios transformacijos 2-kubitų būsenos yra: \\[\\begin{align} cX|\\psi_{00}\\rangle = &amp; |00\\rangle\\,;\\tag{5.27} \\\\ cX|\\psi_{10}\\rangle = &amp; |11\\rangle\\,;\\tag{5.28} \\\\ cX|\\psi_{01}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\,;\\tag{5.29} \\\\ cX|\\psi_{11}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|00\\rangle - |11\\rangle\\big)\\,.\\tag{5.30} \\end{align}\\] Evelina laukia, kol Benas atliks kubitų matavimą, galiausiai tai paveikia ir jos kubitų būseną. Toliau ji perima Agnės ir Beno klasikinę komunikaciją, kurioje jiedu atskleidžia, kokie baziniai vektoriai buvo naudojami šifruoti raktui ir atlikti matavimams. Evelina kartu su Agne ir Benu atmeta tuos kubitus, kuriuose \\(b_A\\) ir \\(b_B\\) nesutampa. Jos strategija yra toliau atlikti tokius pačius matavimus su savo turimais kubitais, kuriuos atliko Benas. Matome, kad Evelina sėkmingai atkuria \\(|\\psi_{00}\\rangle\\) ir \\(|\\psi_{10}\\rangle\\) būsenas, kurioms Benas atliko Pauli-\\(Z\\) matavimus. Deja, kvantinis supynimas paveikia Benui \\(|\\psi_{01}\\rangle\\) ir \\(|\\psi_{11}\\rangle\\) būsenų matavimo rezultatus, kurioms teisingai atkurti jis (atsitiktinai) pasirinktų Pauli-\\(X\\) matavimus. Pažvelkime į galimus Beno matavimo rezultatus, prieš tai atlikę \\(H\\) transformaciją: \\[\\begin{equation} \\begin{aligned} (H\\otimes I)|\\psi_{01}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\Big\\lbrack\\big(|0\\rangle + |1\\rangle\\big)\\otimes |0\\rangle + \\big(|0\\rangle - |1\\rangle\\big)\\otimes |1\\rangle\\Big\\rbrack \\\\ = &amp; \\frac{1}{\\sqrt{2}}\\Big\\lbrack |0\\rangle\\otimes\\big(|0\\rangle + |1\\rangle) + |1\\rangle\\otimes\\big(|0\\rangle - |1\\rangle\\big)\\Big\\rbrack\\,. \\end{aligned} \\tag{5.31} \\end{equation}\\] Antroje eilutėje pergrupavome narius, norėdami parodyti, kad yra 0.5 tikimybė, jog Benas atlikdamas matavimus ras \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\), nes \\(|0\\rangle\\) ir \\(|1\\rangle\\) yra lygios \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\) superpozicijos. Tačiau atlikdamas teisingą matavimą Agnės siųstai \\(|\\psi_{01}\\rangle\\) būsenai jis turėtų rasti \\(|0_x \\rangle\\) kiekvieną kartą. Šis nesutapimas tarp jųdviejų turimų \\(a_A\\) ir \\(a_B\\) bitų bus aptiktas Agnei ir Benui atliekant atsitiktinių \\(a\\) rakto bitų palyginimą protokolo pabaigoje. Tad nors Evelina šioje BB84 protokolo atakoje sugeba teisingai atkurti kiekvieną iš keturių skirtingų būsenų, kurias Benas randa pas save, tačiau kvantinis supynimas pakeičia Beno rezultatus ir įveda neatitikimus. Kadangi unitariosios transformacijos neatitinka norimo tikslo, antra galima Evelinos taktika – naudoti matavimo tipo transformacijas. BB84 protokolas uždaro ir šią spragą, kadangi naudoja neortogonaliąsias kvantines būsenas. Nežinodama, kokį matavimo būdą naudoti, Evelina gali pasirinkti, pavyzdžiui, visus perimtus Agnės kubitus pamatuoti Pauli-\\(Z\\) projekcija. Atlikus matavimą Evelina šiuos kubitus toliau persiunčia Benui, norėdama neišsiduoti, kad pasiklauso ryšio. Tačiau Pauli-\\(Z\\) matavimas, atliekamas \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\) būsenoms, neleidžia atskleisti, kokia yra būsena, kadangi atsitiktinai randamas \\(|0\\rangle\\) arba \\(|1\\rangle\\) su vienodomis tikimybėmis. Dar blogiau, kad Evelinos Pauli-\\(Z\\) matavimas negrįžtamai pakeičia \\(|0_x \\rangle\\) ir \\(|1_x \\rangle\\) kubitų būsenas į \\(|0\\rangle\\) arba \\(|1\\rangle\\). Agnė ir Benas, atlikdami atsitiktinai pasirinktų rakto bitų palyginimą protokolo pabaigoje, gali įvertinti, ar jų buvo pasiklausoma ir nutraukti arba kartoti protokolą iš naujo esant dideliam bitų nesutapimui. 5.4.2 EPR kvantinis rakto pasidalijimo protokolas EPR protokolas (žr. 5.6 pav.) yra dauguma aspektų panašus į BB84, tačiau tarp Agnės ir Beno nėra tiesioginio kvantinio ryšio kanalo. Vietoj jo naudojamas EPR šaltinis, paskirstantis tarp jų supintuosius kubitus. EPR protokole šis šaltinis paruošia \\(4n\\) supintąsias \\(|\\chi^{+}\\rangle\\) kubitų poras ir iš kiekvienos poros nusiunčia po vieną kubitą Agnei ir Benui. Pradžioje jie abu turi po \\(4n\\) supintųjų kubitų, kurių kiekvienas yra būsenoje: \\[\\begin{equation} |\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\,. \\tag{5.32} \\end{equation}\\] Agnė ir Benas atsitiktiniu būdu pasirenka išmatuoti savo visus turimus kubitus santykinai su Pauli-\\(Z\\) arba Pauli-\\(X\\) baziniais vektoriais. Taip jie sugeneruoja bitų sekas {\\(a_A\\), \\(b_A\\)} ir {\\(a_B\\), \\(b_B\\)}; čia \\(b\\) bitas nusako, ar buvo pasirinktas Pauli-\\(Z\\) (0) ar Pauli-\\(X\\) (1) matavimas, o \\(a\\) bitas nusako gautą rezultatą (0 arba 1). Iš to matome, kad jeigu Agnės ir Beno atsitiktiniai matavimo būdo pasirinkimai sutapo, šių kubitų porų būsenas jie visada ras vienodas, ir todėl jų atitinkami rakto bitai sutaps. Tai akivaizdu žvelgiant į \\(|\\chi^{+}\\rangle\\) ir naudojant Pauli-\\(Z\\) matavimus. Norėdami atlikti Pauli-\\(X\\) matavimus abiem kubitams \\(|\\chi^{+}\\rangle\\) Belo būsenoje pirmiausia atlikime Hadamardo vartus: \\[\\begin{equation} \\begin{aligned} H\\otimes H|\\chi^{+}\\rangle = &amp; \\frac{1}{2\\sqrt{2}}\\Big\\lbrack\\big(|0\\rangle + |1\\rangle\\big)\\otimes\\big(|0\\rangle + |1\\rangle\\big) + \\big(|0\\rangle - |1\\rangle\\big)\\otimes\\big(|0\\rangle - |1\\rangle\\big)\\Big\\rbrack \\\\ = &amp; \\frac{1}{\\sqrt{2}}\\big\\lbrack|0\\rangle\\otimes |0\\rangle + |1\\rangle\\otimes |1\\rangle\\big\\rbrack\\,. \\end{aligned} \\tag{5.33} \\end{equation}\\] Matome, kad Pauli-\\(X\\) matavimuose taip pat yra ideali koreliacija tarp dviejų kubitų būsenų, tad atlikus norimus matavimus jų vertės visada sutaps. Tolimesni žingsniai paremti BB84 protokolu: Agnė ir Benas per klasikinį kanalą palygina \\(b_A\\) ir \\(b_B\\) šifravimo bitus ir pasilieka tuos \\(2n\\) rakto bitų, kuriems šifravimo bitai sutapo, \\(a_A = a_B\\). Galiausiai jiedu atsitiktinai pasirenka iš turimų \\(2n\\) rakto bitų \\(n\\) bitų ir palygina, ar jie sutampa, siekdami įvertinti, ar ryšys patikimas. 5.6 pav. EPR protokolo iliustracija Šiuo atveju Evelina gali pabandyti įsiterpti perimdama abu kubitus poroje, skirtus Agnei ir Benui. Evelina atlieka kubitų būsenų matavimą ir toliau jiems persiunčia jau nebesupintus, o klasiškai koreliuotus kubitus, taip tiksliai žinodama, kokie bus Agnės ir Beno rezultatai. Tačiau Evelinos įsiterpimas pakeičia jų rezultatus. Pavyzdžiui, jeigu Evelina atlikusi Pauli-\\(Z\\) matavimus randa \\(|00\\rangle\\) kubitų būseną, tada Agnė ir Benas, atlikę Pauli-\\(Z\\) neaptinka nesutapimų. Na, o jeigu jie atsitiktinai abu pasirenka Pauli-\\(X\\) matavimą \\(|00\\rangle\\) būsenai, tada 0.5 jų matavimų rezultatai nesutaps, nes yra lygi tikimybė rasti \\(|0_x \\rangle\\) arba \\(|1_x \\rangle\\) būsenas. Atlikdami šifravimo ir rakto bitų patikrą Agnė ir Benas tai gali pastebėti ir nutraukti protokolą. Agnės ir Beno matavimo rezultatų nesutapimai gali atsirasti ir dėl kitų išorinių veiksnių, kurie įveda ryšio signalui triukšmą. Praktikoje jiems reikia būdo patikrinti supintosios kvantinės būsenos tikslumą. Kituose poskyriuose smulkiau panagrinėsime supintųjų kubitų savybes ir aptarsime, kaip įmanoma patikrinti būsenų tikslumą, taip pat ar jos pasižymi ryšiuose pageidaujamomis kvantinėmis koreliacijomis. 5.5 Lokalios operacijos ir klasikiniai ryšiai EPR šaltiniai kvantiniuose tinkluose yra nepamainomi, ir dėl to svarbu įvertinti jų tikslumą. Jeigu yra galimybė tai atlikti kubitams vos palikus EPR šaltinį, tada galime apskaičiuoti būsenų tikslumą (angl. state fidelity) palygindami sugeneruotą 2-kubitų būseną su grynąja Belo būsena \\(|\\psi\\rangle\\), kuri, tikimasi, turėtų būti ir EPR šaltinio sugeneruota. Vienas būdas tai apskaičiuoti: \\[\\begin{equation} F\\lbrack\\rho ,|\\psi\\rangle\\rbrack = \\sqrt{\\langle\\psi |\\rho |\\psi\\rangle}\\,. \\tag{5.34} \\end{equation}\\] Tikslumas \\(F\\) nusako būsenų persiklojimą ir yra apibrėžtas intervale \\(0 \\leq F \\leq 1\\). \\(F = 0\\) reiškia, kad būsenos yra ortogonaliosios (maksimaliai skirtingos), o \\(F = 1\\) – kad jos fiziškai vienodos. Čia išreiškiame EPR sugeneruotą būseną tankio operatoriumi \\(\\rho = |\\phi\\rangle\\langle\\phi |\\), nes dėl paruošimo netikslumų ar kitų mums nežinomų veiksnių ji gali būti mišri. Matome, kad tikslumas \\(F\\) nusako persiklojimo tarp būsenų \\(\\rho\\) ir \\(|\\psi\\rangle\\) šaknį. Supintųjų kubitų patikrinimą taip pat galima atlikti teleportuojant Beno kubitą pas Agnę, šitaip ji atliktų Belo matavimą. Tačiau tam reikalinga dar viena Belo būsena. Jeigu Agnė ir Benas yra galutiniai Belo būsenų vartotojai, neturintys tokios galimybės, tada patikrinti šaltinio tikslumui ar kvantinio ryšio kanalo švarumui jiems reikalingas kitas būdas. Imkime standartinį scenarijų, kuriame Agnė ir Benas neturi tarpusavyje kvantinio kanalo ir gali savo individualiems kubitams, gautiems iš EPR šaltinio, atlikti tik lokalias unitariąsias transformacijas bei matavimus ir tarpusavyje komunikuoti klasikiniu būdu. Pavyzdžiui, atlikęs norimą matavimą Benas gali rezultatą pranešti Agnei. Pagal gautą rezultatą, ji savo ruožtu pasirenka norimą transformaciją ar matavimo būdą, siekdama sužinoti kuo daugiau informacijos apie jų turimą kvantinę būseną. Tai yra vadinamasis lokalių operacijų ir klasikinių ryšių metodas kvantinėje informatikoje (angl. local operations classical communication, trumpinys LOCC). Toliau aptarkime, kokias LOCC operacijas Agnė ir Benas gali atlikti norėdami patikrinti keturias Belo būsenas: \\[\\begin{align} |\\chi^{+}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\,,\\quad |\\chi^{-}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle - |11\\rangle\\big)\\,;\\tag{5.35}\\\\ |\\eta^{+}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big(|01\\rangle + |10\\rangle\\big)\\,,\\quad |\\eta^{-}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle - |10\\rangle\\big)\\,.\\tag{5.36} \\end{align}\\] Kaip ir skaičiuojamieji 2 kubitų baziniai vektoriai {\\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\), \\(|11\\rangle\\)}, Belo baziniai vektoriai {\\(|\\chi^{+}\\rangle\\), \\(|\\chi^{-}\\rangle\\), \\(|\\eta^{+}\\rangle\\), \\(|\\eta^{-}\\rangle\\)} kiekvienas individualiai savyje koduoja maksimaliai du bitus klasikinės informacijos. Standartiniame rinkinyje kiekvieną iš dviejų kubitų unikaliai nusako jų reikšmės 0 ir 1. Norint nusakyti supintąsias Belo būsenas akivaizdu, kad tai netinka dėl esamų superpozicijų. Belo rinkinyje pirmasis bitas nusako būsenų lyginumą (angl. parity bit), kuris parodo, ar kubitų būsenos nariuose vienodos, ar skirtingos. Lyginį lyginumą (angl. even parity) turi \\(|\\chi^{+}\\rangle\\) ir \\(|\\chi^{-}\\rangle\\) būsenos, nes abu kubitai jų nariuose \\(|00\\rangle\\) ir \\(|11\\rangle\\) yra lygūs. Nelyginius lyginumus (angl. odd parity) turi \\(|\\eta^{+}\\rangle\\) ir \\(|\\eta^{-}\\rangle\\), sudaryti iš \\(|01\\rangle\\) ir \\(|10\\rangle\\) narių superpozicijos nelygiose būsenose. Antrasis bitas informacijos Belo būsenose yra vadinamas fazės bitu (angl. phase bit). Būsenos \\(|\\chi^{+}\\rangle\\) ir \\(|\\eta^{+}\\rangle\\) turi tokį patį fazės bitą (+), nes nariai yra sudedami (santykinė fazė lygi nuliui). Būsenose \\(|\\chi^{-}\\rangle\\) ir \\(|\\eta^{-}\\rangle\\) nariai yra atimami (santykinė fazė \\(\\pi\\)) ir todėl jų fazės bitas yra priešingas \\(|\\chi^{+}\\rangle\\) ir \\(|\\eta^{+}\\rangle\\) būsenoms (-). Tad norėdami nusakyti Belo būsenas dviem bitais informacijos galime susieti lyginį ir nelyginį lyginumą su pirmo bito 0 ir 1 vertėmis, taip pat + ir – fazės bitus su antro bito 0 ir 1 vertėmis. Tai leidžia unikaliai įvardyti visas keturias Belo būsenas. Kitas svarbus aspektas yra tai, kad supintosiose Belo būsenose lyginumo ir fazės bitus galima keisti atliekant vien lokalias unitariąsias transformacijas vienam iš pasirinktų kubitų, nepaisant atstumo tarp dviejų kubitų. Pavyzdžiui, Agnė, turinti \\(|\\chi^{+}\\rangle\\) būseną, gali pakeisti lyginumo bitą iš 0 į 1 atlikdama savo kubitui Pauli-\\(X\\) transformaciją. Arba tą patį gali padaryti Benas. Norėdami pakeisti fazės bitą iš 0 į 1, bet kuris iš jų atliktų Pauli-\\(Z\\) transformaciją. Pauli-\\(Y\\) transformacija pakeistų lyginumo ir fazės bitus kartu. Apačioje pateikiame lyginumo ir fazės bitų keitimo transformacijas pirmam kubitui \\(|\\chi^{+}\\rangle\\) būsenoje: \\[\\begin{align} (X\\otimes I)|\\chi^{+}\\rangle = &amp; |\\eta^{+}\\rangle\\,;\\tag{5.37} \\\\ (Y\\otimes I)|\\chi^{+}\\rangle = &amp; -\\mathrm{i}|\\eta^{-}\\rangle\\,;\\tag{5.38} \\\\ (Z\\otimes I)|\\chi^{+}\\rangle = &amp; |\\chi^{-}\\rangle\\,.\\tag{5.39} \\end{align}\\] Primename, kad globali būsenos fazė nėra svarbi, tad \\(-\\mathrm{i}|\\eta^{-}\\rangle\\) ir \\(|\\eta^{-}\\rangle\\) nusako identiškas kvantines būsenas. Tad vien lokaliomis transformacijomis viena iš dalyvaujančių šalių gali Belo būseną pakeisti į bet kurią kitą Belo būseną. Atkreipiame dėmesį, kad lokalios unitarinės trasformacijos negali panaikinti supynimo, tad pradedant iš Belo būsenų visos taip pasiekiamos būsenos yra supintosios. Šį rezultatą galima palyginti su faktorizuojamomis būsenomis standartiniuose baziniuose vektoriuose, pavyzdžiui, \\(|00\\rangle\\). Agnė gali keisti savo turimo kubito vertę tarp 0 ir 1, todėl jos lokalios transformacijos leidžia pasiekti \\(|00\\rangle\\) ir \\(|10\\rangle\\) būsenas. Tačiau be Beno pagalbos ji negali globaliai pakeisti \\(|00\\rangle\\) būsenos į \\(|01\\rangle\\) arba \\(|11\\rangle\\). Individualiomis lokaliomis transformacijomis nesupintojoje būsenoje šiuo atveju įmanoma keisti tik vieną bitą informacijos, o ne du, kaip supintosiose. Grįžtant prie būsenų patikros, imkime situaciją, kurioje Agnė ir Benas, turėdami po vieną kubitą iš nežinomos Belo būsenos ir taikydami LOCC metodą nori sužinoti, kokia tai būsena. Pradėdama paprasčiausiu būdu, Agnė pasirenka atsitiktinai pamatuoti savo kubitą naudodama \\(P = |0\\rangle\\langle 0| \\otimes I\\). Dėl šios priežasties nežinoma Belo būsena pasikeis į \\(|00\\rangle\\) arba \\(|01\\rangle\\). Akivazdu, kad nežiūrint, kokį matavimą pasirinks Benas, jie galės pasakyti tik turimos Belo būsenos lyginumo bitą. Fazės bito šiais matavimais jie sužinoti negali, tad ir įvardyti Belo būsenos nepavyks. Agnė ir Benas vis dėlto gali sužinoti supintosios būsenos lyginumo ir fazės bitus LOCC metodu paaukodami dvi supintąsias būsenas, o ne vieną. Tam darome prielaidą, kad EPR šaltinis siunčia identiškas būsenas. Gavę po vieną kubitą iš pirmosios Belo būsenos poros, jie abu atlieka Pauli-\\(Z\\) matavimą savo kubitams, o tikrines vertes sudaugina. Primename, kad atliekant Pauli-\\(Z\\) matavimus individualiems kubitams galimos tikrinės vertės yra +1 (\\(|0\\rangle\\) būsena) arba -1 (\\(|1\\rangle\\) būsena). Matome, kad jeigu Belo būsenos lyginumas yra lyginis, tada Pauli-\\(Z\\) tikrinių verčių sandauga yra 1, o jeigu nelyginis, gaunama -1. Naudojant Pauli-\\(X\\) matavimą antrajai (identiškai) Belo būsenai jie gali rasti ir fazės bitą. Šiuo atveju, jeigu būsenos fazė yra 0, tada tikrinių verčių sandauga yra 1, o jeigu \\(\\pi\\) – gaunama -1. Norėdami pademonstruoti fazės bitų matavimą imkime \\(|\\chi^{+}\\rangle\\) ir \\(|\\chi^{-}\\rangle\\) būsenas. Pauli-\\(X\\) matavimas atliekamas pirmiausia pritaikius abiems kubitams Hadamardo vartus: \\[\\begin{align} (H\\otimes H)|\\chi^{+}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big\\lbrack|0\\rangle\\otimes |0\\rangle + |1\\rangle\\otimes |1\\rangle\\big\\rbrack\\,;\\tag{5.40}\\\\ (H\\otimes H)|\\chi^{-}\\rangle = &amp; \\frac{1}{\\sqrt{2}}\\big\\lbrack|0\\rangle\\otimes |1\\rangle + |1\\rangle\\otimes |0\\rangle\\big\\rbrack\\,.\\tag{5.41} \\end{align}\\] Tada atlikę įprastą Pauli-\\(Z\\) matavimą matome, kad \\(|\\chi^{+}\\rangle\\) ir \\(|\\chi^{-}\\rangle\\) būsenose tikrinių verčių sandauga bus +1 ir -1, atitinkamai. Agnė ir Benas, paaukoję dalį supintųjų kubitų, gali dviem matavimo būdais ir tarpusavio ryšiu tiksliai pasakyti, kokią būseną jiems siunčia EPR šaltinis. Neatitikimai tarp Agnės ir Beno matavimų yra indikatorius, kad šaltinis nėra tikslus ar būsenos yra pažeidžiamos duomenims keliaujant kvantiniu kanalu. Pabandykime suprasti, kodėl LOCC metodu reikia paaukoti du kubitus. Kaip žinome, 1 kubito skaičiuojamieji baziniai vektoriai yra Pauli-\\(Z\\) operatoriaus tikriniai vektoriai, \\(Z|0\\rangle = |0\\rangle\\), \\(Z|1\\rangle = -|1\\rangle\\). Todėl Pauli-\\(Z\\) matavimas, atliekamas vienam iš jo bazinių vektorių, nepakeičia šio vektoriaus ir užtikrintai nusako, kokia tai būsena. Tačiau lokalūs Pauli matavimai vienam iš kubitų Belo būsenose pakeičia bendrą 2 kubitų būseną ir sunaikina supynimą, kadangi jos nėra lokaliųjų Pauli operatorių tikriniai vektoriai. Tad reikalingos dvi supintosios būsenos kopijos ir du lokalūs matavimai, nusakantys lyginumo ir fazės bitus. Belo būsenos yra operatorių \\(\\bar{X} = X\\otimes X\\), \\(\\bar{Y} = Y\\otimes Y\\) ir \\(\\bar{Z} = Z\\otimes Z\\) tikriniai vektoriai: \\[\\begin{align} \\bar{X}|\\chi^{\\pm}\\rangle = &amp; \\pm |\\chi^{\\pm}\\rangle\\,,\\quad \\bar{Y}|\\chi^{\\pm}\\rangle = \\mp |\\chi^{\\pm}\\rangle\\,,\\quad \\bar{Z}|\\chi^{\\pm}\\rangle = |\\chi^{\\pm}\\rangle\\,;\\tag{5.42}\\\\ \\bar{X}|\\eta^{\\pm}\\rangle = &amp; \\pm |\\eta^{\\pm}\\rangle\\,,\\quad \\bar{Y}|\\eta^{\\pm}\\rangle = \\pm |\\eta^{\\pm}\\rangle\\,,\\quad \\bar{Z}|\\eta^{\\pm}\\rangle = -|\\eta^{\\pm}\\rangle\\,.\\tag{5.43} \\end{align}\\] Trys operatoriai \\(\\bar{X}, \\bar{Y}\\) ir \\(\\bar{Z}\\) yra tarpusavyje komutatyvūs, todėl atlikus \\(\\bar{X}\\) ir \\(\\bar{Z}\\) matavimus sekoje Belo būsenai dvi gautos tikrinės vertės ją unikaliai atskirtų nuo kitų nesugriaunant pačios būsenos. Tačiau \\(\\bar{X}, \\bar{Y}\\) ar \\(\\bar{Z}\\) projekciniai matavimai yra nelokalūs – tai yra ne tas pats, kas atlikti du lokalius matavimus ir tikrines vertes sudauginti. Kvantiniame kompiuteryje projekciniai Belo būsenų matavimai atliekami kombinacija, susidedančia iš nelokalios unitarinės transformacijos \\(cX\\), lokalių \\(H\\) bei įprastinio Pauli-\\(Z\\) matavimo abiem kubitams. 5.6 Belo nelygybės testas A. Einšteinas nepasidavė idėjai, kad gamtoje fundamentaliai gali egzistuoti nedeterminizmas ir nuotolinė įtaka (angl. spooky action at a distance), apsireiškiantys supintų kvantinių būsenų matavimuose. Dėl to jis laikėsi pozicijos, kad kvantinė mechanika nors ir teisinga, bet vis dėlto negali būti išsami teorija. Siekdamas patikrinti, ar alternatyvios deterministinės teorijos, įkomponuojančios paslėptus lokalius kintamuosius, sugebėtų atkurti kvantinių koreliacijų efektus, Johnas Bellas 1970-aisiais išvedė vadinamąją Belo nelygybę (angl. Bell inequality). Be fundamentaliųjų tyrimų srities, Belo nelygybių klasės testai yra taikomi praktiškai siekiant patikrinti, ar sugeneruotos 2 kubitų būsenos yra supintosios. Eksperimentuose standartiškai naudojama Belo nelygybės versija, vadinama CHSH (angl. J. Clauser, M. Horne, A. Shimony, R. Holt), kuri labiau tinka atlikti testams su šviesos nešėjais fotonais. Toliau pateikiame CHSH nelygybės supaprastintą įrodymą ir jos testo protokolą, naudojantį supintuosius fotoninius kubitus. Įsivaizduokime scenarijų, kuriame Cita paruošia dvi sistemas ir neatskleisdama paruošimo būdo pateikia vieną Agnei, o kitą Benui. Šioje stadijoje nedarome jokių prielaidų, kokios tai sistemos ir kokiaiss gamtos dėsniais jos paremtos. Agnė ir Benas, abu gavę po vieną sistemą, atsitiktiniu būdu renkasi pamatuoti šių sistemų vieną iš savybių. Šitos savybės yra objektyvios ir gali būti atskleistos atlikus matavimus. Klasikinės savybės būtų, pavyzdžiui, geometrinė forma ar svoris. Agnės galimus pasirinkimus vadinsime \\(A_1\\) ir \\(A_2\\), Beno – \\(B_1\\) ir \\(B_2\\). Kiekvienos iš šių keturių savybių galimi matavimų rezultatai yra įvardijami skaitmeniškai, +1 arba -1. Beno sistema bei jos matuojamos savybės \\(B_1\\) ir \\(B_2\\) gali skirtis nuo Agnės \\(A_1\\) ir \\(A_2\\), tai nėra svarbu. Svarbu tik tai, kad Cita gali paruošti šias dvi sistemas identiškai \\(n\\) kartų. Kiekvieno paruošimo metu ji savo nuožiūra pasirenka, kokios bus matuojamų sistemų savybės (\\(A_1\\) ar \\(A_2\\), \\(B_1\\) ar \\(B_2\\)). Agnė ir Benas atlieka atsitiktiniu būdu pasirinktos savybės matavimus tuo pačiu metu ir būdami labai toli vienas nuo kito. Agnė ir Benas pakartoja šiuos matavimus \\(n\\) kartų ir susitikę apskaičiuoja aritmetinius vidurkius keturių skirtingų narių: \\(A_1 B_1\\), \\(A_2B_1\\), \\(A_1 B_2\\), \\(A_2 B_2\\). Pavyzdžiui, jeigu vienam iš bandymų Agnė pasirinko \\(A_1\\) savybės matavimą (rezultatas +1 arba -1), o Benas \\(B_2\\) matavimą (rezultatas +1 arba -1), tada šios \\(A_1 B_2\\) matavimų poros rezultatus jie sudaugina ir gauna +1 arba -1. Aritmetinį \\(A_1 B_2\\) matavimo porų vidurkį, vadinsime jį \\(\\langle A_1 B_2 \\rangle\\), jie randa sudėję visus šios atsirandančios sandaugos rezultatus ir padaliję iš skaičiaus, kuris nusako, kiek kartų \\(A_1 B_2\\) matavimo pora buvo atlikta. Nariai \\(\\langle A_1 B_2 \\rangle\\) nusako koreliacijas tarp šių matuojamų savybių. Jeigu, pavyzdžiui, \\(A_1\\) ir \\(B_2\\) matavimais rastos savybės idealiai koreliuoja (antikoreliuoja), tada jų sandauga \\(A_1 B_2\\) ir vidurkis \\(\\langle A_1 B_2 \\rangle\\) visada bus +1 (-1). Tačiau, jeigu \\(A_1\\) ir \\(B_2\\) matavimų rezultatai ir todėl jų sandaugų vertės vis atsitiktinai keičiasi tarp +1 ir -1, tada koreliacija tarp šių pamatuotų savybių bus mažesnė arba koreliacijos išvis nebus. Nežiūrėdami į Agnės ir Beno rezultatus pabandykime įvertinti Citos paruoštos vienos atskiros serijos galimus atsakymus. Tam sudėsime tris pirmus narius bei atimsime paskutinįjį: \\[\\begin{equation} C = A_1 B_1 + A_2 B_1 + A_1 B_2 - A_2 B_2 = (A_1 + A_2)B_1 + (A_1 - A_2)B_2\\,. \\tag{5.44} \\end{equation}\\] Matome, kad jeigu \\(A_1\\) ir \\(A_2\\) vertės yra skirtingos, gausime \\(A_1 + A_2 = 0\\) ir \\(A_1 - A_2 = \\pm 2\\). Tačiau, jeigu jos yra vienodos, \\(A_1 + A_2 = \\pm 2\\) ir \\(A_1 - A_2 = 0\\). Todėl, priklauso nuo rastų \\(A_1\\) ir \\(A_2\\) verčių, \\(C\\) gali būti tik +2 arba -2. Akivaizdu, kad atskirų \\(C\\) serijų vidurkio absoliučioji vertė \\(|\\langle C\\rangle|\\) gali būti ir mažiau nei 2, tad bendrai \\(|\\langle C\\rangle| \\leq 2\\). Panaudodami vidurkių apibrėžimą, \\(\\langle C\\rangle = \\langle A_1 B_1 \\rangle + \\langle A_2 B_1 \\rangle + \\langle A_1 B_2 \\rangle - \\langle A_2 B_2 \\rangle\\), gauname CHSH nelygybę: \\[\\begin{equation} |\\langle A_1 B_1 \\rangle + \\langle A_2 B_1 \\rangle + \\langle A_1 B_2 \\rangle - \\langle A_2 B_2 \\rangle| \\leq 2\\,. \\tag{5.45} \\end{equation}\\] Agnė ir Benas, po daugelio matavimų radę individualius vidurkius \\(\\langle A_i B_j \\rangle,\\) gali įvertinti, ar koreliacijos tarp jų matuojamų sistemų savybių tenkina CHSH nelygybę. CHSH nelygybė buvo išvesta darant dvi prielaidas apie sistemas, kurių koreliacijas ji analizuoja. Pirmoji prielaida, vadinama realizmu (angl. realism), įvardija, kad sistemos savybės yra tiksliai apibrėžtos ir egzistuoja nepriklausomai nuo to, ar jos yra stebimos, ar ne. Tai matome iš prielaidos, kad visos keturios savybės \\(\\{A_1 , A_2 , B_1 , B_2 \\}\\) jau prieš Agnei ir Benui jas atskleidžiant turi deterministines vertes +1 arba -1, nustatytas iš anksto Citos. Antra, vadinamoji lokalumo (angl. locality), prielaida įvardija, kad tik artimoji sistemos aplinka gali daryti įtaką jos būsenai ( to reikalauja reliatyvumo teorija). Dėl didelio atstumo tarp Agnės ir Beno lokacijų, kuriose jiedu atlieka sistemos savybių matavimus, jų rasti rezultatai negali paveikti vienas kito. Antraip reliatyvumo teorijos pamatinė aksioma, tvirtinanti, kad niekas negali sklisti greičiau už šviesos greitį, būtų pažeista. Priimant realizmą bei lokalumą, visos gamtoje egzistuojančios sistemos turėtų tenkinti CHSH nelygybę. Klasikinės sistemos tenkina šias, mums visiems intuityvias, prielaidas. Panagrinėkime, ar šią nelygybę tenkina kvantinės sistemos. Imkime dviejų fotonų Belo būseną \\(|\\chi^{+}\\rangle\\), kurioje kubitų būsenos \\(|0\\rangle\\) ir \\(|1\\rangle\\) nusako fotono vertikalią ir horizontalią poliarizacijas, atitinkamai. Pervadiname būsenas taip \\(|0\\rangle\\rightarrow |V\\rangle\\), \\(|1\\rangle\\rightarrow |H\\rangle\\): \\[\\begin{equation} |\\chi^{+}\\rangle = \\frac{1}{\\sqrt{2}}\\big(|VV\\rangle + |HH\\rangle\\big)\\,. \\tag{5.46} \\end{equation}\\] Siekdami patikrinti CHSH nelygybę, Agnė ir Benas taiko keturias detektorių poliarizacijos matavimo konfigūracijas, kurios yra \\(A_1 , A_2 , B_1 , B_2\\) sistemos savybių atitikmuo. Šiame eksperimente atstumai tarp Agnės ir Beno detektorių vėlgi yra dideli, užtikrinant, kad gauti poliarizacijos rezultatai negali paveikti vienas kito. Kiekvienam bandymui Agnė savo detektoriuje atsitiktiniu būdu pasirenka kampą \\(\\alpha_1\\) arba \\(\\alpha_2\\), o Benas \\(\\beta_1\\) arba \\(\\beta_2\\). 5.7 pav. iliustruojame dvi tokias detektorių konfigūracijas, pasuktas kampu \\(\\alpha\\) ir \\(\\beta\\): 5.7 pav. Koordinačių sistemos pasukimas kampais \\(\\alpha\\) ir \\(\\beta\\) pradinės koordinačių sistemos atžvilgiu. Pradinė koordinačių sistema apibrėžia horizontaliosios ir vertikaliosios poliarizacijos kryptis Matome, kad poliarizacijos matavimai Agnės ir Beno detektoriuose yra pasukami pagal laikrodžio rodyklę nurodytais kampais vertikalios ašies lygiagrečios \\(|V\\rangle\\) atžvilgiu, išlaikant statųjį kampą tarp naujų \\(|V\\rangle\\) ir \\(|H\\rangle\\) ašių. Naujos vertikali ir horizontali poliarizacijos būsenos, pasuktos kampu \\(\\alpha\\) pradinių būsenų \\(|V\\rangle\\) ir \\(|H\\rangle\\) atžvilgiu yra lengvai randamos: \\[\\begin{align} |V^{\\alpha}\\rangle = &amp; \\cos(\\alpha)|V\\rangle + \\sin(\\alpha)|H\\rangle\\,;\\tag{5.47} \\\\ |H^{\\alpha}\\rangle = &amp; -\\sin(\\alpha)|V\\rangle + \\cos(\\alpha)|H\\rangle\\,.\\tag{5.48} \\end{align}\\] Tada ermitinis operatorius \\(P(\\alpha)\\), nusakantis poliarizacijos dydžius išilgai naujų, pasuktų kampu \\(\\alpha\\) ašių, išreikštas spektrinėje dekompozicijoje, yra: \\[\\begin{equation} P(\\alpha) = |V^{\\alpha}\\rangle\\langle V^{\\alpha}| - |H^{\\alpha}\\rangle\\langle H^{\\alpha}|\\,. \\tag{5.49} \\end{equation}\\] Lygtyje (5.49) \\(|V^{\\alpha}\\rangle\\langle V^{\\alpha}|\\) ir \\(|H^{\\alpha}\\rangle\\langle H^{\\alpha}|\\) yra diados, nusakančios projekcijas į vertikaliai ir horizontaliai poliarizuotų būsenų poerdves. Šie operatoriai nusako \\(|V\\rangle\\) ir \\(|H\\rangle\\) būsenų matavimą skirtinguose baziniuose vektoriuose – analogišku principu naudojami ir Pauli-\\(Z\\) arba Pauli-\\(X\\) matavimai kriptografijos protokoluose. Kaip ir Pauli-\\(Z\\) operatoriuje, jeigu randama vertikali \\(|V^{\\alpha}\\rangle\\) arba horizontali \\(|H^{\\alpha}\\rangle\\) poliarizacija, tada fiksuojama atitinkamai +1 arba -1 vertės. Identiškai randami ir kiti trys matavimo operatoriai, nusakantys skirtingus Agnės ir Beno detektoriaus pasukimo kampus \\(\\alpha\\) ir \\(\\beta\\). Siekdami įvertinti \\(\\langle AB\\rangle\\) koreliacijų koeficientus skirtingose fotonų matavimo konfigūracijose apskaičiuojame: \\[\\begin{equation} \\langle\\alpha\\beta\\rangle = \\langle\\chi^{+}|P(\\alpha)\\otimes P(\\beta)|\\chi^{+}\\rangle\\,. \\tag{5.50} \\end{equation}\\] Panaudoję viršuje išreikštus \\(P(\\alpha)\\) ir atlikę šiek tiek algebros veiksmų randame, kad dviejų matavimų tikrinių verčių sandaugos vidurkis priklauso tik nuo skirtumo tarp detektorių pasukimo kampų: \\[\\begin{equation} \\langle\\alpha\\beta\\rangle = \\cos\\lbrack 2(\\alpha - \\beta)\\rbrack\\,. \\tag{5.51} \\end{equation}\\] Fotoninėse Belo būsenose CHSH nelygybė yra pažeidžiama didžiausia verte, kai skirtumai tarp kampų keturiose konfigūracijose skiriasi \\(22.5^{\\circ}\\) laipsnio. Čia renkamės \\(\\alpha_1 = 22.5^{\\circ}\\), \\(\\alpha_2 = 45^{\\circ}\\), \\(\\beta_1 = 67.5^{\\circ}\\), \\(\\beta_2 = 90^{\\circ}\\). Tada koreliacijos koeficientai yra \\(\\langle\\alpha_1 \\beta_1 \\rangle = \\langle\\alpha_2 \\beta_1 \\rangle = \\langle\\alpha_1 \\beta_2 \\rangle = 1/\\sqrt{2}\\), \\(\\langle\\alpha_2 \\beta_2 \\rangle = - 1/\\sqrt{2}\\), ir randame \\(|\\langle C \\rangle\\)|: \\[\\begin{equation} |\\langle\\alpha_1 \\beta_1 \\rangle + \\langle\\alpha_2 \\beta_1 \\rangle + \\langle\\alpha_1 \\beta_2 \\rangle - \\langle\\alpha_2 \\beta_2 \\rangle | = 2\\sqrt{2}\\,. \\tag{5.52} \\end{equation}\\] Akivaizdu, kad CHSH nelygybė, \\(|\\langle C\\rangle| \\leq 2\\), nėra tenkinama supintosiose kvantinėse sistemose. Tai parodo, kad CHSH nelygybės įrodyme daromos realizmo ir lokalumo prielaidos apie sistemą negali būti teisingos. Realizmo prielaida atsiremia į kvantinės mechanikos trečiąjį postulatą, kuris teigia, kad matavimas priverčia sistemą, esančią būsenų superpozicijoje, pasirinkti (nedeterministiškai) vieną iš galimų būsenų. Kvantinė mechanika taip pat meta iššūkį mums suprantam lokalumui. Belo nelygybės eksperimentiniai testai ne kartą parodė, kad kvantinei mechanikai alternatyvios deterministinės lokalios paslėptų kintamųjų teorijos nesugeba atkurti stebimų koreliacijų. Tai palaiko argumentą, kad nėra paslėptų ar kažkaip mums pro pirštus praslydusių veiksnių, kuriuos įtraukus būtų galima visada tiksliai atspėti būsenų matavimo rezultatus. Kadangi koreliacijų supintuosiuose kubituose negali imituoti jokia klasikinė sistema ar klasiškai koreliuota kvantinė sistema, CHSH nelygybės testas suteikia būdą įvertinti kvantinio supynimo egzistavimui, reikalingą vykdyti kvantinių ryšių protokolus. "],["skaičiavimai-kvantiniu-kompiuteriu.html", "6 skyrius. Skaičiavimai kvantiniu kompiuteriu 6.1 Bazinių vektorių numeracija 6.2 Funkcinis skaičiavimas 6.3 Kvantinis paralelizmas 6.4 Duomenų kodavimo būdai 6.5 Doičo algoritmas 6.6 Kvantinė paieška ir Groverio algoritmas 6.7 Hadamardo ir SWAP testai", " 6 skyrius. Skaičiavimai kvantiniu kompiuteriu Šiame skyriuje supažindiname su funkciniais skaičiavimais kvantiniu kompiuteriu ir parodome keletą žymių kvantinių algoritmų. Šie algoritmai leidžia geriau suprasti kvantinį skaičiavimo modelį ir naudojamus triukus bei ugdyti „kvantinę intuiciją” sudėtingesnėms užduotims spręsti. 6.1 Bazinių vektorių numeracija Pirmiausiai pristatysime nomenklatūras, naudojamas numeruoti n kubitų registro baziniams vektoriams, ir jų konvertavimą tarp dvejetainės ir dešimtainės skaičių sistemų. Kvantinio registro, sudaryto iš \\(n\\) kubitų, bendra būsena \\(|\\psi\\rangle\\) yra \\(2^n\\) ortogonaliųjų bazinių vektorių superpozicija. Praeitų skyrių pavyzdžiuose dažnai naudojome 2 kubitų skaičiuojamąjį rinkinį {\\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\), \\(|11\\rangle\\)}. Esant dideliam kubitų skaičiui taip rašyti vektorius tampa nepraktiška, nes kiekvienas bazinis vektorius \\(|\\cdots\\rangle\\) bus sudarytas iš ilgos \\(n\\) dvejetainių skaičių sekos. Be to, neretai atsiranda poreikis perteikti ar atlikti operacijas su dešimtainiais skaičiais. Kvantinėje kompiuterijoje dažnai naudojami du skirtingi būdai konvertuoti tarp šių skaičių sistemų. Kubitų numeracija juose skiriasi, ir todėl loginių vartų išraiškos skirsis. Fizikoje yra įprasta atlikti \\(n\\) kubitų numeraciją taip: \\(|k_1 k_2 \\cdots k_{n - 1} k_n \\rangle\\); čia \\(k_i \\in \\{0,1\\}\\). Pirmojo kubito, nusakyto pačios viršutinės kvantinės grandinės, būsena \\(k_1\\) yra rašoma ket kairėje ir paeiliui užbaigiama paskutiniuoju kubitu \\(k_n\\) dešinėje. Šį būdą mes naudojome knygoje iki šiol. Norint perteikti tokią būseną dešimtaine forma \\(|x\\rangle\\), \\(x \\in \\mathbb{N}\\): \\[\\begin{equation} |x\\rangle = |k_1 k_2 \\cdots k_{n - 1}k_n \\rangle \\tag{6.1} \\end{equation}\\] taikome formulę, konvertuojančią dešimtainį skaičių į dvejetainį: \\[\\begin{equation} x = k_1 2^{n - 1} + k_2 2^{n - 2} + \\cdots + k_{n - 1}2^1 + k_n 2^0 = \\sum_{i = 1}^n k_i 2^{n - i} \\tag{6.2} \\end{equation}\\] Pavyzdžiui, dvejetainis skaičius 011 paverčiamas į dešimtainį \\(x = 0\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 = 3\\). Standartiniai 2 kubitų baziniai vektoriai dešimtainėje sistemoje tampa \\(\\{|00\\rangle , |01\\rangle , |10\\rangle , |11\\rangle\\} \\rightarrow \\{|0\\rangle, |1\\rangle , |2\\rangle, |3\\rangle\\}\\). Tačiau kompiuterių moksle ši nomenklatūra skiriasi dviem aspektais. Kubitai yra numeruojami pradedant nuo 0, o ne nuo 1, ir rašomi vektoriuose atvirkštine eiliškumo tvarka, \\(|k_{n - 1}k_{n - 2}\\cdots k_1 k_0 \\rangle\\). Tai yra, pirmas kubitas žymimas \\(k_{0}\\) ir rašomas dešinėje bei užbaigiama paskutiniuoju \\(k_{n - 1}\\) kairėje. Dešimtaine forma išreiškę vektorių \\(|x\\rangle\\): \\[\\begin{equation} |x\\rangle = |k_{n - 1} k_{n - 2}\\cdots k_1 k_0 \\rangle \\tag{6.3} \\end{equation}\\] taikytume šią formulę: \\[\\begin{equation} x = k_0 2^0 + k_1 2^1 + \\cdots + k_{n - 2}2^{n - 2} + k_{n - 1}2^{n - 1} = \\sum_{i = 0}^{n - 1} k_i 2^i\\,. \\tag{6.4} \\end{equation}\\] Nepriklausomai nuo to, kuris būdas taikomas dvejetainę formą paverčiant dešimtaine, rezultatas yra vienodas. Pavyzdžiui, skaičius 011 paverčiamas į dešimtainį \\(x = 1\\cdot 2^0 + 1\\cdot 2^1 + 0\\cdot 2^2 = 3\\). Tačiau, \\(n\\)-kubitų loginių vartų išraiška skiriasi, pavyzdžiui, CNOT su pirmu kubitu, atliekančiu kontrolinio vaidmenį \\(|k_1 k_2 \\cdots k_{n - 1}k_n \\rangle\\) numeracijoje yra \\(cX = |0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes X\\). Antruoju būdu, \\(|k_{n - 1}k_{n - 2}\\cdots k_1 k_0 \\rangle\\), jie yra \\(cX = I\\otimes|0\\rangle\\langle 0| + X\\otimes|1\\rangle\\langle 1|\\). Tai nusako skirtingas matricas. Šioje knygoje vartojame fizikoje įprastą numeraciją \\(|k_1 k_2 \\cdots k_{n - 1}k_n \\rangle\\), nebent iš anksto įspėjama, kad naudojamas kompiuterių moksle įprastas būdas. Iš \\(n\\) kubitų sudarytas \\(2^n\\) skaičiuojamųjų bazinių vektorių rinkinys dešimtaine forma yra \\(\\{|0\\rangle , |1\\rangle , |2\\rangle , \\cdots ,|2^{n} - 1\\rangle\\}\\). Bendra būsena \\(|\\psi \\rangle\\), normavimo sąlyga ir ortogonalumas yra išreiškiami: \\[\\begin{gather} |\\psi\\rangle = c_0|0\\rangle + c_1|1\\rangle + c_2|2\\rangle + \\cdots + c_{2^{n} - 1}|2^n - 1\\rangle = \\sum_{x = 0}^{2^{n} - 1} c_x|x\\rangle\\,;\\tag{6.5}\\\\ \\langle x&#39;|x\\rangle = \\delta_{x&#39;x}\\,;\\tag{6.6}\\\\ |c_0|^2 + |c_1|^2 + |c_2|^2 + \\cdots + |c_{2^{n} - 1}|^2 = \\sum_{x = 0}^{2^{n} - 1} |c_x|^2 = 1\\,.\\tag{6.7} \\end{gather}\\] 6.2 Funkcinis skaičiavimas Skaitmeniniuose skaičiavimuose kintamieji turi dvi reikšmes \\(\\{0, 1\\}\\). Tad galima traktuoti, kad visuose tokiuose skaičiavimuose yra įvertinamos Būlio funkcijos (angl. Boolean function) \\(f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m\\). Ši išraiška nusako, kad Būlo funkcija \\(f\\) transformuoja \\(n\\) bitų ilgio seką į kitą \\(m\\) bitų ilgio seką, kurioje \\(m\\) ir \\(n\\) gali būti vienodi arba skirtis. Kvantinėje kompiuterijoje norima funkcija \\(f\\) turi būti perteikiama unitariuoju operatoriumi \\(U_f\\). Veikiantis \\(n\\) kubitų registro būseną \\(U_f\\) transformuoja ją į kitą \\(n\\) kubitų būseną. Tai yra fundamentaliai invertuojamas procesas, atlikus šiam registrui atvirkštinį operatorių \\(U_f^{\\dagger}\\) bus grąžinta pradinė registro būsena. Visgi didelė dalis skaičiavimuose mus dominančių funkcijų nėra invertuojamos. Funkcija \\(f(x)\\) yra invertuojama, jeigu su kiekvienu jos argumentu \\(x\\) galima unikaliai susieti vieną reikšmę, tai yra 1:1 funkcijos. Pavyzdžiui, funkcija \\(f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}\\) nėra invertuojama, nes su \\(n\\) skirtingų argumentų yra asocijuojamos tik dvi skirtingos reikšmės. Taip pat egzistuoja ir \\(f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^n\\) neinvertuojamų funkcijų. Pavyzdžiui, parabolė \\(f(x) = x^2\\), apibrėžta visiems argumentams \\(x\\), nėra invertuojama, nes \\((+x)^2 = (-x)^2\\) ir todėl kiekvienai \\(f\\) reikšmei yra du skirtingi argumentai (\\(+x\\) ir \\(-x\\)). Dėl šių priežasčių kvantinėje kompiuterijoje funkciniams skaičiavimams atlikti yra dažnai pasitelkiami du kubitų registrai, vadinami įvesties (angl. input register) ir išvesties (angl. output register) registrais. Kvantinis skaičiavimas, naudojant du registrus, dažnai turi tokią formą: \\[\\begin{equation} U_f|x\\rangle\\otimes|0\\rangle = |x\\rangle\\otimes|f(x)\\rangle\\,. \\tag{6.8} \\end{equation}\\] Unitarinė transformacija \\(U_f\\) čia veikia abu registrus. Kiekvienas bazinis vektorius \\(|x\\rangle\\) įvesties registre atlieka funkcijos argumento rolę \\(x\\), o funkcijos reikšmė \\(f(x)\\) yra užrašoma išvesties registro būsenoje \\(|f(x)\\rangle\\). Jeigu išvesties registras yra ne \\(|0\\rangle\\), o kitoje pradinėje būsenoje \\(|y\\rangle\\), tada: \\[\\begin{equation} U_f|x\\rangle\\otimes|y\\rangle = |x\\rangle\\otimes|y\\oplus f(x)\\rangle\\,. \\tag{6.9} \\end{equation}\\] Šiuo atveju naudojame dvejetainę formą, tad išvesties registre yra atliekama \\(y\\) ir \\(f(x)\\) mod(2) bitų sudėtis, žymima ženklu \\(\\oplus\\). Paprasčiausią funkcinio skaičiavimo pavyzdį matėme IV skyriuje naudojant \\(U_f = cX\\), kuris atlieka mod(2) bitų sudėtį. 6.1 pav. iliustruojame šį bendrą skaičiavimo principą kvantine grandine. 6.1 pav. Kvantinė grandinė, realizuojanti funkcinį skaičiavimą \\(U_f|x\\rangle\\otimes|y\\rangle = |x\\rangle\\otimes|y\\oplus f(x)\\rangle\\) 6.3 Kvantinis paralelizmas Norint klasikiniu kompiuteriu apskaičiuoti funkcijos \\(f(x)\\) reikšmes \\(n\\) skirtingų argumentų \\(x_1 , x_2 , \\ldots , x_n\\), reikia šią funkciją pateikti ir įvertinti \\(n\\) kartų. Kvantinis kompiuteris leidžia \\(f(x)\\) įvertinti lygiagrečiai visuose \\(n\\)-argumentuose vienu funkcijos iškvietimu. Norėdami tai pamatyti, pradėkime vėl nuo 2 kubitų sistemos, turinčios po vieną kubitą įvesties ir išvesties registre siekiant apskaičiuoti funkciją argumentuose \\(f(0)\\) ir \\(f(1)\\). Unitarusis operatorius \\(U_f\\) atlieka funkcijos \\(f\\) įvertinimą, randame: \\[\\begin{equation} U_f\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|0\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|f(0)\\rangle + |1\\rangle\\otimes|f(1)\\rangle\\big)\\, \\tag{6.10} \\end{equation}\\] Matome, kad jeigu įvesties registras yra paruoštas į \\(|0\\rangle\\) ir \\(|1\\rangle\\) superpoziciją, tada dėl operatorių tiesiškumo yra lygiagrečiai įvertinamos \\(f(0)\\) ir \\(f(1)\\) vertės vienu funkcijos \\(f\\) pritaikymu. Šį principą galima praplėsti ir atlikti funkcijos įvertinimą \\(2^n\\) argumentų paruošiant pradinę įvesties registro būseną į lygią visų \\(n\\)-kubitų \\(2^n\\) skaičiuojamųjų bazinių vektorių superpoziciją. Tai atliekama kiekvienam kubitui registre pritaikius Hadamardo loginius vartus. Pavyzdžiui, registre sudarytame iš 2-kubitų \\(H\\otimes H|00\\rangle\\): \\[\\begin{equation} \\begin{aligned} \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big) = &amp; \\frac{|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle}{2} \\\\ = &amp; \\frac{|0\\rangle + |1\\rangle + |2\\rangle + |3\\rangle}{2}\\,. \\end{aligned} \\tag{6.11} \\end{equation}\\] Lokaliomis \\(H\\) transformacijomis paruoštos būsenos superpozicijoje yra faktorizuojamos, tad galime išmatuoti kiekvieną kubitą nepaveikdami kitų būsenos. Jeigu rašysime \\(H^{\\otimes n} = H\\otimes H\\otimes\\cdots\\otimes H\\) nusakyti Hadamardo transformaciją kiekvienam iš \\(n\\)-kubitų, kurių bendra pradinė būsena dešimtainėje sistemoje yra \\(|0\\rangle\\), tada gausime lygią visų \\(2^n\\) būsenų superpoziciją: \\[\\begin{equation} H^{\\otimes n}|0\\rangle = \\frac{1}{\\sqrt{2^{n}}}\\sum_{x = 0}^{2^{n} - 1}|x\\rangle\\,. \\tag{6.12} \\end{equation}\\] Atkreipiame dėmesį, kad eksponentiškai didelės \\(2^{n}\\) bazinių vektorių superpozicijos sukūrimas reikalauja tik tiesinio n skaičiaus Hadamardo transformacijų. Skaičiavimo išteklių atžvilgiu tai yra itin efektyvus metodas. Norint įvertinti \\(f(x)\\) funkciją jos \\(2^n\\) skirtingų argumentų \\(x\\), superpozicijai pritaikome \\(U_f\\): \\[\\begin{equation} U_{f}\\frac{1}{\\sqrt{2^{n}}}\\sum_{x = 0}^{2^{n} - 1}|x\\rangle\\otimes|0\\rangle = \\frac{1}{\\sqrt{2^{n}}}\\sum_{x = 0}^{2^{n} - 1}|x\\rangle\\otimes|f(x)\\rangle\\,. \\tag{6.13} \\end{equation}\\] Šis įspūdingas rezultatas yra vadinamasis kvantinis paralelizmas. Pavyzdžiui, jeigu turime 100 kubitų kiekviename registre, sukūrus jų lygią superpoziciją ir atlikus \\(U_f\\) transformaciją paraleliai yra įvertinamas astronominis skaičius \\(\\sim 10^{30}\\) funkcijos \\(f\\) verčių. Tačiau šioje stadijoje dar nėra užtikrinta, kad kvantiniu kompiuteriu bus paspartintas skaičiavimas. Norėdami sužinoti skaičiavimo rezultatą bendrai turime išmatuoti visus kubitus įvesties ir išvesties registruose. Sakykime, kad \\(f(x)\\) yra invertuojama funkcija. Kadangi \\(|x\\rangle\\) būsena yra supinta su \\(|f(x)\\rangle\\), nesvarbu, kurį registrą pasirinksime matuoti pirmą, tad pradėkime nuo įvesties. Įvesties registras yra lygioje visų \\(2^n\\) skirtingų \\(|x\\rangle\\) būsenų superpozicijoje, todėl yra lygi \\(\\frac{1}{2^n}\\) tikimybė rasti bet kurią vieną iš šių būsenų. Atlikus įvesties registro kubitų matavimą ir radus \\(|x_0 \\rangle\\), bendra įvesties ir išvesties registrų būsena tampa \\(|x_0 \\rangle\\otimes|f(x_0)\\rangle\\). Kitame žingsnyje išmatuojame išvesties registrą, taip sužinodami \\(f(x_0)\\) reikšmę. Jeigu \\(f(x)\\) yra neinvertuojamoji funkcija, tada keletas skirtingų \\(|x\\rangle\\) būsenų gali būti supintos su ta pačia \\(|f(x_0)\\rangle\\). Šiuo atveju taip pat nėra svarbu, kurį registrą pasirinksime matuoti pirmą. Pavyzdžiui, pirmiausia išmatavus išvesties registro kubitus ir radus \\(|f(x_0)\\rangle\\), bendra būsena tampa \\(\\big(|x_m\\rangle + \\cdots + |x_l\\rangle\\big)\\otimes|f(x_0)\\rangle\\). Matome įvesties registrą, esantį būsenų superpozicijoje, kurios nusako argumentus su vienodomis funkcijos reikšmėmis \\(f(x_0)\\). Tikimybė rasti bet kurią vieną būseną yra lygi kitoms. Tad šiame procese atsitiktiniu būdu randame vieną iš \\(f(x)\\) reikšmių, negalėdami pasirinkti, kuriame argumente \\(x\\) norime įvertinti \\(f\\). Pirmiausiai atkreipiame dėmesį, kad atliekant funkcinius skaičiavimus retai yra būtinybė nuskaityti visas funkcijos reikšmes. Praktiškai įrašyti minėtų \\(\\sim 10^{30}\\) bitų informacijos, kurias saugo superpozicijoje 100 kubitų, nepakaktų visos pasiekiamos klasikinės kompiuterių atminties. Dažnai yra svarbiau nustatyti tam tikras funkcijos savybes – jos globalius parametrus, minimalias ar maksimalias vertes, periodiškumą ir panašiai. Kvantinių skaičiavimų užduotis yra išnaudoti jų fundamentalų masišką paralelizmą bei papildomais algoritminiais triukais padidinti tikimybę rasti būsenas, koduojančias ieškomus atsakymus. Viena tokia algoritminė strategija yra vadinama amplitudės amplifikacija (angl. amplitude amplification), kuri leidžia padidinti dominančių registro būsenų amplitudes. To pavyzdį matysime Groverio paieškos algoritme. Kitas būdas yra tiesiogiai įvertinti globalius funkcijos parametrus taikant interferenciją ar koreliacijas tarp kvantinių būsenų. Šią strategiją taiko nemaža dalis algoritmų, įskaitant Doičo bei Šoro algoritmus, Hadamardo ir SWAP testus, fazės nustatymo algoritmą, kai kuriuos mašininio mokymosi metodus, kvantinių klaidų taisymo kodus. 6.4 Duomenų kodavimo būdai Skaičiavimo procesą kvantiniame kompiuteryje galima apibūdinti trimis žingsniais: Duomenų kodavimas \\(\\rightarrow\\) Duomenų apdorojimas \\(\\rightarrow\\) Būsenų matavimas Norint pateikti duomenis pirmiausia reikia juos koduoti kubitais. Tai nusako specifinį kubitų registro būsenos paruošimo procesą (angl. state preparation). Analizuojant kvantinių algoritmų sudėtingumą tenka atsižvelgti į tai, kad būsenos paruošimo žingsniai gali savaime pareikalauti daug resursų. Blogiausiu atveju, perteikti bendrai \\(n\\) kubitų būsenai gali prireikti eksponentiškai didelio \\(O(2^n)\\) loginių operacijų skaičiaus nustatant visiems \\(2^n\\) skaičiuojamiesiems baziniams vektoriams skirtingas amplitudes. Koduojant yra pageidautinas tiesiškai arba logaritmiškai su kubitų skaičiumi augantis operacijų skaičius. Duomenų tipas bei kodavimo metodas nulemia kodavimo žingsnio sudėtingumą. Egzistuoja ne vienas kodavimo metodas – plačiausiai taikomi yra bazinių vektorių kodavimas (angl. basis encoding) ir amplitudžių kodavimas (angl. amplitude encoding). Bazinių vektorių metodas tinka koduoti informaciją dvejetainėje formoje. Visa klasikinė duomenų bazė \\(D\\), kurioje kiekvienas atskiras įrašas \\(l\\) yra \\(N\\)-bitų seka \\(b^{(l)} = \\{b_1 ,b_2 , \\ldots , b_N \\}\\), \\(b_i \\in \\{0, 1\\}\\), tiesiogiai perteikiama normuota skaičiuojamųjų bazinių vektorių \\(b^{(l)} \\rightarrow |b^{(l)}\\rangle\\) lygia superpozicija: \\[\\begin{equation} |D\\rangle = \\frac{1}{\\sqrt{L}} \\sum_{l = 1}^L |b^{(l)}\\rangle\\,. \\tag{6.14} \\end{equation}\\] Čia \\(L\\) nusako įrašų skaičių ir todėl naudojamų bazinių vektorių skaičių duomenų bazėje \\(|D\\rangle\\). Kubitų skaičius \\(n\\) turi būti ne mažesnis nei ilgiausios duomenų bazės įrašo \\(b^{(l)}\\) bitų skaičius \\(N\\), tad \\(L \\leq 2^N\\). Visų kitų galimai nekoduojančių \\(2^N - L\\) bazinių vektorių amplitudės lygios nuliui. Pavyzdžiui, duomenų bazę, turinčią du įrašus \\(\\{00110, 10100\\}\\), perteiktume 5 kubitų būsena \\(|D \\rangle\\): \\[\\begin{equation} |D\\rangle = \\frac{|00110\\rangle + |10100\\rangle}{\\sqrt{2}}\\,. \\tag{6.15} \\end{equation}\\] Čia vėl naudojame įprastą fizikoje kubitų numeraciją perteikti dvejetainiams skaičiams. Šis kodavimo būdas nėra itin efektyvus kubitų skaičiaus atžvilgiu, tačiau natūraliai tinka atlikti skaitmenines aritmetines operacijas ir funkcinius skaičiavimus. Nemažai algoritmų naudoja bazinių vektorių kodavimo būdą: Groverio, kvantinė Furjė transformacija, Šoro pirminių skaičių faktorizavimas. Kaip pavadinimas indikuoja, amplitudžių kodavimo metode duomenys yra koduojami bazinių vektorių amplitudėse. Imkime vieną klasikinį duomenų bazės įrašą \\(x^{(l)} = \\{x_1 , x_2 , \\ldots , x_N \\}\\) turintį \\(N\\) elementų. Bendrai toks įrašas nusako \\(N\\) dimensijų vektorių ar duomenis su \\(N\\) skaičiumi savybių. Kiekvienas elementas \\(x_i\\) gali būti bet kokios formos skaičiai – dešimtainėje formoje realieji ar kompleksiniai. Reikalaujama, kad visi elementai \\(x_i\\) būtų normalizuojami: \\(x_i \\rightarrow x_i/\\sqrt{N}\\). Kiekvienas įrašas \\(x^{(l)}\\) yra perteikiamas skaičiuojamųjų bazinių vektorių \\(|i\\rangle\\) superpozicijos amplitudėse \\(x_i\\): \\[\\begin{equation} |x^{(l)}\\rangle = \\sum_{i = 1}^N x_i |i\\rangle\\,. \\tag{6.16} \\end{equation}\\] Šis kodavimo būdas yra kubitų skaičiaus atžvilgiu efektyvus, nes \\(N\\) elementų įrašas reikalauja tik \\(\\log_2 (N)\\) kubitų. Duomenų bazę \\(D\\), turinčią \\(M\\) skaičių su \\(N\\) elementų ilgio įrašais \\(x^{(l)}\\), \\(D = \\{x^{(1)} , x^{(2)} , \\ldots , x^{(M)}\\}\\), galima perteikti \\((M\\times N)\\) dimensijų vektoriumi kubitų registre: \\[\\begin{equation} |D\\rangle = \\sum_{i = 1}^{MN} x_i |i\\rangle\\,. \\tag{6.17} \\end{equation}\\] Tai reikalauja \\(n \\geq \\log_2 (MN)\\) kubitų skaičiaus. Kitaip tariant, norint koduoti visus \\(MN\\) įrašus bazinių vektorių skaičius \\(2^n\\) turi būti \\(2^n \\geq MN\\). Potencialų nekoduojančių elementų perteklių būsenose irgi galima užpildyti nuliais. Amplitudžių kodavimas taikomas daugelyje kvantinio mašininio mokymosi algoritmų ir kvantinių sistemų modeliavime. Šio metodo trūkumas tas, kad skaičiavimo pabaigoje amplitudžių \\(x_i\\) tiesiogiai negalima nuskaityti. Reikalingas kitas būdas panaudoti juose koduojamą informaciją, pavyzdžiui, apskaičiuojant tam tikrą amplitudžių funkciją \\(f(x_i)\\), išreikštą kvantiniu operatoriumi \\(U\\) taip realizuojant \\(f(x_i ) = \\langle x_i |U| x_i \\rangle\\). Hadamardo testas (žr. 6.7 poskyrį) leidžia efektyviai apskaičiuoti šiuos narius. 6.5 Doičo algoritmas Doičo algoritmas (angl. Deutsch algorithm) yra vienas iš pirmųjų ir paprasčiausių pavyzdžių, iliustruojantis kvantinio algoritmo pranašumą prieš klasikinį. Doičo algoritmas nėra savaime ypač naudingas, tačiau parodo esminį būsenų superpozicijos ir interferencijos panaudojimą kvantiniuose skaičiavimuose. Įsivaizduokime scenarijų, kuriame Agnė turi juodąją dėžę, atliekančią vieno bito manipuliacijas. Ši dėžė apskaičiuoja funkciją \\(f\\), kuriai pateikus bitą su verte 0 arba 1, ji išveda kitą bitą, taip pat 0 arba 1. Egzistuoja iš viso keturios skirtingos 1 bito funkcijos \\(f:\\{0, 1\\}\\rightarrow\\{0, 1\\}\\): \\[\\begin{align} f_1(0) = &amp; f_1(1) = 0\\,,\\quad f_2(0) = f_2(1) = 1\\,;\\tag{6.18} \\\\ f_3(0) = &amp; 0\\,,\\quad f_3(1) = 1\\,,\\quad f_4(0) = 1\\,,\\quad f_4(1) = 0\\,.\\tag{6.19} \\end{align}\\] Matome, kad pirmose dviejose funkcijose \\(f_1\\) ir \\(f_2\\) reikšmės nepriklauso nuo pateiktų argumentų, \\(f(0) = f(1)\\). Šias dvi funkcijos vadiname pastoviosiomis. Funkcijose \\(f_3\\) ir \\(f_4\\) reikšmės priklauso nuo argumentų, \\(f(0) \\neq f(1)\\). Jas vadiname subalansuotosiomis. Agnė turi tik vieną bandymą, skirtą sužinoti, ar juodojoje dėžėje slepiasi pastovioji, ar subalansuotoji funkcija. Akivaizdu, kad dviem bandymais ji galėtų tai lengvai padaryti. Turint tik klasikinius išteklius neįmanoma vienu juodosios dėžės panaudojimu atlikti norimą funkcijos klasifikaciją, tačiau kvantiniu kompiuteriu pakanka vieno. Kvantiniame kompiuteryje juodosios dėžės funkciją \\(f:\\{0, 1\\} \\rightarrow \\{0, 1\\}\\) atlieka unitarioji transformacija minėtu principu: \\(U_f|x\\rangle\\otimes |y\\rangle = |x\\rangle\\otimes |y\\oplus f(x)\\rangle\\). Naudojama po 1-kubitą įvesties (\\(k_1\\)) ir išvesties (\\(k_2\\)) registruose. Doičo algoritmas pasitelkia vadinamąjį fazės atatrankos (angl. phase kickback) metodą. Prieš panaudojant juodosios dėžės funkciją, šiame metode išvesties registro būsena yra paruošiama į superpoziciją \\(H|1\\rangle\\). Tada abiem registrams pritaikius \\(U_f\\) gaunama: \\[\\begin{equation} U_f|x\\rangle\\otimes\\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) = (-1)^{f(x)}|x\\rangle\\otimes\\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right)\\,. \\tag{6.20} \\end{equation}\\] Matome, kad fazės atatrankoje išvesties registro būsena nepakinta, tačiau bendrai būsenai \\(|x\\rangle\\otimes H|1\\rangle\\) yra perteikiama santykinė fazė \\((-1)^{f(x)}\\) priklausomai nuo įvesties būsenos \\(|x\\rangle\\), \\(x\\in\\{0, 1\\}\\). Tad \\((-1)^{f(x) = 0} = 1\\) ir \\((-1)^{f(x) = 1} = -1\\). Kitaip nei įprastiniame funkciniame skaičiavime, galime traktuoti, kad \\(U\\) transformacija efektyviai perkelia būsenos pokytį, šiuo atveju fazę, į įvesties registrą. Tai yra vadinama fazės atatranka (angl. phase kickback), ji aptinkama ne viename algoritme. Pradedant Doičo algoritmą, įvesties ir išvesties registro kubitams, esantiems atitinkamai \\(|0\\rangle\\) ir \\(|1\\rangle\\) būsenose, pirmiausiai pritaikome Hadamardo transformacijas: \\[\\begin{equation} |\\psi\\rangle = (H\\otimes H)|0\\rangle\\otimes|1\\rangle = \\frac{1}{2}\\big(|0\\rangle + |1\\rangle\\big)\\otimes\\big(|0\\rangle - |1\\rangle\\big)\\,. \\tag{6.21} \\end{equation}\\] Toliau panaudojame juodosios dėžės funkciją \\(f\\), nusakančią unitariąją transformaciją \\(U_f\\): \\[\\begin{equation} U_f|\\psi\\rangle = \\frac{1}{2}\\big\\lbrack (-1)^{f(0)}|0\\rangle + (-1)^{f(1)}|1\\rangle\\big\\rbrack\\otimes \\big(|0\\rangle - |1\\rangle\\big)\\,. \\tag{6.22} \\end{equation}\\] Skliausteliuose matome fazės atatrankos efektą įvesties registro kubitams, esantiems superpozicijoje. Kadangi išvesties registro būsena nebeturi įtakos likusio algoritmo žingsniams, ją pašaliname iš tolimesnės analizės. Įvesties registro kubitui pritaikome dar vieną Hadamardo transformaciją \\(H\\otimes I\\): \\[\\begin{equation} (H\\otimes I)U_f|\\psi\\rangle = \\frac{1}{2}\\big\\{ \\lbrack (-1)^{f(0)} + (-1)^{f(1)}\\rbrack|0\\rangle + \\lbrack (-1)^{f(0)} - (-1)^{f(1)}\\rbrack|1\\rangle\\big\\}\\,. \\tag{6.23} \\end{equation}\\] Jeigu juodosios dėžės funkcija yra pastovioji \\(f(0) = f(1)\\), tada \\((-1)^{f(0)} - (-1)^{f(1)} = 0\\), ir viršuje išlieka tik \\(|0\\rangle\\) būsena. Jeigu funkcija subalansuota, \\(f(0) \\neq f(1)\\), tada išlieka tik \\(|1\\rangle\\) būsena (iki nesvarbios globalios fazės). Įvesties registro būseną, prieš atliekant matavimą, galima glaustai užrašyti \\(|f(0)\\oplus f(1)\\rangle\\). Matavimo rezultatas užtikrintai klasifikuoja šią funkciją, o procese juodoji dėžė panaudojama tik vieną kartą. Doičo algoritmą nusakanti kvantinė grandinė yra pateikta 6.2 pav. 6.2 pav. Doičo algoritmo loginė grandinė Doičo algoritmas leidžia palyginti, ar funkcijos vertė skirtinguose argumentuose yra vienoda, ar skirtinga, neatskleidžiant, kokios yra tos vertės. Tai skaičiavimo pavyzdys, panaudojantis paralelumą bei būsenų interferenciją, siekiant nusakyti globalią funkcijos savybę. Paralelumas matomas \\(f(0)\\) ir \\(f(1)\\) funkcijos įvertinime vienu metu. O štai konstruktyvios ir destruktyvios būsenų interferencijos efektai matomi, kai pasitelkus Hadamardo transformaciją atliekama narių sudėtis su \\((-1)^{f(x)}\\) amplitudėse, dėl kurios panaikinama \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsena. Doičo-Jodžos algoritmas (angl. Deutsch-Josza algorithm), kurio čia plačiau neanalizuosime, paprastai praplečia Doičo algoritme naudojamos funkcijos \\(f\\) dydį nuo 2 iki \\(2^n\\) argumentų ir leidžia vienu juodosios dėžės panaudojimu klasifikuoti ją kaip esančią pastoviąją arba subalansuotąją. Pastovioji \\(f\\) funkcija \\(2^n\\) argumentų yra tokia, kurios vertės skirtinguose argumentuose yra vienodos. Subalansuotojoje funkcijoje pusė jos visų verčių (\\(2^n/2\\)) yra 0 ir pusė 1. Tad klasikiniame kompiuteryje gali reikėti iki \\(2^{n-1}+1\\) funkcijos \\(f\\) įvertinimų norint atlikti šią klasifikaciją. 6.6 Kvantinė paieška ir Groverio algoritmas Kvantinis kompiuteris gali reikšmingai paspartinti įrašų paieškos procesą nestruktūrizuotose duomenų bazėse. Vienas tokios paieškos pavyzdys būtų „vardenio-pavardenio” paieška telefonų knygoje žinant telefono numerį, nes telefonų knyga yra struktūrizuota pagal vardus. Jeigu imsime, kad duomenų bazė turi \\(N\\) įrašų, klasikiniu algoritmu nėra kito būdo, kaip tik tikrinti visus įrašus, tad blogiausiu atveju gali prireikti \\(N - 1\\) patikrų, o tikimybė rasti įrašą po \\(k\\)-skaičiaus bandymų yra \\(k/N\\). Bet štai kvantiniu kompiuteriu pakanka \\(\\sqrt{N}\\) įrašų patikrinimų norint rasti norimą su praktiškai 100% tikimybe. Šis kvadratinis paspartinimas gali suteikti esminį pranašumą didėjant įrašų skaičiui duomenų bazėje. Įrodyta, kad Groverio algoritmas yra optimaliausias kvantinės paieškos nestruktūrizuotoje duomenų bazėje algoritmas. Bet koks kitas gali nebent pakeisti \\(O(\\sqrt{N})\\) algoritmo laiko sudėtingumą bendrąja konstanta. Groverio paieškoje naudojamas amplitudžių amplifikacijos metodas yra taikomas kaip modulis įvarios paskirties kvantiniuose algoritmuose, įskaitant mašininio mokymosi, ir kvantinėje kriptografijoje. Paieškos problemą galima formaliai apibūdinti Būlio funkcija \\(f:\\{0, 1\\}^n \\rightarrow\\{0, 1\\}\\), kuriai pateikus \\(n\\)-bitų seką (funkcijos argumentą) funkcijos reikšmė yra 1, jeigu \\(x\\) argumentas atitinka paieškomą, vadinsime jį \\(d\\). Visais kitais atvejais, kai \\(x \\neq d\\), funkcijos reikšmė yra 0: \\[\\begin{equation} f(x)=\\begin{cases} 1\\,, &amp; x=d\\,,\\\\ 0\\,, &amp; x\\neq d\\,. \\end{cases} \\tag{6.24} \\end{equation}\\] Tokio tipo funkcijos yra vadinamos orakulu (angl. oracle). Orakulas savaime negali pasakyti ieškomo įrašo, tačiau atpažįsta, kai šis yra jam pateiktas. Paieškos algoritmo užduotis – rasti norimą įrašą \\(d\\) su kuo mažiau kreipimųsi į orakulą (funkcijos \\(f\\) panaudojimų). Groverio algoritme orakulas yra visa duomenų bazė su \\(N = 2^n\\) įrašų. Tarp jų yra vienas elementas \\(d\\), kurį norima rasti. Ieškomų įrašų Groverio algoritmo taikymuose gali būti ir daugiau negu vienas, tačiau čia iliustruojame pavyzdį, kai yra tik vienas. Pirmame šio algoritmo žingsnyje visi \\(2^n\\) įrašai yra perteikiami įvesties registro būsenomis \\(|x\\rangle\\) dešimtainėje sistemoje sukuriant lygią superpoziciją: \\[\\begin{equation} |\\psi\\rangle = H^{\\otimes n}|0\\rangle = \\frac{1}{\\sqrt{2^{n}}}\\sum_{x = 0}^{2^n - 1}|x\\rangle\\,. \\tag{6.25} \\end{equation}\\] Išvesties registras yra sudarytas iš vieno kubito ir inicijuojamas į \\(H|1\\rangle\\) būseną siekiant panaudoti fazės atatrankos metodą. Orakulo funkcijos, vadinsime ją \\(U_f\\), efektas vienai tokiai būsenai yra: \\[\\begin{equation} U_f|x\\rangle\\otimes H|1\\rangle = (-1)^{f(x)}|x\\rangle\\otimes H|1\\rangle\\,. \\tag{6.26} \\end{equation}\\] Tad jeigu orakului pateikiama neteisinga būsena \\(|x\\rangle \\neq |d\\rangle\\), tada \\(f(x) = 0\\) ir abiejų registrų būsena nepakinta. Pateikus ieškomą būseną \\(|x\\rangle = |d\\rangle\\), bendra būsena tampa \\(-|d\\rangle\\otimes H|1\\rangle\\). Kitaip tariant, orakulas paženklina teisingą būseną įvesdamas jai fazę \\(|d\\rangle\\rightarrow -|d\\rangle\\). Matome, kad išvesties ir įvesties registrai nėra supinti nei prieš, nei po \\(U_f\\) panaudojimo. Kadangi Groverio paieškos algoritme \\(U_f\\) yra vienintelė transformacija, veikianti abu registrus, tačiau ji nekeičia išvesties registro būsenos, toliau analizuojant šį algoritmą galima koncentruotis vien į įvesties registrą. Orakulo transformaciją \\(U_f\\) pakeisime kita efektyvia transformacija, vadinkime ją \\(V\\), kuri veikia vien tik įvesties registrą (vienetinis operatorius \\(\\otimes I\\) išvesties registrui), ir atlieka jam tokią pačią funkciją kaip ir \\(U_f\\). Tai užrašome: \\[\\begin{equation} V|x\\rangle = (-1)^{f(x)}|x\\rangle = \\begin{cases} -|x\\rangle\\,, &amp; x=d\\,,\\\\ |x\\rangle\\,, &amp; x\\neq d\\,. \\end{cases} \\tag{6.27} \\end{equation}\\] Nors matricos forma \\(V\\) operatoriaus čia tiesiogiai nenaudosime, tačiau verta atkreipti dėmesį, kad tai yra diagonalioji transformacija: \\[\\begin{equation} V = \\begin{bmatrix} (-1)^{f(0)} &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; (-1)^{f(2^n - 1)} \\end{bmatrix}\\,. \\tag{6.28} \\end{equation}\\] Nenuliniai skaičiai yra tik išilgai pagrindinės įstrižainės. Jeigu ieškoma tik viena būsena, tada vienas atitinkamas skaičius įstrižainėje yra -1, o visi kiti 1. Pritaikę operatorių \\(V\\) visam įvesties registrui pradinėje būsenoje randame: \\[\\begin{equation} V|\\psi\\rangle = -\\frac{1}{\\sqrt{2^n}}|d\\rangle + \\frac{1}{\\sqrt{2^n}}\\sum_{x \\neq d}^{2^{n - 1} - 1}|x\\rangle\\,. \\tag{6.29} \\end{equation}\\] Antrame naryje matome visų būsenų išskyrus \\(|d\\rangle\\) sumą, tad sumuojama \\(2^{n - 1} - 1\\) narių. Šiek tiek ilgėliau pažiūrėjus į išraišką (6.29) tampa aišku, kad \\(V\\) transformacija turi šią formą: \\[\\begin{equation} V = - 2|d\\rangle\\langle d| + I\\,. \\tag{6.30} \\end{equation}\\] Čia \\(I\\) – vienetinis operatorius, o \\(|d\\rangle\\langle d|\\) yra projekcinis operatorius į \\(|d\\rangle\\) vektoriaus poerdvį. Skaičius -2 atspindį tai, kad viršuje vektorius \\(|d\\rangle\\) yra atimamas du kartus – iš būsenų sumos nario, o pavienis \\(|d \\rangle\\) narys yra su minuso ženklu. Siekiant atlikti paiešką, Groverio algoritmas naudoja unitariąją transformaciją, vadinkime ją \\(G\\), kuri nereikalauja orakulo panaudojimo. Jos išraiška nepriklauso ir nuo paieškomo \\(|d\\rangle\\) vektoriaus bei turi šią formą: \\[\\begin{equation} G = 2|\\psi\\rangle\\langle\\psi| - I\\,. \\tag{6.31} \\end{equation}\\] Čia \\(|\\psi\\rangle\\langle\\psi |\\) yra projekcinis operatorius į pradinės būsenos \\(|\\psi\\rangle\\) poerdvį. Groverio algoritmas (žr. 6.3 pav.) pakartotinai pritaiko, arba iteruoja, \\(GV\\) operatorius, o tai lemia \\(|d \\rangle\\) būsenos amplitudės amplifikaciją likusių būsenų sąskaita: \\[\\begin{equation} |d\\rangle\\approx GVGV\\cdots GV|\\psi\\rangle\\,. \\tag{6.32} \\end{equation}\\] 6.3 pav. Groverio algoritmo bendrą principą nusakanti loginė grandinė Toliau parodysime, kaip ši iteracija atlieka paieškos užduotį amplifikuojant ieškomosios būsenos amplitudę ir kiek kartų reikia iteruoti norint užtikrinti, kad \\(|d \\rangle\\) bus rasta su didele tikimybe. Galima pažvelgti į Groverio algoritmą dviem būdais: algebriškai analizuojant amplitudžių pokyčius kiekviename iteracijos žingsnyje, arba geometriškai atsižvelgiant į būsenos vektoriaus posūkį 2 dimensijų erdvėje. Šie būdai savaip apšviečia algoritmo esmę, tad panagrinėkime juos abu. 6.6.1 Algebrinė interpretacija Viršuje pateikėme transformacijos \\(V\\) efektą įvertindami \\(V|\\psi\\rangle\\). Norėdami pamatyti vienos \\(GV\\) iteracijos efektą bendrai būsenai \\(|\\phi\\rangle\\), toliau įvertinsime \\(G|\\phi\\rangle\\). Būseną \\(|\\phi\\rangle\\) galima traktuoti esant tarpinę tarp pradinės \\(|\\psi\\rangle\\) ir visų kitų galimų registro būsenų algoritmo metu. Ji išreiškiama tais pačiais \\(2^n\\) skaičiuojamaisias baziniais vektoriais, bet kitomis amplitudėmis \\(c_x\\): \\[\\begin{equation} |\\phi\\rangle = \\sum_{x = 0}^{2^{n - 1}} c_x|x\\rangle\\,. \\tag{6.33} \\end{equation}\\] Kadangi pradinėje \\(|\\psi\\rangle\\) būsenoje visos amplitudės yra realieji skaičiai, o \\(V\\) ir \\(G\\) operacijos jas tokias išlaiko, viso algoritmo metu amplitudės \\(c_x\\) išlieka realiaisiais skaičiais. Apskaičiuodami \\(G|\\phi\\rangle = 2|\\psi\\rangle\\langle\\psi |\\phi\\rangle - |\\phi\\rangle\\), pirmiausiai įvertinsime vidinę sandaugą \\(\\langle\\psi |\\phi\\rangle\\): \\[\\begin{equation} \\langle\\psi |\\phi\\rangle = \\frac{1}{\\sqrt{2^n}}\\sum_{x&#39;,x = 0}^{2^{n - 1}} c_x\\langle x&#39;|x\\rangle = \\frac{\\sqrt{2^n}}{2^n}\\sum_{x = 0}^{2^{n - 1}} c_x = \\sqrt{2^n} \\bar{c}_x\\,. \\tag{6.34} \\end{equation}\\] Pirmoje eilutėje vidinių sandaugų suma yra atliekama su \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\) baziniais vektoriais \\(\\{|x\\rangle\\}\\), indeksuotais \\(x&#39;\\) ir \\(x\\), atitinkamai. Kadangi \\(\\{|x\\rangle\\}\\) yra ortogonaliųjų normuotųjų vektorių rinkinys, \\(\\langle x&#39;|x\\rangle = \\delta_{xx&#39;}\\), panaikinamas vienas suminis indeksas. Antroje dalyje identifikavome \\(\\bar{c}_x\\), nusakantį visų \\(2^n\\) amplitudžių \\(c_x\\) vidurkį: \\[\\begin{equation} \\bar{c}_x = \\frac{1}{2^n}\\sum_{x = 0}^{2^{n - 1}} c_x\\,. \\tag{6.35} \\end{equation}\\] Dabar galima rasti \\(G|\\phi\\rangle\\): \\[\\begin{equation} G|\\phi\\rangle = 2\\left(\\sum_{x = 0}^{2^{n - 1}}|x\\rangle\\right)\\bar{c}_x - \\sum_{x = 0}^{2^{n - 1}} c_x|x\\rangle = \\sum_{x = 0}^{2^{n - 1}} (2\\bar{c}_x - c_x)|x\\rangle\\,. \\tag{6.36} \\end{equation}\\] Palyginę su \\(|\\phi \\rangle\\) būsena matome, kad jai pritaikius \\(G\\) operatorių visos amplitudės pakeičiamos \\(c_x \\rightarrow 2\\bar{c}_x - c_x\\). Pradinėje \\(|\\psi\\rangle\\) būsenoje visos \\(c_x = 1/\\sqrt{2^n}\\), tad ir jų vidurkis \\(\\bar{c}_x = 1/\\sqrt{2^n}\\). Atlikus \\(V|\\psi\\rangle\\), ieškomos būsenos \\(|d\\rangle\\) amplitudė tampa \\(c_{x = d} = -1/\\sqrt{2^n}\\), todėl vidurkis \\(\\bar{c}_x\\) sumažėja. Tolesniame žingsnyje \\(GV|\\psi\\rangle\\) ieškomos būsenos amplitudė tampa vėl teigiama (dėl atimties ženklo \\(2\\bar{c}_x - c_x\\) išraiškoje) ir didesnė nei prieš tai, nes pridedamas vidurkis, padaugintas iš dviejų, \\(2\\bar{c}_x + 1/\\sqrt{2^n}\\). Tačiau visų likusių būsenų amplitudės sumažėja, nes jų amplitudės yra atimamos iš sumažėjusio vidurkio (padauginto iš dviejų). Pirmos iteracijos žingsniai iliustruoti 6.4 pav. 6.4 pav. Būsenų \\(|x\\rangle\\) amplitudžių \\(c_x\\) pokytis pirmos Groverio iteracijos \\(GV\\) metu. Ieškomosios būsenos \\(|d\\rangle\\) amplitudė žymima \\(d\\), visų būsenų amplitudžių vidurkis \\(\\bar{c}_x\\) nurodytas brūkšniuota linija Antrosios iteracijos pirmame žingsnyje \\(VGV|\\psi\\rangle\\), būsenos \\(|d\\rangle\\) amplitudė vėl padaroma neigiamąja, taip sumažinant vidurkį, o \\(GVGV|\\psi\\rangle\\) vėl amplifikuoja \\(|d\\rangle\\) padarant ją teigiamąja ir pridedant vidurkį. O štai visų kitų būsenų amplitudės vėl sumažinamos. Pakartojus \\(GV\\) iteraciją apytiksliai \\((\\pi/4)\\sqrt{N}\\) kartų, tikimybė pamatavus registro būseną rasti \\(|d\\rangle\\), kai \\(N\\) yra didelis skaičius, gali būti pageidaujamai artima 100 %. Geometrinė Groverio algoritmo interpretacija leidžia intuityviau pademonstruoti, kodėl yra reikalingas būtent toks skaičius iteracijų. 6.6.2 Geometrinė interpretacija Nors bendra registro būsena \\(|\\phi\\rangle\\) yra apibūdinama \\(2^n\\) dimensijų erdvėje, viso Groverio algoritmo metu \\(|\\phi\\rangle\\) pokyčiai vyksta tik 2 dimensijų vektorių poerdvyje, ir tai leidžia atlikti paprastą geometrinę analizę. Norint tai pamatyti, transformaciją \\(V\\) pradinei būsenai \\(|\\psi\\rangle\\) bei ieškomajai \\(|d\\rangle\\) perteikiame taip: \\[\\begin{align} V|\\psi\\rangle = &amp; |\\psi\\rangle - \\frac{2}{\\sqrt{2^n}}|d\\rangle\\,;\\tag{6.37} \\\\ V|d\\rangle = &amp; -|d\\rangle\\,.\\tag{6.38} \\end{align}\\] Operatoriaus \\(G\\) efektas: \\[\\begin{align} G|\\psi\\rangle = &amp; |\\psi\\rangle\\,;\\tag{6.39} \\\\ G|d\\rangle = &amp; \\frac{2}{\\sqrt{2^n}}|\\psi\\rangle - |d\\rangle\\,.\\tag{6.40} \\end{align}\\] Matome, kad individualūs \\(V\\) ir \\(G\\) (todėl ir bendra \\(GV\\)), veikdami \\(|\\psi\\rangle\\) ir \\(|d\\rangle\\), sukuria kitas šių būsenų tiesines kombinacijas išlaikant amplitudes realiaisiais skaičiais. Visos tiesinės dviejų vektorių kombinacijos realioje vektorių erdvėje apibrėžia 2 dimensijų plokštumą. Yra pravartu iliustruoti šią plokštumą identifikuojant ortogonaliuosius vektorius \\(\\big\\{|d\\rangle , |d_{\\bot}\\rangle\\big\\}\\); čia \\(|d_{\\bot}\\rangle\\) yra statmenas ieškomajam \\(|d\\rangle\\) vektoriui. Tad pradinę būseną \\(|\\psi\\rangle\\) perteikiame jų sudėtimi: \\(|\\psi\\rangle = \\langle\\psi |d\\rangle |d\\rangle + \\langle\\psi |d_{\\bot}\\rangle|d_{\\bot}\\rangle\\). Jeigu imsime, kad \\(\\theta\\) yra kampas tarp \\(|\\psi\\rangle\\) ir \\(|d_{\\bot}\\rangle\\), tada \\(\\langle\\psi |d_{\\bot}\\rangle = \\cos(\\theta)\\) ir \\(\\langle\\psi |d\\rangle = \\cos\\left(\\frac{\\pi}{2} - \\theta\\right) = \\sin(\\theta)\\). Taigi bendrą būseną \\(|\\phi\\rangle\\) šioje 2 dimensijų plokštumoje galima išreikšti ir taip: \\[\\begin{equation} |\\phi\\rangle = \\sin(\\theta)|d\\rangle + \\cos(\\theta)|d_{\\bot}\\rangle\\,. \\tag{6.41} \\end{equation}\\] Groverio algoritme \\(GV\\) iteracijos atlieka registro būseną nusakančio vektoriaus \\(|\\phi\\rangle\\) posūkį link \\(|d\\rangle\\) vektoriaus. Tikimybė rasti \\(|d\\rangle\\) būseną yra \\(p = |\\langle\\phi | d\\rangle |^{2} = \\sin^2(\\theta)\\), todėl tikslas yra pasiekti kampą \\(\\theta\\), kuo artimesnį \\(\\frac{\\pi}{2}\\), padarant \\(p \\approx 1\\). Kadangi \\(\\langle\\psi |d\\rangle = \\frac{1}{\\sqrt{2^n}}\\) yra artimas nuliui kai \\(2^n \\gg 1\\), \\(|\\psi\\rangle\\) ir \\(|d\\rangle\\) yra beveik lygiagretieji vektoriai. Kampas \\(\\theta\\) tokiu atveju yra labai mažas ir todėl \\(\\langle\\psi | d\\rangle = \\sin(\\theta)\\approx\\theta\\). Taip randame pradinį kampą \\(\\theta\\) tarp \\(|\\psi\\rangle\\) ir \\(|d_{\\bot} \\rangle\\). Kampas tarp \\(|d\\rangle\\) ir būsenos \\(|\\psi\\rangle\\) yra \\(\\frac{\\pi}{2} - \\theta\\), tad reikalingas iteracijų skaičius \\(k\\) randamas iš lygybės \\(2\\theta k = \\frac{\\pi}{2} - \\theta\\), arba \\(k = \\frac{\\pi}{4\\theta} - \\frac{1}{2} \\approx \\frac{\\pi}{4}\\sqrt{2^n}\\), suapvalinus \\(k\\) iki artimiausio sveikojo skaičiaus. Sugrįžkime dar kartą prie \\(V\\) ir pritaikykime šią transformaciją vektoriais \\(\\big\\{|d\\rangle , |d_{\\bot}\\rangle\\big\\}\\) perteiktai pradinei būsenai, \\(V|\\psi\\rangle = -\\langle\\psi | d\\rangle |d\\rangle + \\langle\\psi |d_{\\bot}\\rangle|d_{\\bot}\\rangle\\). Ši išraiška parodo, kad vektoriaus komponentas lygiagretus \\(|d_{\\bot}\\rangle\\) lieka nepakeistas, o komponentas lygiagretus \\(|d\\rangle\\) įgauna minuso ženklą, \\(\\langle\\psi |d\\rangle\\rightarrow -\\langle\\psi |d\\rangle\\). Kadangi \\(\\langle\\psi |d\\rangle\\approx\\theta\\), matome, kad \\(V|\\psi\\rangle\\) dabar sudaro kampą \\(-\\theta\\) su ašimi, nusakyta \\(|d_{\\bot}\\rangle\\), tad ši transformacija pasuko \\(|\\psi\\rangle\\) kampu \\(2\\theta\\) pagal laikrodžio rodyklę. Jeigu pradinis kampas būtų \\(-\\theta\\), \\(V\\) pasuktų \\(|\\psi\\rangle\\) kampu \\(2\\theta\\) prieš laikrodžio rodyklę. Toks simetriškas vektoriaus pasukimas apie ašį yra vadinamas atspindžiu (angl. reflection). Pritaikius \\(V\\) bendrai būsenai \\(|\\phi\\rangle\\), kurią galima išreikšti vektoriais \\(|d\\rangle\\) ir \\(|d_{\\bot}\\rangle\\), \\(V|\\phi\\rangle\\) geometriškai nusako \\(|\\phi\\rangle\\) atspindį ašies nusakytos \\(|d_{\\bot}\\rangle\\) vektoriumi, atžvilgiu. Transformacijos \\(G\\) efektas yra taip pat atspindėti \\(|\\phi\\rangle\\) šioje plokštumoje, tačiau atžvilgiu ašies lygiagrečios pradinės būsenos \\(|\\psi\\rangle\\) vektoriui. Norėdami tuo įsitikinti, išreikškime \\(|\\phi\\rangle\\) komponentais paraleliai ir statmenai pradinei būsenai \\(|\\psi\\rangle\\), \\(|\\phi\\rangle = |\\psi_{\\parallel}\\rangle + |\\psi_{\\bot}\\rangle\\). Lygiagretus komponentas randamas \\(|\\psi_{\\parallel}\\rangle = \\langle\\psi |\\phi\\rangle|\\psi\\rangle\\), tad statmenas \\(|\\psi_{\\bot}\\rangle = |\\phi\\rangle - \\langle\\psi |\\phi\\rangle|\\psi\\rangle\\). Norėdami rasti \\(|\\phi\\rangle\\) vektoriaus atspindį \\(|\\psi\\rangle\\) atžvilgiu, atimame iš jo du statmenus komponentus: \\[\\begin{equation} \\begin{aligned} |\\phi\\rangle - 2|\\psi_{\\bot}\\rangle = &amp; |\\phi\\rangle - 2\\big(|\\phi\\rangle - \\langle\\psi |\\phi\\rangle|\\psi\\rangle\\big) = 2|\\psi\\rangle\\langle\\psi |\\phi\\rangle - |\\phi\\rangle \\\\ = &amp; \\big(2|\\psi\\rangle\\langle\\psi| - I\\big)|\\phi\\rangle\\,. \\end{aligned} \\tag{6.42} \\end{equation}\\] Paskutinėje eilutėje atpažįstame skliausteliuose \\(G\\) operatorių, tai patvirtina atspindžio efektą. Tad \\(GV\\) iteracija pritaiko du atspindžius arba, kitaip tariant, du vektorių pasukimus, vieną apie \\(|d_{\\bot}\\rangle\\) ašį ir kitą apie \\(|\\psi\\rangle\\). 6.5 pav. Geometrinė Groverio algoritmo iliustracija. Pradinės registro būsenos (vektoriaus) \\(|\\psi\\rangle\\) pasukimas vienos iteracijos \\(GV\\) metu link ieškomosios būsenos \\(|d\\rangle\\). Ieškomoji būsena, kartu su jai statmena \\(|d_{\\bot}\\rangle\\), apibūdina 2 dimensijų realų poerdvį (plokštumą) visoje \\(2^n\\) dimensijų kubitų registro būsenų erdvėje Pradedant algoritmą ir atlikus \\(V|\\psi\\rangle\\), \\(|\\psi\\rangle\\) yra pasukamas \\(2\\theta\\) kampu pagal laikrodžio rodyklę (žr. 6.5 pav.). Toliau pritaikius \\(G\\) šiai būsenai, ji yra dar kartą atspindima, šį kartą apie \\(|\\psi\\rangle\\), todėl vektorius pasukamas prieš laikrodžio rodyklę. Kadangi kampas tarp \\(V|\\psi\\rangle\\) ir \\(|\\psi\\rangle\\) yra \\(2\\theta\\), kampas tarp \\(GV|\\psi\\rangle\\) ir \\(V|\\psi\\rangle\\) yra \\(4\\theta\\). Tad vienos iteracijos \\(GV\\) dėka pradinė \\(|\\psi\\rangle\\) pasisuka \\(2\\theta\\) kampu link \\(|d\\rangle\\). Tolesnėje iteracijoje \\(V\\) vėl atspindi \\(GV|\\psi\\rangle\\) būseną apie \\(|d_{\\bot}\\rangle,\\) ir ši pasisuka \\(6\\theta\\) pagal laikrodžio rodyklę, nes sudaro \\(3\\theta\\) kampą su \\(|d_{\\bot}\\rangle\\). Tada pritaikius G būsenai \\(VGV|\\psi\\rangle\\), ši atspindima apie \\(|\\psi\\rangle\\) ir dėl šios priežasties pasisuka dar \\(2\\theta\\) kampu link \\(|d\\rangle\\). Taip kiekviena \\(GV\\) iteracija pasuka registro būseną \\(2\\theta\\) kampu arčiau ieškomosios \\(|d \\rangle\\). 6.6.3 Groverio paieška su \\(N = 8\\) Čia iliustruojame Groverio paieškos algoritmą duomenų bazėje, sudarytoje iš \\(N = 8\\) elementų pasitelkiant 3 kubitų registrą. Sakykime, kad \\(|d\\rangle = |101\\rangle = |5\\rangle\\) yra ieškomoji būsena. Orakulo funkcija, pažyminti \\(|101\\rangle\\) būseną matricos forma: \\[\\begin{equation} V = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\,. \\tag{6.43} \\end{equation}\\] Naudosime dvejetainę sistemą siekdami aiškiau iliustruoti orakulo funkcijos efektą. Tiesiogiai pritaikę orakulo funkciją \\(V = - 2|d\\rangle\\langle d| + I\\), pakeičiančią ieškomosios būsenos \\(|d\\rangle\\ = |101\\rangle\\) fazę, randame: \\[\\begin{equation} V|\\psi\\rangle = \\frac{|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle + |100\\rangle - |101\\rangle + |110\\rangle + |111\\rangle}{\\sqrt{8}}\\,. \\tag{6.44} \\end{equation}\\] Visos įmanomos 3 kubitų orakulo funkcijos, atliekančios diagonaliąją transformaciją ir pažyminčios vieną skaičiuojamąjį bazinį vektorių iš 8 skirtingų, yra iliustruotos 6.6 pav. loginiais vartais. Juose 3 kubitų loginiai vartai gali būti perteikti, pavyzdžiui, Tofoli vartų dekompozicijos metodu, parodytu 4 skyriuje. 6.6 pav. Visos galimos 3 kubitų registro orakulo funkcijas (\\(V\\) operatorių) realizuojančios loginės grandinės, atskirtos viena nuo kitos brūkšniuota linija. Viršuje pažymėtos būsenos, kurioms atitinkama grandinė pritaiko santykinę fazę Operatoriaus \\(G = 2|\\psi\\rangle\\langle \\psi| - I\\) išraišką galima rasti pirmiausiai atkreipiant dėmesį, kad \\(|\\psi\\rangle = H^{\\otimes 3}|000\\rangle\\), tad \\(G\\), veikiantis 3 kubitų registrą, užrašomas taip: \\[\\begin{equation} G = 2H^{\\otimes 3}|000\\rangle\\langle 000|H^{\\otimes 3} - I = H^{\\otimes 3}\\big(2|000\\rangle\\langle 000| - I\\big)H^{\\otimes 3}\\,. \\tag{6.45} \\end{equation}\\] 6.45 eilutėje panaudojome \\((H^{\\otimes 3})^{\\dagger} = H^{\\otimes 3}\\) ir \\(H^{\\otimes 3}IH^{\\otimes 3} = I\\). Skliausteliuose matome transformaciją \\((2|000\\rangle\\langle 000| - I)\\), kuri veikdama bazinius vektorius įveda santykinę \\(\\pi\\) fazę tarp \\(|000\\rangle\\) ir visų likusių būsenų. Norėdami realizuoti šį operatorių kvantinėje grandinėje, atkreipiame dėmesį, kad galima identiškai perrašyti šį operatorių \\((2|000\\rangle\\langle 000| - I ) \\rightarrow - (I - 2|000\\rangle\\langle 000|)\\), faktorizuojant globalią (neturinčią įtakos) fazę. Šioje formoje minuso ženklas priskiriamas \\(|000\\rangle\\) būsenai, o ne visoms likusioms būsenoms. Kvantinėje grandinėje \\(G\\) operatorius 3 kubitų registrui yra perteikiamas 6.7 pav.: 6.7 pav. Groverio 3 kubitų paieškos algoritme \\(G\\) operatorių realizuojanti loginė grandinė Turime visus ingredientus atlikti Groverio paiešką. Norint rasti reikiamą \\(GV\\) iteracijų skaičių, pirmiausiai nustatome pradinį kampą \\(\\theta\\): \\[\\begin{equation} \\langle\\psi |d\\rangle = \\cos\\left(\\frac{\\pi}{2} - \\theta\\right) = \\sin(\\theta) = 1/\\sqrt{8}\\,. \\tag{6.46} \\end{equation}\\] Randame \\(\\theta = \\arcsin\\left(\\frac{1}{\\sqrt{8}}\\right) \\approx 20.7^{\\circ}\\) ir todėl 3-kubitų dydžio registro atveju pasiekti \\(90^{\\circ}\\) kampą tiksliai neišeis. Po vienos \\(GV\\) iteracijos kampas tampa \\(\\theta \\approx 62.1^{\\circ}\\), o dviejų \\(\\theta \\approx 103.5^{\\circ}\\). Tikimybė rasti \\(|d\\rangle = |101\\rangle\\) būseną yra \\(p = \\sin^{2}(\\theta)\\), todėl po vienos iteracijos ji yra \\(p = 0.78\\), o po dviejų \\(p = 0.95\\) ir toliau pradeda mažėti, nes vektorius yra prasukamas per toli. Praktiniuose taikymuose mus domina paieška didelėje duomenų bazėje. Šioje situacijoje būtent ir galime rasti atsakymą vienu matavimu su praktiškai \\(p = 1\\) tikimybe. Mat didėjant įvesties būsenų skaičiui \\(N\\), pradinis kampas \\(\\theta\\) mažėja. Na, o kadangi kiekviena \\(GV\\) iteracija pasuka vektorių \\(2\\theta\\) kampu, mažesnis pradinis kampas \\(\\theta\\) leidžia tiksliau priartinti \\(|\\phi\\rangle\\) prie ieškomosios \\(|d\\rangle\\) būsenos ir ją amplifikuoti. 6.7 Hadamardo ir SWAP testai Šioje dalyje pristatome plačiai žinomus ir algoritmuose aptinkamus Hadamardo ir SWAP testus (angl. Hadamard, SWAP tests). Jie yra naudojami kaip moduliai ir procedūros kvantiniuose algoritmuose, leidžiantys apytikriai apskaičiuoti tokių narių reikšmes: unitariojo operatoriaus \\(U\\) tikrinių verčių vidurkį \\(\\langle U\\rangle = \\langle\\psi |U|\\psi\\rangle\\), dviejų būsenų vidinę sandaugą \\(\\langle\\phi |\\psi\\rangle\\), ir vidinės sandaugos kvadratą \\(|\\langle\\phi |\\psi\\rangle |^2\\). 6.7.1 Hadamardo testas Kvantinės grandinės, realizuojančios Hadamardo, modifikuotą Hadamardo ir SWAP testus panaudoja ancila 1 kubito registrą bei papildomą registrą (ar registrus) koduojančius būsenas, kurių atžvilgiu apskaičiuojami minėti nariai. Šios grandinės pasižymi identiška loginių vartų seka: Hadamardo vartai yra pritaikomi ancila kubitui prieš ir po sąlyginių loginių vartų \\(cU\\), kontroliuojamų ancila kubito būsenų, taip pat išmatuojama ancila kubito būsena. Hadamardo testą realizuojanti grandinė yra iliustruota 6.8 pav. 6.8 pav. Hadamardo testą atliekanti loginė grandinė Matome ancila kubitą pradinėje \\(|0\\rangle\\) būsenoje ir antrą kubitas bendroje \\(|\\psi\\rangle\\) būsenoje, tad turime faktorizuojamą \\(|0\\rangle\\otimes|\\psi\\rangle\\). Darome prielaidą, kad galime pakartotinai paruošti \\(|\\psi\\rangle\\). Atlikus Hadamardo loginius vartus ancilai randame: \\[\\begin{equation} H\\otimes I\\big(|0\\rangle\\otimes|\\psi\\rangle\\big) = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|\\psi\\rangle\\,. \\tag{6.47} \\end{equation}\\] Toliau atliekami kontroliuojami \\(U\\) antrajam kubitui, vadinkime juos \\(cU\\): \\[\\begin{equation} cU\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|\\psi\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle + |1\\rangle\\otimes U|\\psi\\rangle\\big)\\,. \\tag{6.48} \\end{equation}\\] Ir dar vieni \\(H\\) ancila kubitui: \\[\\begin{equation} \\begin{split} H\\otimes I &amp; \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle + |1\\rangle\\otimes U|\\psi\\rangle\\big) = \\\\ &amp; \\frac{1}{2}\\Big(\\big(|0\\rangle + |1\\rangle\\big)\\otimes|\\psi\\rangle + \\big(|0\\rangle - |1\\rangle\\big)\\otimes U|\\psi\\rangle\\Big)\\,. \\end{split} \\tag{6.49} \\end{equation}\\] Šią būseną, vadinkime ją \\(|\\chi\\rangle\\), galime pergrupuoti taip: \\[\\begin{equation} |\\chi\\rangle = |0\\rangle\\otimes\\left(\\frac{I + U}{2}\\right)|\\psi\\rangle + |1\\rangle\\otimes\\left(\\frac{I - U}{2}\\right)|\\psi\\rangle\\,. \\tag{6.50} \\end{equation}\\] Sekant parodytą kvantinę grandinę, išmatuojame ancila kubito būseną. Toliau apskaičiuosime neselektyvaus būsenų matavimo rezultatą, suteikiantį ancila kubito tikrinių verčių \\(\\lambda_k \\in \\{ 1, -1\\}\\) vidurkį. Tam formaliai naudojame operatorių \\(Z\\otimes I\\), tad turėsime apskaičiuoti \\(\\langle\\chi |Z\\otimes I|\\chi\\rangle\\). Taikant projekcinę dekompoziciją: \\[\\begin{equation} Z\\otimes I = \\sum_k \\lambda_k P_k \\otimes I = \\lambda_0|0\\rangle\\langle 0|\\otimes I + \\lambda_1|1\\rangle\\langle 1|\\otimes I = |0\\rangle\\langle 0|\\otimes I - |1\\rangle\\langle 1|\\otimes I\\,. \\tag{6.51} \\end{equation}\\] Randame \\(\\langle\\chi |Z\\otimes I |\\chi\\rangle\\): \\[\\begin{equation} \\begin{split} \\langle\\chi |Z\\otimes I |\\chi\\rangle = &amp; \\left\\lbrack\\langle 0|\\otimes\\langle\\psi|\\left(\\frac{I + U^{\\dagger}}{2}\\right) + \\langle 1|\\otimes\\langle\\psi|\\left(\\frac{I - U^{\\dagger}}{2}\\right)\\right\\rbrack (Z\\otimes I)\\\\ &amp; \\times\\left\\lbrack |0\\rangle\\otimes\\left(\\frac{I + U}{2}\\right)|\\psi\\rangle + |1\\rangle\\otimes\\left(\\frac{I - U}{2}\\right)|\\psi\\rangle\\right\\rbrack\\,. \\end{split} \\tag{6.52} \\end{equation}\\] Atlikus vidines sandaugas: \\[\\begin{equation} \\langle\\chi |Z\\otimes I|\\chi\\rangle = \\frac{1}{2}\\langle\\psi |\\psi\\rangle + \\frac{1}{2}\\langle\\psi |U + U^{\\dagger}|\\psi\\rangle = \\frac{1}{2}\\langle\\psi |\\psi\\rangle + \\mathrm{Re}\\big\\lbrack\\langle\\psi |U|\\psi\\rangle\\big\\rbrack\\,. \\tag{6.53} \\end{equation}\\] Primename, kad unitariojo operatoriaus \\(U\\) tikrinės vertės \\(\\lambda_k\\) yra kompleksiniai skaičiai su vienetiniu moduliu ir forma \\(\\lambda_k = \\mathrm{e}^{\\mathrm{i}\\theta_k}\\). Paskutinėje eilutėje panaudojome \\(\\langle\\psi |U^{\\dagger}|\\psi\\rangle = (\\langle\\psi |U|\\psi\\rangle)^{\\dagger}\\), tad bendrai, sudėję kompleksinį skaičių \\(z\\equiv\\langle\\psi |U|\\psi\\rangle = a + \\mathrm{i}b\\) ir jo kompleksinę jungtį \\(z^{*} \\equiv\\langle\\psi |U^{\\dagger}|\\psi\\rangle = a - \\mathrm{i}b\\) gauname realiąją \\(z\\) skaičiaus dalį (\\(2a\\)). Kaip matome, šis rezultatas tiesiogiai leidžia apskaičiuoti \\(U\\) operatoriaus tikrinių verčių vidurkio realiąją dalį \\(\\mathrm{Re}\\big\\lbrack\\langle\\psi |U|\\psi\\rangle\\big\\rbrack\\). Žinoma, mus gali taip pat dominti ir menamoji \\(\\langle\\psi |U|\\psi\\rangle\\) nario dalis, \\(\\mathrm{Im}\\langle\\psi |U|\\psi\\rangle\\). Ją irgi paprastai randame pakoregavę Hadamardo testo grandinę. Po pirmųjų Hadamardo loginių vartų, pritaikytų ancila kubitui, pritaikome jam papildomus vartus \\(S^{\\dagger}\\), suteikiančius \\(|1\\rangle\\) būsenai fazę, \\(|1\\rangle\\rightarrow -\\mathrm{i}|1 \\rangle\\): \\[\\begin{equation} S^{\\dagger} = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; -\\mathrm{i} \\end{bmatrix}\\,. \\tag{6.54} \\end{equation}\\] Tada vėl atliekami vartai \\(cU\\) ir \\(H\\otimes I\\): \\[\\begin{equation} \\begin{aligned} (H\\otimes I)cU\\frac{1}{\\sqrt{2}}\\big(|0\\rangle - \\mathrm{i}|1\\rangle\\big)\\otimes|\\psi\\rangle = &amp; (H\\otimes I)\\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle - \\mathrm{i}|1\\rangle\\otimes U|\\psi\\rangle\\big) \\\\ = &amp; |0\\rangle\\otimes\\left(\\frac{I - iU}{2}\\right)|\\psi\\rangle + |1\\rangle\\otimes\\left(\\frac{I + iU}{2}\\right)|\\psi\\rangle\\,. \\end{aligned} \\tag{6.55} \\end{equation}\\] Vadindami šią būseną \\(|\\chi\\rangle\\), apskaičiuojame \\(\\langle\\chi |Z\\otimes I |\\chi\\rangle\\): \\[\\begin{equation} \\langle\\chi |Z\\otimes I|\\chi\\rangle = \\frac{1}{2}\\langle\\psi |\\psi\\rangle + \\frac{\\mathrm{i}}{2}\\langle\\psi |U^{\\dagger} - U|\\psi\\rangle = \\frac{1}{2}\\langle\\psi |\\psi\\rangle + \\mathrm{Im}\\big\\lbrack\\langle\\psi |U|\\psi\\rangle\\big\\rbrack\\,. \\tag{6.56} \\end{equation}\\] Viršuje irgi pritaikėme kompleksinių skaičių aritmetiką, \\(\\mathrm{i}(z^{*} - z) = \\mathrm{i}(-2\\mathrm{i}b) = 2b\\), taip rasdami menamąją dalį \\(\\mathrm{Im}\\big\\lbrack\\langle\\psi |U|\\psi\\rangle\\big\\rbrack\\). Skaičiavimo išteklių atžvilgiu Hadamardo testas bus įvykdytas efektyviai, jeigu galime efektyviai paruošti \\(|\\psi\\rangle\\) ir atlikti \\(cU\\). Atkreipiame dėmesį, kad antrojo registro būsena po ancilos matavimo yra žinoma kaip \\(\\left(\\frac{I \\pm \\mathrm{i}U}{2}\\right)|\\psi\\rangle\\), su ženklu + arba -, kuris priklauso nuo rastos ancila kubito būsenos. Hadamardo testo algoritmo laiko sudėtingumas auga kaip \\(O(1/\\epsilon)\\) su norimu pasiekti tikslumu \\(\\epsilon\\). 6.7.2 Modifikuotas Hadamardo testas Šis testas suteikia būdą apytikriai apskaičiuoti dviejų kvantinių būsenų, \\(\\{|\\psi\\rangle ,|\\phi\\rangle\\} \\in V\\), kurių kiekviena yra sudaryta iš \\(n\\) kubitų, vidinę sandaugą \\(\\langle\\psi |\\phi\\rangle\\). Dviejų normuotųjų būsenų vidinės sandaugos reikšmė yra bendrai kompleksinis skaičius, o modulis \\(|\\langle\\psi |\\phi\\rangle |\\leq 1\\). Turime du registrus, kurių pradinė būsena yra \\(|0\\rangle\\otimes|0\\rangle\\). Pirmasis registras yra 1 kubito ancila, o štai antrasis registras turi \\(n\\) kubitų ir naudojamas paruošti \\(|\\psi\\rangle\\) bei \\(|\\phi\\rangle\\) būsenų superpozicijai. Darome prielaidą, kad galime įvykdyti unitariąsias transformacijas \\(A\\) ir \\(B\\) pradinei registro būsenai \\(|0\\rangle\\), kurios leidžia paruošti norimas būsenas: \\(A|0\\rangle = |\\psi\\rangle\\) ir \\(B|0\\rangle = |\\phi\\rangle\\). Šis algoritmas skiriasi nuo Hadamardo testo tuo, kad \\(cU\\) tarp Hadamardo vartų yra pakeičiamas dvejais sąlyginiais loginiais vartais \\(cA\\) ir \\(cB\\) (žr. 6.9 pav.). 6.9 pav. Modifikuotą Hadamardo testą atliekanti loginė grandinė Pirmiausiai atliekame Hadamardo vartus ancila kubitui: \\[\\begin{equation} (H\\otimes I)|0\\rangle\\otimes|0\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|0\\rangle\\,. \\tag{6.57} \\end{equation}\\] Toliau atliekami dveji sąlyginiai vartai \\(cA\\) ir \\(cB\\) antrajam registrui, tačiau kontroliuojame skirtingose ancilos būsenose. Pritaikome \\(A\\), jeigu ancilos kubito būsena yra \\(|0\\rangle\\), ir \\(B\\), jeigu ancilos būsena yra \\(|1\\rangle\\). Kadangi ancila yra superpozicijoje, randame: \\[\\begin{equation} cBcA\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|0\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle + |1\\rangle\\otimes|\\phi\\rangle\\big)\\,. \\tag{6.58} \\end{equation}\\] Atliekame \\(H\\) ancilai: \\[\\begin{equation} \\begin{aligned} (H\\otimes I)\\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle + |1\\rangle\\otimes|\\phi\\rangle\\big) = &amp; \\frac{1}{2}|0\\rangle\\otimes\\big(|\\psi\\rangle + |\\phi\\rangle\\big) + \\frac{1}{2}|1\\rangle\\otimes\\big(|\\psi\\rangle - |\\phi \\rangle\\big) \\\\ \\equiv &amp; |\\chi\\rangle\\,. \\end{aligned} \\tag{6.59} \\end{equation}\\] Galiausiai išmatuojame ancilos būseną, apskaičiuodami tikrinių verčių vidurkį \\(\\langle\\chi |Z\\otimes I |\\chi\\rangle\\): \\[\\begin{equation} \\langle\\chi |Z\\otimes I|\\chi\\rangle = \\mathrm{Re}\\big\\lbrack\\langle\\psi |\\phi\\rangle\\big\\rbrack\\,. \\tag{6.60} \\end{equation}\\] Šis modifikuotas Hadamardo testas suteikia realiąją vidinės sandaugos \\(\\langle\\psi |\\phi\\rangle\\) dalį. Menamąją dalį \\(\\mathrm{Im}\\big\\lbrack\\langle\\psi |\\phi\\rangle\\big\\rbrack\\) galime rasti analogiškai kaip ir Hadamardo teste, pritaikę ancila kubitui papildomus vartus \\(S^{\\dagger}\\). 6.7.3 SWAP testas Šis testas (žr. 6.10 pav.) leidžia apskaičiuoti dviejų \\(n\\) kubitų kvantinių būsenų, \\(\\{|\\psi\\rangle , |\\phi\\rangle\\} \\in V\\), vidinės sandaugos kompleksinį kvadratą \\(|\\langle\\phi |\\psi\\rangle |^2\\). Šis neneigiamasis skaičius, \\(|\\langle\\phi |\\psi\\rangle |^2 \\leq 1\\), parodo, kiek būsenos persikloja ir yra panašios. Kvantinė grandinė realizuojant šią procedūrą yra sudaryta iš trijų registrų: 1 kubito ancilos ir dviejų \\(n\\) kubitų registrų, koduojančių būsenas \\(|\\psi\\rangle\\) ir \\(|\\phi\\rangle\\). Galime daryti prielaidą, kad šios dvi būsenos yra mums pateikiamos po prieš tai atlikto skaičiavimo, arba iš trečiosios šalies, pavyzdžiui, atsiųstos kvantiniu ryšiu. Tad pradinė faktorizuojama 3 kubitų būsena yra \\(|0\\rangle\\otimes|\\psi\\rangle\\otimes|\\phi\\rangle\\). Be šių skirtumų tarp Hadamardo testo, \\(cU\\) čia yra sąlyginiai \\(SWAP\\) (\\(Fredkin\\)) loginiai vartai, \\(cW\\), kontroliuojami ancila kubito. 6.10 pav. SWAP testo loginė grandinė Pirmiausiai, atlikę Hadamardo vartus ancila kubitui, turime: \\[\\begin{equation} \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\psi\\rangle\\otimes|\\phi\\rangle + |1\\rangle\\otimes|\\phi\\rangle\\otimes|\\psi\\rangle\\big)\\,. \\tag{6.61} \\end{equation}\\] Toliau atliekami Fredkin loginiai vartai, sukeičiantys antrojo ir trečiojo registro būsenas vietomis: \\[\\begin{equation} \\begin{split} cW\\frac{1}{\\sqrt{2}} &amp; \\big(|0\\rangle\\otimes|\\psi\\rangle\\otimes|\\phi\\rangle + |1\\rangle\\otimes|\\phi\\rangle\\otimes|\\psi\\rangle\\big) = \\\\ &amp; \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|\\phi\\rangle\\otimes|\\psi\\rangle + |1\\rangle\\otimes|\\psi\\rangle\\otimes|\\phi\\rangle\\big)\\,. \\end{split} \\tag{6.62} \\end{equation}\\] Pritaikius antrus Hadamardo loginius vartus ancila kubitui \\(H\\otimes I\\otimes I\\), galutinė būsena \\(|\\chi\\rangle\\) yra: \\[\\begin{equation} |\\chi\\rangle = \\frac{1}{2}|0\\rangle\\otimes\\big(|\\psi\\rangle\\otimes|\\phi\\rangle + |\\phi\\rangle\\otimes|\\psi\\rangle\\big) + \\frac{1}{2}|1\\rangle\\otimes\\big(|\\psi\\rangle\\otimes|\\phi\\rangle - |\\phi\\rangle\\otimes|\\psi\\rangle\\big)\\,. \\tag{6.63} \\end{equation}\\] Išmatuojame ancilos būseną, apskaičiuodami tikrinių verčių vidurkį \\(\\langle\\chi |Z\\otimes I|\\chi\\rangle\\): \\[\\begin{equation} \\langle\\chi |Z\\otimes I|\\chi\\rangle = |\\langle\\phi|\\psi\\rangle |^2\\,. \\tag{6.64} \\end{equation}\\] Tai tiesiogiai suteikia norimą reikšmę. Jos tikslumas gali būti pasiektas pageidaujamo dydžio didinant SWAP testo skaičių pateikiamoms identiškoms būsenoms \\(\\{|\\psi\\rangle , |\\phi\\rangle\\}\\). SWAP testo algoritmo laiko sudėtingumas auga kaip \\(O(1/\\epsilon^{2})\\) su siekiamu tikslumu \\(\\epsilon\\). Norint atlikti SWAP testą dviem \\(n\\) kubitų būsenoms, klasikinių algoritmų laiko sudėtingumas auga eksponentiškai su kubitų skaičiumi \\(n\\), o štai kvantinės SWAP testo grandinės gylis auga tiesiškai. Tai suteikia eksponentinį paspartinimą. Pabaigoje trumpai pakomentuosime stebimą Hadamardo ir SWAP testų kvantinės grandinės bendrąjį efektą. Ancila kubitas, pasitelkus Hadamardo vartus, yra pastatomas į būsenų superpoziciją, ir šios dvi būsenos supinamos su skirtingomis antrojo registro būsenomis, koduojančiomis \\(\\{|\\psi\\rangle , |\\phi\\rangle\\}\\). Kvantinės optikos požiūriu, tai padalija antrą registrą į du skirtingus optinius „kelius”, kuriuose kvantinės būsenos patiria skirtingus loginius vartus \\(U\\). Antrieji Hadamardo vartai, pritaikyti ancila kubitui, šiuos du kelius vėl sugrąžina į vieną. Tai priverčia antrojo registro kvantinę būseną patirti interferencinius efektus, kurie matavimuose seka iš vidinės sandaugos-tipo atsirandančių narių, \\(\\langle\\chi |U|\\chi\\rangle\\) ir \\(\\langle\\phi |\\psi\\rangle\\). "],["furjė-transformacija-ir-jos-taikymai.html", "7 skyrius. Furjė transformacija ir jos taikymai 7.1 Kvantinė Furjė transformacija 7.2 Furjė transformacijos realizavimas kvantinėje grandinėje 7.3 Funkcijos periodiškumo paieška 7.4 Kvantinis fazės nustatymo algoritmas 7.5 Tiesinių lygčių sprendimas HHL algoritmu", " 7 skyrius. Furjė transformacija ir jos taikymai Šiame skyriuje toliau tęsiame kvantinių skaičiavimų apžvalgą pristatydami Furjė transformaciją (angl. Fourier transform) ir ja pagrįstus algoritmus. Klasikinė Furjė transformacija yra plačiai naudojama atliekant duomenų ir signalų analizę bei apdorojimą ir yra esminės reikšmės įrankis matematinėje funkcijų analizėje. Kaip praktinį Furjė naudojimo pavyzdį, nebūtinai sunkų skaičiavimo išteklių atžvilgiu, imkime funkciją \\(f(t)\\), kuri nusako garso šaltinio kitimą laike. Šios funkcijos Furjė transformacija, žymima \\(\\mathrm{FT}\\lbrack f(t)\\rbrack = f(v)\\), išreiškia ją dažnių (\\(v\\)) spektro pavidale \\(f(v)\\). Norėdami atlikti pasirinktų dažnių filtravimą, pavyzdžiui, siekiant nuslopinti aukštojo dažnio garsus, galime užmaskuoti šias amplitudes dažnio srities funkcijoje \\(f(v)\\). Atlikę atvirkštinę \\(f(v)\\) funkcijos Furjė transformaciją, žymimą \\({\\mathrm{FT}}^{-1}\\lbrack f(v)\\rbrack = f(t)\\), grąžiname ją atgal į laiko sritį, taip atstatydami modifikuotą garso įrašą. 7.1 Kvantinė Furjė transformacija Kvantinė Furjė transformacija (angl. quantum Fourier transform) yra klasikinės Furjė transformacijos kvantinis realizavimas. Palyginus su vadinamuoju greituoju klasikiniu Furjė transformacijos algoritmu (angl. fast Fourier transform), naudojamu diskretiesiems (skaitmenizuotiems) signalams, kvantinė jos versija pasiekia eksponentinį pagreitinimą loginių operacijų skaičiaus atžvilgiu. Todėl kvantinė Furjė transformacija atveria galimybes paspartinti aibę skaičiavimo užduočių. Tarp jų yra kvantinių sistemų modeliavimas, tiesinių lygčių sprendinių paieška, kvantinio mašininio mokymosi algoritmai, Šoro pirminių skaičių faktorizavimas. Kvantinė Furjė transformacija (vartosime trumpinį FT) priima kaip įvestį \\(n\\) elementų vektorių ir pateikia išvestyje kitą \\(n\\) elementų vektorių. FT yra realizuojama unitariąja transformacija, vadinkime ją \\(U_{\\mathrm{FT}}\\), kurios efektas \\(n\\) kubitų skaičiuojamiesiems baziniams vektoriams \\(|x\\rangle\\) nusakomas: \\[\\begin{equation} U_{\\mathrm{FT}}|x\\rangle =\\frac{1}{\\sqrt{2^n}}\\sum_{y = 0}^{2^n - 1}\\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}|y\\rangle\\,. \\tag{7.1} \\end{equation}\\] Čia \\(x\\) ir \\(y\\) yra skaičiai, išreikšti dešimtaine sistema. Iš to gaunama \\(U_{\\mathrm{FT}}\\) operatoriaus matematinė išraiška diadomis: \\[\\begin{equation} U_{\\mathrm{FT}} =\\frac{1}{\\sqrt{2^n}}\\sum_{x = 0}^{2^{n} - 1}\\sum_{y = 0}^{2^n - 1} \\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}|y\\rangle\\langle x|\\,. \\tag{7.2} \\end{equation}\\] Matome, kad \\(U_{\\mathrm{FT}}\\), veikiantis bet kurį bazinį vektorių \\(|x\\rangle\\), transformuoja jį į lygią visų standartinių bazinių vektorių superpoziciją. Šie vektoriai yra perindeksuojami raide \\(y\\) ir kartu nešasi skirtingus fazės narius \\(\\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}\\). Šios eksponentės argumentuose \\(xy\\) yra daugyba, pavyzdžiui, jeigu \\(|x\\rangle = |5\\rangle\\) ir \\(|y\\rangle = |3\\rangle\\), tada \\(xy = 15\\). Operatorių \\(U_{\\mathrm{FT}}\\), žinoma, galima išreikšti ir \\((2^n \\times 2^n)\\) dydžio matrica. Jos \\(y\\) stulpelio ir \\(x\\) eilutės įrašai yra fazės nariai \\(\\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}/\\sqrt{2^n}\\). Būdama unitarioji transformacija, FT išlaiko vektorių normuotumą ir ortogonalumą \\(\\langle x&#39;| U^{\\dagger}_{\\mathrm{FT}}U_{\\mathrm{FT}}|x\\rangle =\\langle x&#39;|x\\rangle = 0\\). Tad \\(U_{\\mathrm{FT}}\\) leidžia sukurti naują \\(n\\) kubitų bazinių vektorių rinkinį, vadinamą Furjė bazinių vektorių rinkiniu (angl. Fourier basis). Viršuje \\(U^{\\dagger}_{\\mathrm{FT}}\\) yra \\(U_{\\mathrm{FT}}\\) operatoriaus ermitinė jungtis ir nusako atvirkštinę Furjė transformaciją, dar žymimą \\(\\mathrm{FT}^{\\dagger}\\) arba \\(\\mathrm{FT}^{-1}\\). Pritaikius \\(U^{\\dagger}_{\\mathrm{FT}}|x\\rangle\\) skirtumas nuo viršuje parodytos išraiškos bus tik kompleksinėje fazės narių jungtyje \\(\\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n} \\rightarrow\\mathrm{e}^{-\\mathrm{i}2\\pi xy/2^n}\\). Ar minuso ženklas vartojamas \\(U^{\\dagger}_{\\mathrm{FT}}\\), ar \\(U_{\\mathrm{FT}},\\) neturi esminės įtakos, svarbu tik sistemiškai juos vartoti. Pritaikę FT bendrai būsenai \\(|\\psi\\rangle\\), esančiai bazinių vektorių \\(|x\\rangle\\) superpozicijoje, randame: \\[\\begin{equation} U_{\\mathrm{FT}}|\\psi\\rangle = U_{\\mathrm{FT}}\\sum_{x = 0}^{2^n - 1} c_x|x\\rangle = \\frac{1}{\\sqrt{2^n}}\\sum_{x = 0}^{2^n - 1} \\sum_{y = 0}^{2^n - 1} c_x \\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}|y\\rangle\\,. \\tag{7.3} \\end{equation}\\] Atkreipiame dėmesį, kad \\(U_{\\mathrm{FT}}|\\psi\\rangle\\) nusako faktorizuojamą kvantinę \\(n\\) kubitų būseną. Šią išraišką galima supaprastinti: \\[\\begin{equation} U_{\\mathrm{FT}}|\\psi\\rangle = \\sum_{y = 0}^{2^n - 1} b_y|y\\rangle\\,. \\tag{7.4} \\end{equation}\\] Čia \\(b_y\\) yra gaunamas laikant \\(y\\) fiksuotą ir atliekant sumą \\(x\\) atžvilgiu, tai formaliai nusako funkciją, priklausančią tik nuo argumento \\(y\\): \\[\\begin{equation} b_y =\\frac{1}{\\sqrt{2^n}}\\sum_{x = 0}^{2^n - 1} c_x \\mathrm{e}^{\\mathrm{i}2\\pi xy/2^n}\\,. \\tag{7.5} \\end{equation}\\] Toliau pateikiame keletą kvantinės Furjė transformacijos pavyzdžių. Vieno kubito FT, \\(n = 1\\), yra randama: \\[\\begin{equation} U_{\\mathrm{FT}}|x\\rangle = \\frac{1}{\\sqrt{2}}\\sum_{y = 0}^1 \\mathrm{e}^{\\mathrm{i}2\\pi xy/2}|y\\rangle =\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x}|1\\rangle\\big)\\,. \\tag{7.6} \\end{equation}\\] Fazės narys \\(\\mathrm{e}^{\\mathrm{i}\\pi x} = 1\\), jeigu \\(U_{\\mathrm{FT}}\\) veikia \\(|x\\rangle = |0\\rangle\\), ir \\(\\mathrm{e}^{\\mathrm{i}\\pi x} = -1\\), jeigu \\(U_{\\mathrm{FT}}\\) veikia \\(|x\\rangle = |1\\rangle\\). Tad \\(n = 1\\) Furjė transformaciją galima išreikšti tiesiog Hadamardo loginiais vartais, \\(U_{\\mathrm{FT}} = H\\). Taip pat matome ir kitą specifinę situaciją, kai Furjė transformacija pritaikoma \\(n\\) kubitų registrui, esančiam \\(|0\\rangle\\) būsenoje (dešimtainėje sistemoje): \\[\\begin{equation} U_{\\mathrm{FT}}|0\\rangle =\\frac{1}{\\sqrt{2^n}}\\sum_{y = 0}^{2^n - 1}|y\\rangle\\,. \\tag{7.7} \\end{equation}\\] Jos efektą galima taip pat nusakyti kiekvienam iš \\(n\\) kubitų pritaikant Hadamardo vartus, \\(H^{\\otimes n}\\), taip sukuriant lygią visų bazinių vektorių superpoziciją. Paskutiniame pavyzdyje imkime vieno iš bazinių vektorių \\(|x\\rangle\\), nusakančio \\(n = 3\\) kubitų registro būseną, Furjė transformaciją: \\[\\begin{equation} \\begin{aligned} U_{\\mathrm{FT}}|x\\rangle = &amp; \\frac{1}{\\sqrt{8}}\\sum_{y = 0}^{7} \\mathrm{e}^{\\mathrm{i}2\\pi xy/8}|y\\rangle \\\\ = &amp; \\frac{1}{\\sqrt{8}}\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x/4}|1\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x/2}|2\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x3/4}|3\\rangle \\\\ &amp; + \\mathrm{e}^{\\mathrm{i}\\pi x}|4\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x5/4}|5\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x3/2}|6\\rangle + \\mathrm{e}^{\\mathrm{i}\\pi x7/4}|7\\rangle\\big)\\,. \\end{aligned} \\tag{7.8} \\end{equation}\\] Toliau pateikiame itin naudingą \\(n\\) kubitų bazinio vektoriaus \\(|x\\rangle\\) kvantinės Furjė transformacijos formą naudojant pavienių kubitų \\(n\\) tenzorinę sandaugą: \\[\\begin{equation} \\begin{aligned} U_{\\mathrm{FT}}|x\\rangle = &amp; \\frac{1}{\\sqrt{2^n}}\\prod_{k = 1}^n \\big(|0\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}2\\pi x}{2^k}}|1\\rangle\\big) \\\\ = &amp; \\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi x/2}|1\\rangle\\big)\\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi x/4}|1\\rangle\\big) \\otimes\\cdots\\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi x/2^n}|1\\rangle\\big)\\,. \\end{aligned} \\tag{7.9} \\end{equation}\\] Tai nusako \\(n\\) kubitų, kurių kiekvienas yra superpozicijoje, tenzorinę sandaugą ir todėl – faktorizuojamąją būseną. Šią išraišką galima taip pat perteikti dvejetaine forma pasitelkiant kubitų numeraciją \\(|x\\rangle = |k_1 k_2 \\cdots k_n\\rangle\\) su \\(k_i \\in\\{0, 1\\}\\) ir dvejetainės trupmenos apribrėžimą: \\[\\begin{equation} 0.k_1 k_2 \\cdots k_n =\\frac{k_1}{2} +\\frac{k_2}{4} +\\cdots +\\frac{k_n}{2^n} =\\sum_{i = 1}^n k_i 2^{-i}\\,. \\tag{7.10} \\end{equation}\\] Keletas dvejetainių trupmenų pavyzdžių: 0.1=1/2, 0.001=1/8, 0.011=3/8. Viską sudėjus kartu, \\(U_{\\mathrm{FT}}|x\\rangle\\) dvejetaine forma yra: \\[\\begin{equation} \\begin{split} U_{\\mathrm{FT}}|k_1 k_2\\cdots k_n\\rangle = &amp; \\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 0.k_{n}}|1\\rangle\\big) \\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 0.k_{n - 1}k_n}|1\\rangle\\big) \\otimes\\cdots \\\\ &amp; \\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 0.k_1 k_2 \\cdots k_n}|1\\rangle\\big)\\,. \\end{split} \\tag{7.11} \\end{equation}\\] 7.2 Furjė transformacijos realizavimas kvantinėje grandinėje Kvantinė Furjė transformacija yra efektyviai realizuojama kvantinėje grandinėje naudojant 1 kubito ir 2 kubitų loginius vartus. Pirmiausiai pateikiame kaip pavyzdį 3 kubitų registrui \\(U_{\\mathrm{FT}}\\) atliekančią kvantinę grandinę (žr. 7.1 pav.): 7.1 pav. 3 kubitų registrui kvantinę Furjė transformaciją atliekanti loginė grandinė Čia matome Hadamardo, 2-kubitų \\(cP_k\\) bei SWAP loginių vartų kombinaciją. Joje \\(cP_k\\) yra 4 skyriuje minėti sąlyginiai fazės vartai \\(cP_k(\\theta)\\) su \\(\\theta = \\mathrm{e}^{\\mathrm{i}2\\pi/2^k}\\), \\(k\\) – sveikasis skaičius. Matricos forma atrodo taip: \\[\\begin{equation} cP_{k} =\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}2\\pi/2^k} \\end{bmatrix}\\,. \\tag{7.12} \\end{equation}\\] Vartai \\(W\\) panaudojami grandinės pabaigoje, kadangi FT algoritmas sukeičia kubitų indeksavimą aplink centrinius kubitus. Šiuo atveju \\(k_1\\) sukeičiamas su \\(k_3\\), tad \\(W\\), panaudoti grandinės pabaigoje, atstato juos atgal į standartinę \\(\\{k_1, k_2, k_3\\}\\) seką. Aišku, nebūtina to daryti, jeigu toliau atliekami loginiai vartai atsižvelgiant į indeksavimo pasikeitimą. Atvirkštinė Furjė transformacija \\(\\mathrm{FT}^{\\dagger}\\) yra realizuojama atvirkštine loginių vartų seka panaudojant atvirkštinius loginius vartus. Hadamardo bei SWAP loginiai vartai yra patys sau atvirkštiniai, o štai atvirkštiniai \\(cP_k\\) vartai yra jų ermitinė jungtis \\({cP}_k^{\\dagger}\\). Atvirkštinę 3 kubitų transformaciją \\(\\mathrm{FT}^{\\dagger}\\) atliekanti grandinė yra pateikta 7.2 pav. 7.2 pav. Atvirkštinė 3 kubitų kvantinė Furjė transformacija Furjė transformacijoje, atliekamoje \\(n\\)-kubitų registrui, galime įžvelgti loginių vartų seką. Pradedant nuo viršutinio kubito \\(k_1\\), jam atliekami \\(H\\) bei sąlyginiai \\(cP_k\\) vartai poromis su visais \\(n-1\\) likusiais kubitais. Tai kartojama su \\(k_2, k_3, \\ldots\\) ir likusiais kubitais, paskutiniajam atliekant tik \\(H\\). 7.3 pav. Loginė grandinė, atliekanti kvantinę Furjė transformaciją \\(n\\) kubitų registrui Kaip minėjome, galima FT užbaigti \\(W\\) loginiais vartais siekiant atstatyti visų kubitų indeksavimo eiliškumą. Apibendrinus, norint atlikti FT \\(n\\) kubitų registrui yra panaudojami \\(n\\) \\(H\\) vartų, \\(n(n - 1)/2\\) sąlyginių \\(cP_k\\), ir ne daugiau nei \\(n/2\\) \\(W\\) vartų. Šie vartai gali būti realizuojami trimis \\(cX\\), o \\(cP_k\\) galima realizuoti pasitelkus ne daugiau negu 6 elementariuosius loginius vartus. Tad kvantinės \\(n\\) kubitų Furjė transformacijos sudėtingumas yra nulemtas \\(O(n^2)\\) elementarių loginių operacijų, o štai klasikinei diskrečiajai Furjė transformacijai prireiks eksponentiškai daugiau operacijų, \\(O(n2^n)\\). Galima pastebėti, kad sąlyginiuose 2 kubitų vartuose \\(cP_k\\) adresatiniam kubitui pritaikoma fazė \\(\\theta = \\mathrm{e}^{\\mathrm{i}2\\pi/2^k}\\) vis mažėja su didėjančiu \\(k\\). Todėl FT atliekama registrui, sudarytam iš didelio skaičiaus kubitų, nuo tam tikro \\(k\\) skaičiaus galima atitinkamiems kubitams nebetaikyti \\(cP_k\\), nes \\(\\theta\\) bus nereikšmingai maža. Tai leidžia dar labiau sumažinti loginių vartų skaičių, atkreipiant dėmesį, kad didėjantis \\(k\\) nusako atliekamus \\(cP_k\\) tarp vis toliau vienas nuo kito esančių kubitų. 7.3 Funkcijos periodiškumo paieška Pirmame Furjė transformacijos taikymo pavyzdyje parodysime funkcijos periodiškumo nustatymo algoritmą. Funkcija \\(f(x)\\) yra periodinė su periodu \\(P\\), jeigu \\(f(x) = f(x + P)\\) visiems \\(x\\) funkcijos \\(f\\) apibrėžimo intervale. Vienas periodinės funkcijos pavyzdys būtų trigonometrinė funkcija \\(f(x) =\\cos(2\\pi x/P)\\), nusakanti osciliacijas su periodu \\(P\\). Klasikiniai algoritmai gali nustatyti \\(P\\) su eksponentiniu laiko sudėtingumu, augančiu didėjant įvesties dydžiui \\(N\\). O štai paprastas kvantinis algoritmas, naudojantis FT, leidžia pasiekti eksponentinį paspartinimą. Imkime šio algoritmo pavyzdį su įvesties bei išvesties registrais, turinčiais po 3 kubitus, ir funkciją \\(f(x)\\), kurios periodas yra \\(P = 2\\). Dėl šio periodiškumo funkcijos reikšmės lyginiuose ir nelyginiuose argumentuose yra nusakytos \\(y&#39;\\) ir \\(y&#39;&#39;\\) vertėmis: \\(y&#39; = f(0) = f(2) = f(4) = f(6)\\) ir \\(y&#39;&#39; = f(1) = f(3) = f(5) = f(7)\\). Pirmiausia pradinės būsenos \\(|\\psi_0\\rangle = |0\\rangle\\otimes|0\\rangle\\) įvesties registrui pritaikome Hadamardo vartus \\(H^{\\otimes 3}\\), kurie sukuria lygią visų bazinių vektorių superpoziciją: \\[\\begin{equation} (H^{\\otimes 3}\\otimes I)|\\psi_0\\rangle =\\frac{1}{\\sqrt{8}}\\sum_{x = 0}^7 |x\\rangle\\otimes|0\\rangle\\,. \\tag{7.13} \\end{equation}\\] Kitame žingsnyje pritaikome abu registrus veikiančią transformaciją \\(U_f\\), kuri nusako periodinę funkciją \\(f(x)\\): \\[\\begin{equation} |\\psi_1\\rangle = U_f\\frac{1}{\\sqrt{8}}\\sum_{x = 0}^7 |x\\rangle\\otimes|0\\rangle = \\frac{1}{\\sqrt{8}}\\sum_{x = 0}^7 |x\\rangle\\otimes|f(x)\\rangle\\,. \\tag{7.14} \\end{equation}\\] Atliekame Furjė transformaciją įvesties registrui: \\[\\begin{equation} (U_{\\mathrm{FT}}\\otimes I)|\\psi_1\\rangle = \\frac{1}{8}\\sum_{x = 0}^7 \\sum_{y = 0}^7 \\mathrm{e}^{\\mathrm{i}2\\pi xy/8}|y\\rangle\\otimes|f(x)\\rangle\\,. \\tag{7.15} \\end{equation}\\] Šią dvigubą sumą apskaičiuosime pirmiausia sudėdami \\(x\\) indeksuotuosius narius ir laikant \\(y\\) fiksuotus, nes norime išnaudoti supaprastinimą, atsirandantį dėl \\(f(x)\\) periodiškumo. Vadindami šioje stadijoje bendrą būseną \\(|\\psi_2\\rangle\\) randame: \\[\\begin{equation} \\begin{split} |\\psi_2\\rangle = &amp; \\frac{1}{8}\\sum_{y = 0}^7 |y\\rangle\\otimes\\big(|f(0)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y}{4}}|f(1)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y}{2}}|f(2)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y3}{4}}|f(3)\\rangle \\\\ &amp; + \\mathrm{e}^{\\mathrm{i}\\pi y}|f(4)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y5}{4}}|f(5)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y3}{2}}|f(6)\\rangle + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y7}{4}}|f(7)\\rangle\\big)\\,. \\end{split} \\tag{7.16} \\end{equation}\\] Toliau panaudojame \\(f(x)\\) periodiškumą identifikuodami anksčiau minėtas vertes \\(y&#39;\\) ir \\(y&#39;&#39;\\) ir sugrupuojame šiuos narius: \\[\\begin{equation} |\\psi_2\\rangle =\\frac{1}{8}\\sum_{y = 0}^7 |y\\rangle\\otimes\\Big(\\big(1 + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y}{2}} + \\mathrm{e}^{\\mathrm{i}\\pi y} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y3}{2}}\\big)|y&#39;\\rangle + \\big(\\mathrm{e}^{\\frac{i\\pi y}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y3}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y5}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi y7}{4}}\\big)|y&#39;&#39;\\rangle\\Big)\\,. \\tag{7.17} \\end{equation}\\] Būsenos \\(|\\psi_2\\rangle\\) išraiška taip pat susiprastina dėl atsirandančių destruktyviųjų interferencijų sudedant skliausteliuose fazės narius. Pavyzdžiui, jeigu \\(y = 1\\), tada: \\[\\begin{align} \\left(1 + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi}{2}} + \\mathrm{e}^{\\mathrm{i}\\pi} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi 3}{2}}\\right)|y&#39;\\rangle = &amp; (1 + \\mathrm{i} - 1 - \\mathrm{i})|y&#39;\\rangle = 0\\,.\\tag{7.18} \\\\ \\left(\\mathrm{e}^{\\frac{\\mathrm{i}\\pi}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi 3}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi 5}{4}} + \\mathrm{e}^{\\frac{\\mathrm{i}\\pi 7}{4}}\\right)|y&#39;&#39;\\rangle = &amp; \\Bigg(\\frac{1}{\\sqrt{2}} +\\frac{\\mathrm{i}}{\\sqrt{2}} - \\frac{1}{\\sqrt{2}} + \\frac{\\mathrm{i}}{\\sqrt{2}} \\nonumber\\\\ &amp; - \\frac{1}{\\sqrt{2}} - \\frac{\\mathrm{i}}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}} - \\frac{\\mathrm{i}}{\\sqrt{2}}\\Bigg)|y&#39;&#39;\\rangle = 0\\,.\\tag{7.19} \\end{align}\\] Taip patikrinę visas \\(y\\) vertes sumoje matome, kad konstruktyvioji interferencija atsiranda tik įvesties registro būsenose \\(|y\\rangle = |0\\rangle\\) ir \\(|y\\rangle = |4\\rangle\\). Visų kitų būsenų amplitudės susideda į 0. Galutinė abiejų registrų būsena \\(|\\psi_3\\rangle\\) yra: \\[\\begin{equation} |\\psi_3\\rangle =\\frac{1}{2}|0\\rangle\\otimes\\big(|y&#39;\\rangle + |y&#39;&#39;\\rangle\\big) + \\frac{1}{2}|4\\rangle\\otimes\\big(|y&#39;\\rangle - |y&#39;&#39;\\rangle\\big)\\,. \\tag{7.20} \\end{equation}\\] Kadangi \\(\\langle y&#39;|y&#39;&#39;\\rangle =\\delta_{y&#39;y&#39;&#39;}\\), pamatavę įvesties registrą rasime būsenas \\(|0\\rangle\\) arba \\(|4\\rangle\\) su \\(p(0) = p(4) = 0.5\\) tikimybe. Būsena \\(|0\\rangle\\) nepriklauso nuo periodo, tad radus ją nėra suteikiama informacijos, tad teks kartoti žingsnius kol, šiuo atveju, bus rasta \\(|4\\rangle\\). Tai prisideda prie algoritmo laiko sudėtingumo. Būsena \\(|4\\rangle\\) tiesiogiai atspindi \\(P = 2\\) periodiškumą, nes pritaikius šį algoritmą \\(n\\) kubitų sistemai įvesties registre (žr. 7.4 pav.) bendrai išlieka tik šių būsenų superpozicija: \\[\\begin{equation} |0\\rangle\\,, |1\\cdot 2^n/P\\rangle\\,, |2\\cdot 2^n/P\\rangle\\,, |3\\cdot 2^n/P\\rangle\\,,\\ldots\\,, |(P - 1)\\cdot 2^n/P\\rangle\\,. \\tag{7.21} \\end{equation}\\] Darome prielaidą, kad \\(2^n/P\\) yra sveikasis skaičius, tad jeigu randama būsena \\(|y\\rangle\\), periodas yra \\(P = k(2^n/y)\\). Čia \\(k = 0, 1, 2,\\ldots, (P - 1)\\) yra sveikasis neneigiamasis skaičius, o \\(2^n\\) nusako sistemos dimensiją ir yra žinomas skaičius. Taikydami šią formulę matome, kad minėta būsena \\(|4\\rangle\\) indikuoja \\(P =\\frac{2^3}{4} = 2\\) periodą. Bendrai, jeigu perteiksime sąryšį taip \\(P/k = 2^n/y\\), tada atlikus \\(2^n/y\\) naryje abiejų skaičių padalijimą iš jų didžiausio bendrojo daliklio, gautas vardiklis bus periodas \\(P\\). Taip pat galima parodyti, kad jeigu \\(2^n/P\\) ir nėra sveikasis skaičius, amplitudės vis tiek išlieka tik tų būsenų \\(|y\\rangle\\), kurios yra artimos \\(k2^n/P\\) sveikajam skaičiui. 7.4 pav. Funkcijos periodiškumą nustatanti loginė grandinė. Furjė transformacija \\(n\\) kubitų registrui glaustai užrašyta kaip modulis FT 7.4 Kvantinis fazės nustatymo algoritmas Šis algoritmas (angl. quantum phase estimation) pasitelkia kvantinę Furjė transformaciją ir aptinkamas kaip modulis kituose algoritmuose. Tarp jų yra kvantinis tiesinių lygčių sprendimo algoritmas, kurį pristatome kitame poskyryje. Fazės nustatymo algoritmo sudėtingumas yra nulemtas FT modulio, kuriam prireiks \\(O(n^2)\\) elementariųjų operacijų. Fazės nustatymo algoritmo užduotis yra rasti unitariojo operatoriaus \\(U\\) tikrines vertes. Unitariųjų operatorių tikrinės vertės \\(\\lambda_u\\) turi bendrą formą \\(\\lambda_u = \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_u}\\) ir tenkina lygtį: \\[\\begin{equation} U|u\\rangle = \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_u}|u\\rangle\\,. \\tag{7.22} \\end{equation}\\] Čia \\(U\\) yra unitarusis operatorius, kurio tikrinė vertė \\(\\lambda_u = \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_u}\\) asocijuota su tikriniu vektoriumi \\(|u\\rangle\\) (darome prielaidą, kad tikriniai vektoriai yra neišsigimę). Parametras, įvardijantis \\(U\\) skirtingas tikrines vertes \\(\\lambda_u\\), yra fazė \\(\\theta_u\\) (realusis skaičius) ir \\(0\\leq\\theta_u &lt; 1/2\\pi\\) dėl periodiškumo. Literatūroje galima rasti pervadintą \\(\\theta_u\\) įkomponuojant \\(2\\pi\\), tada \\(\\lambda_{u} = \\mathrm{e}^{\\mathrm{i}\\theta_u}\\) ir \\(\\theta_u \\rightarrow\\theta_u/2\\pi\\). Fazės nustatymo algoritmas leidžia, skaičiavimo išteklių atžvilgiu, efektyviai apskaičiuoti \\(\\theta_u\\) pageidaujamu tikslumu. Šiuo metodu naudojamas fazės atatrankos triukas, kurį jau matėme Doičo ir Groverio algoritmuose. Imkime paprastą 2 kubitų būsenos pavyzdį: \\[\\begin{equation} |k_1\\rangle\\otimes|k_2\\rangle =\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\otimes|u\\rangle\\,. \\tag{7.23} \\end{equation}\\] Čia kubitas \\(k_2\\) yra \\(U\\) operatoriaus tikrinio vektoriaus būsenoje \\(|u\\rangle\\). Pritaikome šiems dviem kubitams sąlyginį 2 kubitų operatorių \\(cU\\), kuriame \\(k_2\\) kubitas yra adresatinis: \\[\\begin{equation} cU|k_1\\rangle\\otimes|k_2\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|u\\rangle + |1\\rangle\\otimes U|u\\rangle\\big) = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_{u}}|1\\rangle\\big)\\otimes|u\\rangle\\,. \\tag{7.24} \\end{equation}\\] Matome, kad amplitudė, nusakanti \\(|u\\rangle\\) būsenos tikrinę vertę \\(\\lambda_u = \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_u}\\), yra perkeliama kubitui \\(k_1\\). Fazės nustatymo algoritmas pasikliauja gebėjimu paruošti \\(U\\) operatoriaus tikrinį vektorių \\(|u\\rangle\\) ir atlikti sąlyginius \\(cU^{2^n}\\) vartus, kai \\(U^{2^n}\\) yra \\(U\\) pritaikytas \\(2^n\\) kartų (pakeltas \\(2^n\\) laipsniu). Pavyzdžiui, \\(U^2|u\\rangle = UU|u\\rangle = \\mathrm{e}^{\\mathrm{i}2\\pi\\theta_u}U|u\\rangle = \\mathrm{e}^{\\mathrm{i}2\\pi 2\\theta_u}|u\\rangle\\). Taip tęsdami matome: \\[\\begin{equation} U^{2^n}|u\\rangle = \\mathrm{e}^{\\mathrm{i}2\\pi 2^n\\theta_u}|u\\rangle\\,. \\tag{7.25} \\end{equation}\\] Kvantinė grandinė, realizuojanti fazės nustatymą, yra parodyta 7.5 pav. 7.5 pav. Bendra loginė grandinė, realizuojanti fazės nustatymo algoritmą Pirmasis registras yra sudarytas iš \\(n\\) kubitų, čia skaičius \\(n\\) yra parenkamas pagal tai, kokį norima pasiekti fazės \\(\\theta\\) tikslumą bitais. Atkreipiame dėmesį, kad naudojamas bazinių vektorių kodavimo metodas (žr. 6.4 poskyrį). Antrasis registras sudarytas iš \\(m\\) kubitų, reikalingų \\(U\\) operatoriaus tikriniam vektoriui \\(|u\\rangle\\) perteikti. Pritaikę \\(H^{\\otimes n}\\) bei \\(cU^{2^n}\\) vartų sekas, randame šią bendrą būseną: \\[\\begin{equation} \\begin{aligned} |\\psi\\rangle = &amp; \\frac{1}{\\sqrt{2^n}}\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 2^{n - 1}\\theta_u}|1\\rangle\\big) \\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 2^{n - 2}\\theta_u}|1\\rangle\\big) \\otimes\\cdots \\\\ &amp; \\otimes\\big(|0\\rangle + \\mathrm{e}^{\\mathrm{i}2\\pi 2^{0}\\theta_u}|1\\rangle\\big)\\otimes|u\\rangle \\\\ = &amp; \\frac{1}{\\sqrt{2^n}}\\sum_{y = 0}^{2^n - 1} \\mathrm{e}^{\\mathrm{i}2\\pi y\\theta_u}|y\\rangle\\otimes|u\\rangle\\,. \\end{aligned} \\tag{7.26} \\end{equation}\\] Antroje eilutėje atlikome supaprastinimą, išskleisdami visas \\(n\\) kubitų tenzorines sandaugas. Tada, atpažindami \\(n\\) kubitų superpoziciją, pervadinome \\(|y\\rangle\\) bazinius vektorius dešimtainėje sistemoje. Antrasis \\(m\\) kubitų registras \\(|u\\rangle\\) būsenoje nebeturi įtakos likusiems algoritmo žingsniams. Atliekame atvirkštinę \\(\\mathrm{FT}^{\\dagger}\\) pirmam \\(n\\) kubitų registrui: \\[\\begin{equation} (U_{\\mathrm{FT}}^{\\dagger}\\otimes I)\\frac{1}{\\sqrt{2^n}}\\sum_{y = 0}^{2^n - 1} \\mathrm{e}^{\\mathrm{i}2\\pi y\\theta_u}|y\\rangle\\otimes|u\\rangle = \\frac{1}{2^n}\\sum_{l = 0}^{2^n - 1} \\sum_{x = 0}^{2^n - 1} \\mathrm{e}^{\\frac{-\\mathrm{i}2\\pi l(x - 2^n \\theta_u)}{2^n}}|x\\rangle\\otimes|u\\rangle\\,. \\tag{7.27} \\end{equation}\\] Atlikus dvigubą indeksų \\(l\\) ir \\(x\\) sudėtį, pirmojo registro amplitudė turi didelę vertę tik ties \\(x\\approx 2^n \\theta_u\\), tai yra \\(|x\\rangle = |2^n \\theta_u\\rangle\\) būsenai. Galutinę \\(|\\psi\\rangle\\) galima užrašyti: \\[\\begin{equation} |\\psi\\rangle\\cong |2^n\\theta_u\\rangle\\otimes|u\\rangle\\,. \\tag{7.28} \\end{equation}\\] Todėl pirmojo registro būsenos matavimas su didele tikimybe grąžins \\(|2^n \\theta_u\\rangle\\) būseną. Fazė yra randama \\(\\theta_u = x/2^n\\), čia \\(x\\) nusako pirmojo registro matavimo rezultatą. Atvirkštinės \\(\\mathrm{FT}^{\\dagger}\\) naudojimo reikšmę šiame algoritme galima pamatyti, jeigu fazę perteiksime dvejetainės trupmenos forma, \\(\\theta_u = 0.k_1 k_2 \\cdots k_n\\) su \\(n\\)­bitų tikslumu. Tada, pritaikius \\(H^{\\otimes n}\\) ir \\(cU^{2^n}\\) sekas, būsena \\(|\\psi\\rangle\\) įgauna formą dvejetainėje sistemoje, kuri yra identiškai nusakoma FT atlikimu \\(U_{\\mathrm{FT}}|2^n k_1 k_2 \\cdots k_n\\rangle\\). Iškvietę atvirkštinę \\(\\mathrm{FT}^{\\dagger}\\), randame \\(U_{\\mathrm{FT}}^{\\dagger}U_{\\mathrm{FT}}|2^n k_1 k_2 \\cdots k_n\\rangle = |2^n k_1 k_2 \\cdots k_n\\rangle\\), ir tai vėl tiesiogiai įvardija \\(\\theta_u\\) dvejetainėje formoje. Fazės nustatymo algoritme reikalinga paruošti pradinę registrų būseną į \\(|0\\rangle^{\\otimes n}\\otimes|u\\rangle\\). Tačiau itin tiksliai paruošti \\(U\\) operatoriaus tikrinį vektorių \\(|u\\rangle\\) gali būti keblu. Kaip tada veiks algoritmas? Atkreipiame dėmesį, kad bendrą būseną \\(|\\phi\\rangle\\) visada galima perteikti \\(U\\) operatoriaus tikriniais vektoriais \\(|u\\rangle\\): \\[\\begin{equation} |\\phi\\rangle =\\sum_u c_u |u\\rangle\\,. \\tag{7.29} \\end{equation}\\] Čia amplitudės \\(c_u =\\langle u|\\phi\\rangle\\) nusako šių būsenų persiklojimą. Pritaikius fazės nustatymo algoritmą (FN), realizuojamą \\(U_{\\mathrm{FN}}\\) būsenai \\(|\\phi\\rangle\\), rezultatas bus superpozicija: \\[\\begin{equation} U_{\\mathrm{FN}}|\\phi\\rangle\\cong\\sum_u c_u |2^n \\theta_u \\rangle\\otimes|u\\rangle\\,. \\tag{7.30} \\end{equation}\\] Tikimybė rasti būseną \\(|u\\rangle\\) bei su ja supintą pirmojo registro būseną \\(|2^n \\theta_u\\rangle\\), kuri nusako tikrinę vertę, yra \\(|c_u|^2\\). Kitaip tariant, netikslus \\(|u\\rangle\\) paruošimas gali įvesti atsitiktinumo į rezultatą, dėl šios priežasties bus rasta kita \\(U\\) operatoriaus tikrinė vertė su tikimybe \\(|c_u|^2 (1 -\\epsilon)\\). Faktorius \\((1 -\\epsilon)\\) atsiranda dėl tikslumo, kuriuo pasirenkama nustatyti fazę. Todėl nebūtina idealiai tiksliai paruošti \\(|u\\rangle\\), pakanka pradinę būseną \\(|\\phi\\rangle\\) padaryti kuo panašesnę į norimą \\(|u\\rangle\\) maksimizuojant jų persiklojimą \\(|\\langle u |\\phi\\rangle|\\). Jeigu \\(2^n \\theta_u\\) ir nėra sveikasis skaičius, šis algoritmas vis tiek grąžina ieškomąją fazę su didesne nei \\(p = 0.4\\) tikimybe. Tikimybė rasti ieškomą rezultatą ir \\(\\theta\\) skaičiaus tikslumas gali būti padidinti pasitelkus daugiau \\(n\\) kubitų pirmajame registre. Galima formaliai parodyti, kad kubitų skaičius \\(n\\) grandinėje auga kaip \\(O(\\log(1/\\epsilon))\\) siekant \\(\\epsilon\\) paklaidos bei reikalauja \\(O(1/\\epsilon)\\) sąlyginių loginių vartų \\(cU\\). 7.5 Tiesinių lygčių sprendimas HHL algoritmu Kvantinis HHL algoritmas (jo kūrėjų Harrow-Hassidim-Lloyd pavardžių trumpinys) leidžia spręsti tiesinių lygčių sistemas ir suteikia žymų paspartinimą prieš klasikinius algoritmus: Gauso pašalinimą (angl. Gauss elimination) ir konjuguotojo gradiento metodą (angl. conjugate gradient method). Vadinamasis matricos sąlygos skaičius (angl. condition number) nusako didžiausios ir mažiausios matricos \\(A\\) tikrinių verčių santykį, \\(\\kappa =\\lambda_{\\max}/\\lambda_{\\min}\\). Didėjant \\(\\kappa\\) tampa sunkiau invertuoti matricą \\(A\\), ir todėl mažėja HHL algoritmo stabilumas. HHL algoritmo laiko vykdymo trukmė auga kaip \\(O(\\kappa^2\\log 2^m)\\) ir suteikia eksponentinį paspartinimą sistemos dydžio atžvilgiu \\(2^m\\) prieš klasikinius algoritmus, kurie pasižymi \\(O(\\kappa 2^m)\\). HHL algoritmas yra aptinkamas kaip modulis kituose kvantiniuose algoritmuose, įskaitant mašininio mokymosi ir kvantinių sistemų modeliavimo, savo ruožtu leidžia paspartinti šiuos skaičiavimus. Pirmiausiai apžvelgsime šio algoritmo bendruosius veikimo principus ir pateiksime jo realizaciją kvantinėje grandinėje. Tiesinių lygčių sistema yra išreiškiama lygtimi: \\[\\begin{equation} A|x\\rangle = |b\\rangle\\,. \\tag{7.31} \\end{equation}\\] Sprendžiant lygčių sistemą kvantiniu kompiuteriu, operatorius \\(A\\) tiesinėje algebroje yra ermitinė \\((2^m \\times 2^m)\\) dydžio matrica, \\(|x\\rangle\\) ir \\(|b\\rangle\\) yra \\(2^m\\) dimensijų normuotieji vektoriai. Matrica \\(A\\) bei vektorius \\(|b\\rangle\\) yra nurodyti, algoritmo užduotis – rasti vektorių \\(|x\\rangle\\), tenkinantį šią lygčių sistemą. Bendrai ši sistema nusako \\(2^m\\) skaičių lygčių ir \\(2^m\\) skaičių nežinomųjų, kurie yra \\(|x\\rangle\\) vektoriaus amplitudės. Sprendimas \\(|x\\rangle\\) randamas invertuojant \\(A\\) matricą, tai yra apskaičiuojant \\(A^{-1}\\) (\\(A^{-1}A = I\\)), nes: \\[\\begin{equation} |x\\rangle = A^{-1}|b\\rangle\\,. \\tag{7.32} \\end{equation}\\] Reikalavimas, kad \\(A\\) būtų ermitinė matrica, gali būti sušvelninamas; mat jeigu \\(A\\) nėra ermitinė, galime apibūdinti naują matricą \\(B\\), kuri yra ermitinė: \\[\\begin{equation} B =\\begin{pmatrix} 0 &amp; A\\\\ A^{\\dagger} &amp; 0 \\end{pmatrix}\\,. \\tag{7.33} \\end{equation}\\] ir išspręsti susijusią lygčių sistemą: \\[\\begin{equation} B\\begin{pmatrix} 0\\\\ |x\\rangle \\end{pmatrix} = \\begin{pmatrix} |b\\rangle\\\\ 0 \\end{pmatrix}\\,. \\tag{7.34} \\end{equation}\\] Toliau darome prielaidą, kad \\(A\\) yra ermitinis operatorius, perteikę spektrine dekompozicija: \\[\\begin{equation} A =\\sum_{k = 0}^{2^m - 1} \\lambda_k |a_k\\rangle\\langle a_k|\\,. \\tag{7.35} \\end{equation}\\] Diados yra sudarytos iš operatoriaus \\(A\\) tikrinių vektorių \\(|a_k\\rangle,\\) asocijuotų su tikrinėmis vertėmis \\(\\lambda_k\\). Tiesinėje algebroje \\(A\\) yra diagonalioji matrica, kurios įstrižainės yra tikrinės vertės \\(\\lambda_k\\). Tad jos atvirkštinė matrica \\(A^{-1}\\) diadų formoje yra tiesiog: \\[\\begin{equation} A^{-1} =\\sum_{k = 0}^{2^m - 1} \\frac{1}{\\lambda_k}|a_k\\rangle\\langle a_k|\\,. \\tag{7.36} \\end{equation}\\] Tai irgi diagonalioji matrica su įstrižainės vertėmis \\(\\lambda_k^{-1}\\). Vektorius \\(|b\\rangle\\) taip pat gali būti išreikštas \\(A\\) operatoriaus tikriniais vektoriais \\(|a_i\\rangle\\): \\[\\begin{equation} |b\\rangle =\\sum_{i = 0}^{2^m - 1} b_i|a_i\\rangle\\,. \\tag{7.37} \\end{equation}\\] Sudėjus šias išraiškas ir pritaikius bazinių vektorių ortogonalumą \\(\\langle a_k | a_i\\rangle =\\delta_{k,i}\\), sprendinys yra ieškomas tokia forma: \\[\\begin{equation} |x\\rangle =\\sum_{k = 0}^{2^m - 1} \\lambda_k^{-1} b_k|a_k\\rangle\\,. \\tag{7.38} \\end{equation}\\] Tad ieškomasis vektorius \\(|x\\rangle\\) bus koduojamas kaip tikrinių vektorių \\(|a_k\\rangle\\) amplitudės (žr. 6.4 poskyrį). Atkreipiame dėmesį, kad būsenų matavimas galiausiai yra atliekamas Pauli-\\(Z\\) tikrinių vektorių bazėje {\\(|0\\rangle, |1\\rangle\\)}, o ne {\\(|a_k\\rangle\\)}. Tačiau galima matematiškai patikrinti, kad šiuo atveju vis tiek bus gautos teisingos amplitudės tarp šių bazinių vektorių rinkinių saryšio, jeigu kubitai nėra supintieji. HHL algoritmo pagrindinis tikslas yra perteikti būseną \\(|b\\rangle\\) operatoriaus \\(A\\) tikriniais vektoriais \\(|a_k\\rangle\\) ir nustatyti jo tikrines vertes \\(\\lambda_k\\). Kadangi \\(A\\) yra ermitinis operatorius, jo eksponentė nusako unitarinį operatorių, ir todėl galime panaudoti kvantinį fazės nustatymo algoritmą rasti norimoms vertėms. Hamiltoniano kodavimo metodas (angl. hamiltonian encoding) leidžia simuliuoti matricą \\(A\\) unitariuoju operatoriumi ir todėl išreikšti loginiais vartais: \\[\\begin{equation} U = \\mathrm{e}^{\\mathrm{i}At}\\,. \\tag{7.39} \\end{equation}\\] Kodavimo pavadinime žodis „hamiltonianas” atsiranda dėl to, kad \\(A\\) yra ermitinis operatorius ir todėl iš principo nusako tam tikros kvantinės sistemos energijos lygius. Tad iš \\(A\\) suformuotas unitariusis operatorius \\(U\\) nusako šios sistemos laiko evoliuciją (žr. 3 skyrių), (7.39) lygybėje matome laiko kintamąjį \\(t\\). Ermitinio operatoriaus \\(A\\) matematinė išraiška nusakys, kaip galima realizuoti eksponentę \\(\\mathrm{e}^{\\mathrm{i}At}\\). Tai gali būti itin paprasta diagonalioji matrica, kurią galima išreikšti be aproksimacijų, arba gali prireikti kitų metodų. Vieną bendrojo tipo aproksimacijos metodą, vadinamą „troterizacija”, pristatome 8 skyriuje. Tęsiant algoritmo apibūdinimą, išreiškus \\(U\\) spektrine dekompozicija: \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}At} =\\sum_{k = 0}^{2^m - 1} \\mathrm{e}^{\\mathrm{i}\\lambda_k t}|a_k\\rangle\\langle a_k|\\,. \\tag{7.40} \\end{equation}\\] Operatoriaus tikrinės vertės \\(\\mathrm{e}^{\\mathrm{i}\\lambda_k t}\\) yra asocijuotos su \\(U\\) tikriniais vektoriais \\(|a_k\\rangle\\), kurie čia taip pat yra ir \\(A\\) tikriniai vektoriai. Pažvelgus į fazės nustatymo algoritme naudojamus tikrinių verčių apibrėžimus ir lyginant su šiuo, \\(\\mathrm{e}^{\\mathrm{i}2\\pi\\theta_k} \\rightarrow \\mathrm{e}^{\\mathrm{i}\\lambda_k t}\\), ermitinio operatoriaus \\(A\\) tikrinė vertė susieta su faze \\(\\theta_k =\\lambda_k t/2\\pi\\). Tai yra visi reikalingi matematiniai įrankiai, naudojami HHL algoritme. Toliau apibūdinkime jo žingsnius, parodytus kvantinėje grandinėje 7.6 pav. 7.6 pav. HHL algoritmo realizavimas loginėje grandinėje. Daroma prielaida, kad būsena \\(|b\\rangle\\) jau yra paruošta antrajame registre. Sąlyginiai \\(m + 1\\) kubitų loginiai vartai \\(cR_y(\\theta)\\) yra kontroliuojami \\(m\\) kubitais ir keičia adresato ancila kubito būseną. Kartu su parodytomis Furjė transformacijomis ir ancila kubito matavimu ši algoritmo dalis yra kartojama, kol ancila kubitas randamas \\(|1\\rangle\\) būsenoje HHL naudoja tris kubitų registrus. Pirmųjų dviejų registrų funkcijos čia yra iš esmės tokios pačios, kaip ir fazės nustatymo algoritme. Pirmasis registras turi \\(n\\) skaičių kubitų, jame užrašomos tikrinės vertės dvejetaine forma su atitinkamu bitų tikslumu. Antrasis registras turi \\(m\\) skaičių kubitų, jame įrašoma ir transformuojama būsena \\(|b\\rangle\\), kurią čia perteikėme tikriniais vektoriais \\(|a_k\\rangle\\). Antrajame registre ir bus galiausiai užrašomas sprendinys \\(|x\\rangle\\). Trečiasis registras yra 1 kubito ancila, kurios paskirtį iliustruosime toliau. Pradinė normuotoji trijų registrų būsena \\(|\\phi\\rangle\\) po būsenos \\(|b\\rangle\\) paruošimo yra: \\[\\begin{equation} |\\phi\\rangle =\\sum_k b_k|0\\rangle\\otimes|a_k\\rangle\\otimes|0\\rangle\\,. \\tag{7.41} \\end{equation}\\] Tolesniame žingsnyje pritaikome fazės nustatymo algoritmą tarp pirmų dviejų registrų, kurio visus žingsnius kompaktiškai žymime \\(U_{\\mathrm{FN}}\\). Randame: \\[\\begin{equation} U_{\\mathrm{FN}}|\\phi\\rangle = \\sum_k b_k|\\tilde{\\lambda}_k\\rangle\\otimes|a_k\\rangle\\otimes|0\\rangle\\,. \\tag{7.42} \\end{equation}\\] Čia fazė yra koduojama: \\(\\tilde{\\lambda}_k = 2^n \\lambda_k t/2\\pi\\). Tai leidžia tiesiogiai susieti \\(|\\tilde{\\lambda}_k\\rangle\\) būseną su ieškomosiomis tikrinėmis vertėmis \\(\\lambda_k\\). Parametro \\(t\\) dydis yra pasirenkamas pagal \\(U\\) realizavimo metodą, siekiant sumažinti \\(U\\) atlikimo klaidas ir nepadaryti algoritmo ilgo loginių vartų atžvilgiu. Šioje stadijoje norima atlikti pirmojo registro transformaciją: \\(|\\tilde{\\lambda}_k\\rangle \\rightarrow C\\lambda_k^{-1}|\\tilde{\\lambda}_k\\rangle\\); čia \\(C\\) yra konstanta, reikalinga užtikrinti būsenų normavimui, ir ji turėtų būti mažesnė nei mažiausia tikrinė vertė, \\(|C| &lt;\\lambda_{\\min}\\). Tam pasitelkiamas ancila kubitas, kuriam atliekami sąlyginiai loginiai vartai \\(cR_y(\\theta)\\), kontroliuojami pirmojo registro \\(|\\tilde{\\lambda}_k\\rangle\\) būsenomis, su atitinkamai pasirinktu \\(\\theta\\): \\[\\begin{equation} cR_y(\\theta)U_{\\mathrm{FN}}|\\phi\\rangle = \\sum_k b_k|\\tilde{\\lambda}_k\\rangle\\otimes|a_k\\rangle\\otimes \\left\\lbrack\\sqrt{1 - (C\\lambda_k^{-1})^2}|0\\rangle + C\\lambda_k^{-1}|1\\rangle\\right\\rbrack\\,. \\tag{7.43} \\end{equation}\\] Matome, kad jeigu išmatuotume ancila kubitą, radus jo būseną esant \\(|1\\rangle\\) bendrai būsenai bus perteikta amplitudė \\(C\\lambda_k^{-1}\\). Atkreipiame dėmesį, kad pirmi du registrai yra supintieji, tad norint perteikti teisingas amplitudes antrajam registrui reikia panaikinti supynimą. Paskutiniame žingsnyje pritaikome atvirkštinę fazės nustatymo rutiną, \\(U_{\\mathrm{FN}}^{\\dagger}\\), grąžindami pirmąjį registrą į pradinę būseną ir panaikindami supynimą tarp pirmų dviejų registrų. Ignoruodami potencialius netikslumus, kylančius iš \\(U_{\\mathrm{FN}}\\) ir \\(U_{\\mathrm{FN}}^{\\dagger}\\), randame: \\[\\begin{equation} U_{\\mathrm{FN}}^{\\dagger} cR_y(\\theta)U_{\\mathrm{FN}}|\\phi\\rangle = \\sum_k b_k|0\\rangle\\otimes|a_k\\rangle\\otimes \\left\\lbrack\\sqrt{1 - (C\\lambda_k^{-1})^2}|0\\rangle + C\\lambda_k^{-1}|1\\rangle\\right\\rbrack\\,. \\tag{7.44} \\end{equation}\\] Šioje stadijoje atliekame ancila kubito matavimą. Radus jo būseną esant \\(|1\\rangle\\), sprendinys \\(|x\\rangle\\) matomas antrajame registre: \\[\\begin{equation} |0\\rangle\\otimes|x\\rangle\\otimes|1\\rangle = \\frac{1}{\\sqrt{N}}\\sum_k |0\\rangle\\otimes b_k \\lambda_k^{-1}|a_k\\rangle\\otimes|1\\rangle\\,. \\tag{7.45} \\end{equation}\\] Su būsenos normavimo konstanta \\(N\\): \\[\\begin{equation} N =\\sum_k |b_k \\lambda_k^{-1}|^2\\,. \\tag{7.46} \\end{equation}\\] Radus ancila kubitą \\(|0\\rangle\\) būsenoje tektų kartoti žingsnius iš naujo, tai prisideda prie algoritmo laiko sudėtingumo. Kadangi taikomas amplitudžių kodavimas, atsakymo \\(|x\\rangle\\) tiesiogiai nuskaityti nepavyks. Vis dėlto dažnai yra svarbiau sužinoti ne patį atsakymą, bet jo tam tikras savybes, vidutines vertes, momentus, santykinę būsenos orientaciją sprendinių erdvėje. Pasitelkdami Hadamardo testą (žr. 6.7 poskyrį) ar kitą panašų metodą, galime apskaičiuoti sprendinio funkciją \\(f(x) =\\langle x|M|x\\rangle\\), realizuojant ją atitinkamai suformuluotu kvantiniu operatoriumi \\(M\\). "],["sistemu-modeliavimas-ir-qml.html", "8 skyrius. Kvantinių sistemų modeliavimas ir mašininis mokymasis 8.1 Dinaminių sistemų modeliavimas 8.2 Erdvinės Šriodingerio lygties sprendimo algoritmas 8.3 Mašininis mokymasis", " 8 skyrius. Kvantinių sistemų modeliavimas ir mašininis mokymasis 8.1 Dinaminių sistemų modeliavimas Klasikinių bei kvantinių sistemų modeliavimas yra pagrįstas diferencialinių lygčių sprendinių paieška. Diferencialinės lygtys nusako sistemos dinamiką laike bei erdvėje ir atspindi dėsnius, kuriais šios sistemos pagrįstos. Klasikinėje fizikoje dažnai aptinkamos Niutono, Maksvelo ir Einšteino diferencialinės lygtys. Jos apibūdina sistemos pozicijų konfigūracijas, elektromagnetinių ir gravitacinių laukų kitimą, atitinkamai. Įprastai kompiuteriniai skaičiavimai diskretizuoja diferencialinės lygties kintamuosius, tokius kaip laiko ir erdvės. Tada iteracinė procedūra pradinę sistemos būseną nuveda prie ieškomosios galutinės. Diskretizavimo žingsnių dydis pasirenkamas atsižvelgiant į toleruotinus paklaidos dydžius, kuriuos dažnai galima tiksliai įvertinti. Modeliuojamos sistemos dydis ir jos dinamikos tikslumas bus nulemti prieinamų skaičiavimo išteklių. Pavienių ir sudėtinių kvantinių sistemų dinamiką apibūdina 3 skyriuje minėta Šriodingerio lygtis: \\[\\begin{equation} \\mathrm{i}\\hbar\\frac{d|\\psi(t)\\rangle}{dt} = H|\\psi(t)\\rangle\\,. \\tag{8.1} \\end{equation}\\] Ši lygtis tinka kvantinėms sistemoms, kuriose reliatyvistiniai efektai yra nereikšmingi arba gali būti aproksimuojami efektyviu hamiltonianu \\(H\\). Tokio tipo sistemas čia ir aptarsime. 8.1.1 Aizingo modelis ir hamiltoniano kodavimas Pirmiausia pradėkime nuo teiginio, kad sudėtinės kvantinės sistemos, kurių būsenos matematiškai aprašomos identiškai kubitams, natūraliai tinka kvantinės kompiuterijos taikymams. Tai iš principo atstoja gerai kontroliuojamą eksperimentą su šiomis sistemomis. Tarp jų yra medžiagų magnetizmą nulemiančios elementariosios bei sudėtinės dalelės (elektronai, protonai, neutronai), turinčios \\(1/2\\) sūkį (angl. \\(1/2\\) spin). Šios dalelės magnetiniame lauke elgiasi panašiai kaip magnetiniai dipoliai. Blocho vektorius, orientuotas į ortogonaliąsias \\(|0\\rangle\\) arba \\(|1\\rangle\\) būsenas, yra atitinkamai magnetinė „šiaurė” arba „pietūs”. Vienas pavyzdys – periodiškai išsidėlioję atomai kristaluose, kuriuose kiekvienoje atomo pozicijoje yra po vieną nesuporuotą elektroną (kubitą). Aizingo modelio (angl. Ising model) hamiltonianas apibūdina sistemos, sudarytos iš \\(1/2\\) sukinių, dinamiką. Skersinio lauko Aizingo modelio versija (angl. transverse-field Ising model) turi šią formą: \\[\\begin{equation} H = - j\\sum_{i = 1}^n Z_i\\otimes Z_{i + 1} - g\\sum_{i = 1}^n X_i\\,. \\tag{8.2} \\end{equation}\\] Hamiltonianas apibūdina \\(n\\) kubitų, išrikiuotų eilėje. Nariai pirmoje sumoje nusako magnetines sąveikas tarp vienas šalia kito (\\(i\\), \\(i + 1\\)) esančių kubitų išilgai \\(z\\) ašies, apibūdintas Pauli-\\(Z\\) operatoriais ir sąveikos stiprumu \\(j\\). Pavyzdžiui, vienas toks narys, veikiantis tarp antrojo ir trečiojo kubito 4 kubitų sistemoje būtų \\(-jI\\otimes Z\\otimes Z\\otimes I\\). Antra suma hamiltoniane apibūdina išorinio magnetinio lauko išilgai \\(x\\) ašies efektą kiekvienam iš \\(n\\) kubitų. Pavyzdžiui, veikdamas trečią kubitą 4 kubitų sistemoje jis būtų \\(-gI\\otimes I\\otimes X\\otimes I\\). Nepaisant paprastos išraiškos, bendras kubitų elgesys šiame Aizingo modelyje pasižymi fenomenų gausa. Norėdami apskaičiuoti kubitų evoliuciją laike turime įvertinti unitariojo operatoriaus \\(U = \\mathrm{e}^{\\frac{-\\mathrm{i}Ht}{\\hbar}}\\) veiksmą (žr. 3 skyrių): \\[\\begin{equation} |\\psi(t) \\rangle = \\mathrm{e}^{\\frac{-\\mathrm{i}Ht}{\\hbar}}|\\psi(0)\\rangle = U|\\psi(0)\\rangle\\,. \\tag{8.3} \\end{equation}\\] Čia pradinė būsena \\(|\\psi(0) \\rangle\\) laiku \\(t = 0\\) yra bendrai \\(n\\) kubitų superpozicija. Unitariojo operatoriaus formavimas iš ermitinio operatoriaus, šiuo atveju hamiltoniano \\(H\\), kvantinėje kompiuterijoje vadinamas hamiltoniano kodavimu (angl. hamiltonian encoding). Mat iš bet kokio ermitinio operatoriaus \\(A\\) galime suformuoti unitarųjį operatorių \\(U\\) imdami jo ekponentę \\(\\mathrm{e}^{\\mathrm{i}At}\\), ir šį unitarųjį operatorių realizuoti loginiais vartais. Pavyzdžiui, mašininio mokymosi algoritmuose operatorių realizuojanti matrica \\(A\\) gali nusakyti mokymosi duomenis, o hamiltoniano kodavimas suteikia vieną būdą duomenis pateikti kvantiniam kompiuteriui. 8.1.2 Troterizacija Daugeliu atvejų hamiltonianą \\(H\\) galime išskaidyti suma: \\[\\begin{equation} H = \\sum_{i = 1}^k H_i\\,. \\tag{8.4} \\end{equation}\\] Minėtame Aizingo modelyje hamiltonianas yra sudarytas iš dviejų narių: \\(H_1 = - j\\sum_{i = 1}^n Z_i\\otimes Z_{i + 1}\\) ir \\(H_2 = - g\\sum_{i = 1}^n X_i\\). Atkreipiame dėmesį, kad nors visi nariai \\(H_1\\) ir \\(H_2\\) sumose yra komutatyvūs, tačiau \\(H_1\\) ir \\(H_2\\) yra tarpusavyje nekomutatyvūs, \\(\\lbrack H_1 , H_2\\rbrack \\neq 0\\). Todėl negalime šio unitariojo operatoriaus tiesiogiai pritaikyti nustatydami sistemos evoliuciją laike, nes: \\[\\begin{equation} \\mathrm{e}^{\\frac{-\\mathrm{i}H_1t}{\\hbar}}\\mathrm{e}^{\\frac{-\\mathrm{i}H_2t}{\\hbar}} \\neq \\mathrm{e}^{\\frac{-\\mathrm{i}(H_1 + H_2)t}{\\hbar}}\\,. \\tag{8.5} \\end{equation}\\] Vadinamoji troterizacija (angl. Suzuki-Trotter approximation) leidžia apeiti iškilusią kliūtį ir apytikriai realizuoti norimą operatorių. Ši aproksimacija diskretizuoja laiko intervalą \\(t\\) į \\(s\\) žingsnių, kai kiekvienas laiko intervalas trunka \\(\\Delta t = t/s\\). Unitarusis operatorius tampa: \\[\\begin{equation} U = \\mathrm{e}^{\\frac{-\\mathrm{i}(H_1 + H_2)t}{\\hbar}} \\cong \\left(\\mathrm{e}^{\\frac{-\\mathrm{i}H_1\\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}H_2\\Delta t}{\\hbar}}\\right)^s\\,. \\tag{8.6} \\end{equation}\\] Naudodami pasirinktinai mažą žingsnį \\(\\Delta t\\) ir atlikdami iteraciją \\(s\\) kartų, apskaičiuokime norimą sistemos laiko evoliuciją visame laiko intervale \\(t\\). 8.6 lygybėje parodyta pirmosios eilės aproksimacija, joje įterpiamos klaidos yra ne didesnės nei žingsnio dydžio kvadratas \\(O(\\Delta t^2)\\). Troterizacija taip pat išsaugo laiko evoliucijos operatoriaus unitarumą ir todėl užtikrina, kad visame procese kvantinė būsena išlieka normuota. Galutinė sistemos būsena randama \\(|\\psi(t)\\rangle \\cong |\\psi(s\\Delta t)\\rangle\\): \\[\\begin{equation} |\\psi(s\\Delta t)\\rangle = \\mathrm{e}^{\\frac{-\\mathrm{i}H_1 \\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}H_2 \\Delta t}{\\hbar}}\\cdots \\mathrm{e}^{\\frac{-\\mathrm{i}H_1 \\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}H_2 \\Delta t}{\\hbar}}|\\psi(0)\\rangle\\,. \\tag{8.7} \\end{equation}\\] Troterizacija natūraliai tinka realizuoti ir hamiltonianus, kurie kinta laike. Tai gali nusakyti, pavyzdžiui, periodines sistemos perturbacijas ar simuliuoti atsitiktinai jaučiamas išorines sąveikas. Čia taip pat pasirenkamas diskretizuotas laiko žingsnis \\(\\Delta t\\), pagal kurį laiko evoliucijos operatorius \\(U(t)\\) yra strobuojamas, taip pateikiant efektyvią seką: \\[\\begin{equation} |\\psi(s\\Delta t)\\rangle = U_s(\\Delta t)\\cdots U_2(\\Delta t)U_1(\\Delta t)|\\psi(0)\\rangle\\,. \\tag{8.8} \\end{equation}\\] 8.1.3 Aizingo modelio realizavimas kvantinėje grandinėje Aizingo modelyje matome 1 kubito operatorių, turintį formą: \\(\\mathrm{e}^{\\frac{-\\mathrm{i}H_2 \\Delta t}{\\hbar}} = \\mathrm{e}^{-\\frac{\\mathrm{i}\\theta X}{2}} \\equiv R_{x}(\\theta)\\). Tai yra pažįstamas posūkio operatorius aplink \\(x\\) ašį, čia jis atlieka Blocho vektoriaus posūkį kampu \\(\\theta = - \\frac{2g\\Delta t}{\\hbar}\\) kiekviename iš \\(\\Delta t\\) dydžio iteracijos laiko žingsnių \\(s\\). Taip pat turime realizuoti 2 kubitų loginius vartus, nusakytus operatoriumi \\(\\mathrm{e}^{\\frac{-\\mathrm{i}H_1 t}{\\hbar}} = \\mathrm{e}^{\\mathrm{i}\\theta Z_k\\otimes Z_l}\\). Čia \\(\\theta = \\frac{j\\Delta t}{\\hbar}\\), o \\(Z_k\\otimes Z_l\\) veikia \\(k\\) ir \\(l\\) kubitus kiekviename žingsnyje. Dėl paprastumo praleidžiame identitetus, \\(\\otimes I\\), kurie veikia likusius kubitus. Tam galime panaudoti 2 skyriuje pateiktą tenzorinės operatorių sanudaugos funkcijos išraišką: \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\theta Z_k\\otimes Z_l} = \\sum_{k,l} \\mathrm{e}^{\\mathrm{i}\\theta\\lambda_k\\lambda_l}P_k\\otimes P_l = \\begin{bmatrix} \\mathrm{e}^{\\mathrm{i}\\theta} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\theta} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\theta} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\mathrm{e}^{\\mathrm{i}\\theta} \\end{bmatrix}\\,. \\tag{8.9} \\end{equation}\\] (8.9) lygybės tenzorinėje sandaugoje \\(P_{k,l} \\in \\big(|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\big)\\) yra Pauli-\\(Z\\) projekciniai operatoriai, o tikrinių verčių sandauga yra \\(\\lambda_k\\lambda_l \\in (1, -1)\\). Atkreipiame dėmesį, kad lyginį lyginumą turinčioms 2 kubitų būsenoms (\\(|00\\rangle\\) ir \\(|11\\rangle\\)) yra pritaikoma fazė \\(\\mathrm{e}^{\\mathrm{i}\\theta}\\), o štai nelyginio lyginumo būsenos (\\(|01\\rangle\\) ir \\(|10\\rangle\\)) įgauna \\(\\mathrm{e}^{-\\mathrm{i}\\theta}\\). 8.1 pav. parodyta grandinė, realizuojanti \\(\\mathrm{e}^{\\mathrm{i}\\theta Z_k\\otimes Z_l}\\) operatorių kubitams \\(k_1\\) ir \\(k_2\\) pasitelkiant ancilą \\(a_1\\). 8.1 pav. Loginė grandinė, realizuojanti \\(\\mathrm{e}^{\\mathrm{i}\\theta Z_1\\otimes Z_2}\\) operatorių. Ancila kubitui pritaikomi \\(R_z\\) posūkio loginiai vartai Pirma kvantinės grandinės užduotis yra atskirti būsenų lyginumą. Tam iškviečiami dveji \\(cX\\) vartai, supinantys ancilą kubitą \\(a_1\\) su \\(k_1\\) ir \\(k_2\\) kubitais. Norėdami tai aiškiau pamatyti, imkime, kad \\(k_1\\) ir \\(k_2\\) kubitai yra lygioje 2 kubitų skaičiuojamųjų bazinių vektorių superpozicijoje. Tad bendra pradinė būsena yra \\(|\\psi\\rangle = |k_1 k_2\\rangle\\otimes|a_1\\rangle\\): \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{2}\\big(|00\\rangle + |10\\rangle + |01\\rangle + |11\\rangle\\big)\\otimes|0\\rangle\\,. \\tag{8.10} \\end{equation}\\] Pritaikius pirmus dvejus \\(cX\\) vartus su ancila adresatiniu kubitu, skaičiumi nurodant kontroliuojantį \\(k\\) kubitą, randame: \\[\\begin{equation} cX_{2}cX_{1}|\\psi\\rangle = \\frac{1}{2}\\big(|00\\rangle + |11\\rangle\\big)\\otimes|0\\rangle + \\frac{1}{2}\\big(|10\\rangle + |01\\rangle\\big)\\otimes|1\\rangle\\,. \\tag{8.11} \\end{equation}\\] Matome, kad tai supina ancilos kubito būseną \\(|0\\rangle\\) su lyginio lyginumo \\(k_1\\) ir \\(k_2\\) kubitų būsenomis, o \\(|1\\rangle\\) yra supinama su nelyginėmis. Atskyrę lyginumo būsenas, kitame žingsnyje pritaikome grandinėje parodytus \\(R_z(\\theta) = \\mathrm{e}^{\\mathrm{i}\\theta Z}\\) posūkio aplink \\(z\\) ašį loginius vartus ancila kubitui. Pagal 4 skyriuje apibūdintus posūkio vartus \\(R_z(\\varphi) = \\mathrm{e}^{-\\mathrm{i}\\varphi Z/2}\\), kampas čia yra \\(\\theta = -\\varphi/2\\). Dėl kvantinio supynimo \\(R_z(\\varphi)\\) efektyviai suteikia skirtingas fazes skirtingo lyginumo būsenoms: \\[\\begin{equation} \\begin{aligned} (I\\otimes I\\otimes \\mathrm{e}^{\\mathrm{i}\\theta Z})&amp;cX_2cX_1|\\psi\\rangle \\\\ = &amp;\\frac{1}{2}\\big(|00\\rangle + |11\\rangle\\big) \\otimes\\mathrm{e}^{\\mathrm{i}\\theta}|0\\rangle + \\frac{1}{2}\\big(|10\\rangle + |01\\rangle\\big) \\otimes\\mathrm{e}^{-\\mathrm{i}\\theta}|1\\rangle \\\\ = &amp; \\frac{1}{2}\\big(\\mathrm{e}^{\\mathrm{i}\\theta}|00\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta}|11\\rangle\\big)\\otimes|0\\rangle + \\frac{1}{2}\\big(\\mathrm{e}^{-\\mathrm{i}\\theta}|10\\rangle + \\mathrm{e}^{-\\mathrm{i}\\theta}|01\\rangle\\big)\\otimes|1\\rangle\\,. \\end{aligned} \\tag{8.12} \\end{equation}\\] Ancilos kubito būseną atstatome atgal su dviem \\(cX\\) vartais kartu panaikindami supynimą su \\(k_1\\) ir \\(k_2\\) kubitais. Gauname galutinę 2 kubitų būseną, realizuojamą operatoriumi \\(\\mathrm{e}^{\\frac{-\\mathrm{i}H_1 t}{\\hbar}} = \\mathrm{e}^{\\mathrm{i}\\theta Z_k\\otimes Z_l}\\): \\[\\begin{equation} cX_1cX_2(I\\otimes I\\otimes \\mathrm{e}^{\\mathrm{i}\\theta Z})cX_2cX_1|\\psi\\rangle = \\frac{1}{2}\\big(\\mathrm{e}^{\\mathrm{i}\\theta}|00\\rangle + \\mathrm{e}^{-\\mathrm{i}\\theta}|10\\rangle + \\mathrm{e}^{-\\mathrm{i}\\theta}|01\\rangle + \\mathrm{e}^{\\mathrm{i}\\theta}|11\\rangle)\\otimes|0\\rangle\\,. \\tag{8.13} \\end{equation}\\] Tad turime visus įrankius realizuoti Aizingo modeliui kvantiniame kompiuteryje. 8.2 Erdvinės Šriodingerio lygties sprendimo algoritmas Banginė funkcija (angl. wave function), kaip ir būseną apibūdinantis vektorius \\(|\\psi \\rangle\\), nusako viską, ką galima žinoti apie kvantinę sistemą. Erdvinė banginė funkcija \\(\\psi(x)\\) praktikoje leidžia analizuoti ir aprašyti erdvines kvantinės sistemos savybes, pavyzdžiui, nusakant jos poziciją, judėjimo kryptį ir greitį, kiek tai leidžia Haizenbergo neapibrėžtumo principas. Čia verta įsivaizduoti specifinę sistemą, pavyzdžiui, elektroną. Neprarasdami bendrumo imsime, kad elektronas juda vienoje erdvinėje dimensijoje – tai artimai atspindi keletą realių situacijų, kuriose yra apriboti erdviniai laisvės laipsniai. Norėdami apskaičiuoti, kaip ši sistema kinta laike, turime išspręsti Šriodingerio lygtį. 8.2.1 Banginė funkcija Pirmiausiai perteiksime elektrono kvantinę būseną, išreikštą vektoriumi \\(|\\psi\\rangle\\), į erdvinį jos atvaizdavimą. Tam įvesime erdvinės pozicijos operatorių \\(\\hat{x}\\) ir jo tikrinius vektorius \\(|x\\rangle\\), kurie tenkina lygtį: \\[\\begin{equation} \\hat{x}|x&#39;\\rangle = x&#39;|x&#39;\\rangle\\,. \\tag{8.14} \\end{equation}\\] (8.14) lygybėje \\(\\hat{x}\\) operatorius, veikiantis vieną iš tikrinių vektorių \\(|x&#39;\\rangle\\), grąžina jo sandaugą su tikrine verte \\(x&#39;\\). Tikriniai vektoriai \\(|x&#39;\\rangle\\) priskiriami kiekvienai erdvės pozicijai \\(x&#39;\\) ir kadangi yra tolydūs, jų iš principo yra begalybė. Formaliai šios būsenos yra apibūdinamos pasitelkiant vadinamąją suklastotą Hilberto erdvę (angl. rigged Hilbert space). Skirtingų pozicijos tikrinių vektorių ortonormalumas išreiškiamas Dirako delta funkcija (angl. Dirac delta function), \\(\\langle x|x&#39;\\rangle = \\delta(x - x&#39;)\\). Kvantinės sistemos būsena \\(|\\psi\\rangle\\), išreikšta erdviniais baziniais vektoriais \\(\\{|x\\rangle\\}\\) ir pasitelkiant pilnumo savybę (2 skyrius), atrodo taip: \\[\\begin{equation} |\\psi\\rangle = \\int_{-\\infty}^{\\infty} |x\\rangle\\langle x|\\psi\\rangle\\,dx = \\int_{-\\infty}^{\\infty}\\psi(x)|x\\rangle\\,dx\\,. \\tag{8.15} \\end{equation}\\] Pilnumo savybėje naudojame integralą, o ne sumą, kadangi \\(x\\) kinta tolydžiai. Integrale matome \\(\\psi(x)|x\\rangle\\) narius, kuriuose pozicijos vektoriaus \\(|x\\rangle\\) kompleksinė amplitudė yra nusakoma \\(\\psi(x) = \\langle x|\\psi\\rangle\\). Kvantinių būsenų pozicijos atvaizdavime amplitudžių \\(\\psi(x)\\) visuma yra vadinama bangine funkcija. Laike besikeičiančios kvantinės sistemos banginė funkcija yra pasklidusi erdvėje, ir tai formaliai nusako jos pozicijos būsenų superpoziciją. Banginę funkciją galima apriboti išoriniais veiksniais, pavyzdžiui, elektroną – elektrinio lauko barjeru. Todėl tik tam tikrame erdvės intervale ji turės nenulines vertes, \\(\\psi(x) \\neq 0\\). Elektroną taip pat galima lokalizuoti atlikus jo pozicijos matavimą. Matuojant elektronas yra lokalizuojamas erdvės intervale, nusakytame matavimo įrenginio savybėmis, pavyzdžiui, jo erdvine skiriamąja geba. Tikimybę rasti dalelę nykstamai mažo \\(dx\\) dydžio erdvės intervale nusako banginės funkcijos \\(\\psi(x)\\) modulio kvadrato šioje pozicijoje ir intervalo \\(dx\\) sandauga: \\[\\begin{equation} |\\langle x|\\psi\\rangle |^2 dx = \\psi^{*}(x)\\psi(x)dx = |\\psi(x)|^2 dx\\,. \\tag{8.16} \\end{equation}\\] Susumavę (integravę) tokius narius visoje erdvėje reikalaujame, kad tikimybė \\(p\\) susidėtų į 1, mat elektronas turi būti vis tiek rastas kažkur erdvėje: \\[\\begin{equation} \\int_{-\\infty}^{\\infty}|\\psi(x)|^2\\,dx = 1\\,. \\tag{8.17} \\end{equation}\\] Praktiniuose taikymuose, banginė kvantinės sistemos funkcija \\(\\psi(x)\\) yra išplitusi tik tam tikroje erdvės dalyje ir nesitęsia iki begalybės. Todėl integraciją pakanka atlikti tik toje erdvės dalyje, kur \\(\\psi(x)\\) turi apčiuopiamo dydžio vertes. 8.2.2 Diskretizavimas Norėdami kvantiniu kompiuteriu spręsti Šriodingerio lygtį erdvinėje išraiškoje, pirmiausiai atliksime erdvinių laisvės laipsnių diskretizavimą. Sakykime, kad mus domina \\(L\\) dydžio erdvės intervalas \\(- L/2 \\leq x \\leq \\ L/2\\). Šį intervalą diskretizuosime \\(2^n\\) skaičiumi taškų su lygiais \\(\\Delta x = L/2^n\\) dydžio intervalais. Tai reiškia, kad tik šiuose \\(2^n\\) erdvės taškuose bus įvertintos banginės funkcijos \\(\\psi(x)\\) reikšmės. Tokią diskretizacijos taškų visumą vadinsime gardele (angl. lattice). Kiekvienas gardelės taškas yra indeksuojamas vienu iš \\(n\\) kubitų skaičiuojamųjų bazinių vektorių \\(|x\\rangle\\). Norint išvengti \\(x\\) simbolių dubliavimo su erdviniais simboliais, dešimtainėje sistemoje naudojamus \\(x\\) simbolius pakeisime į \\(v\\). Jeigu registras yra sudarytas iš \\(n\\) kubitų, tada turime \\(2^n\\) diskretizacijos taškus, nusakytus \\(2^n\\) baziniais vektoriais \\(\\{|v\\rangle\\}\\). Pavyzdžiui, 3 kubitų registras leidžia sukurti 8 taškų gardelę {\\(|0\\rangle\\), \\(|1\\rangle\\), \\(|2\\rangle\\), \\(|3\\rangle\\), \\(|4\\rangle\\), \\(|5\\rangle\\), \\(|6\\rangle\\), \\(|7\\rangle\\)}. Čia natūraliai pasitelkiame amplitudžių kodavimo metodą, kadangi banginė funkcija, kurios kitimą apskaičiuosime, yra bazinių vektorių {\\(|v\\rangle\\)} amplitudės. Atkreipiame dėmesį, kad dėl eksponentinio būsenų augimo \\(d\\) skaičiui taškų tereikia \\(\\log_2 (d)\\) kubitų – tai yra itin efektyvus diskretizacijos būdas. Kvantinėms sistemoms yra papildomas privalumas, kadangi kiekviename gardelės taške kubito būsenos amplitudė yra natūraliai koduojama kompleksiniu skaičiumi. Kiekvieną (diskretizuotą) poziciją \\(x\\) unikaliai susiejame su baziniais vektoriais \\(|v\\rangle\\) ir pervadindami ją \\(x_v\\) turime: \\[\\begin{equation} x_v = -\\frac{L}{2} + v\\Delta x\\,. \\tag{8.18} \\end{equation}\\] Diskretizuotąją kvantinę būseną \\(|\\psi\\rangle\\) šioje erdvėje išreiškiame taip: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{\\sqrt{N}}\\sum_{v = 0}^{2^n - 1}\\psi(x_v)|v\\rangle\\,. \\tag{8.19} \\end{equation}\\] Būsena \\(|\\psi\\rangle\\) yra normuojama \\(L\\)-dydžio intervale faktoriumi \\(\\sqrt{N}\\): \\[\\begin{equation} N = \\sum_{v = 0}^{2^n - 1} |\\psi(x_v)|^2 \\Delta x\\,. \\tag{8.20} \\end{equation}\\] Siekdami supaprastinti simboliką, laikinai praleisime pozicijos \\(x\\) indeksaciją \\(v\\) simboliais. Tolesniame žingsnyje perteikiame Šriodingerio lygtimi apibūdinamą sistemos dinamiką į matematinę formą, kuri yra tinkama diskretizacijai. Naudojant \\(\\psi(x,t) = \\langle x|\\psi(t)\\rangle\\): \\[\\begin{equation} \\mathrm{i}\\hbar\\frac{d\\psi(x,t)}{dt} = H\\psi(x,t)\\,. \\tag{8.21} \\end{equation}\\] Ši lygtis nusako \\(\\psi(x,t)\\) banginės funkcijos (amplitudžių) kitimą erdvėje ir laike. Hamiltonianas bendrai susideda iš kinetinės energijos (angl. kinetic energy) ir potencinės energijos (angl. potential energy) operatorių: \\[\\begin{equation} H = -\\frac{\\hbar^2}{2m} \\frac{d^2}{dx^2} + V(x) \\equiv K + V\\,. \\tag{8.22} \\end{equation}\\] Čia \\(d^2/dx^2\\) atlieka banginės funkcijos antros eilės išvestinę, \\(m\\) yra kvantinės sistemos masė. Potencinės energijos funkcija \\(V\\) nusako sąveikas su išorinėmis sistemomis. Imsime, kad \\(V(x)\\) priklauso tik nuo erdvinės pozicijos \\(x\\) ir nekinta laike. Pradinės banginės funkcijos \\(\\psi(x,0)\\) evoliucija po laiko intervalo \\(t\\) randama: \\[\\begin{equation} \\psi(x,t) = \\mathrm{e}^{\\frac{-\\mathrm{i}(K + V)t}{\\hbar}}\\psi(x,0)\\,. \\tag{8.23} \\end{equation}\\] Atkreipiame dėmesį, kad \\(\\mathrm{e}^{\\frac{-\\mathrm{i}(K + V)t}{\\hbar}} \\neq \\mathrm{e}^{\\frac{-\\mathrm{i}Kt}{\\hbar}}\\mathrm{e}^{\\frac{-\\mathrm{i}Vt}{\\hbar}}\\). Šie išskaidyti unitarieji operatoriai bendroje situacijoje yra nekomutatyvūs. Tam vėl pasitelksime troterizaciją diskretizuodami laiko intervalą \\(t\\) į \\(s\\) skaičių žingsnių: \\[\\begin{align} \\mathrm{e}^{\\frac{-\\mathrm{i}(K + V)t}{\\hbar}} \\cong &amp; \\left(\\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}V\\Delta t}{\\hbar}}\\right)^s\\,;\\tag{8.24}\\\\ \\psi(x,t) = &amp; \\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}V\\Delta t}{\\hbar}}\\cdots \\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}} \\mathrm{e}^{\\frac{-\\mathrm{i}V\\Delta t}{\\hbar}}\\psi(x,0)\\,.\\tag{8.25} \\end{align}\\] Šioje stadijoje diskretizavome erdvės ir laiko kintamuosius, taip pat perteikėme banginę funkciją gardelėje. Toliau parodysime, kaip apskaičiuoti troterizuoto laiko evoliucijos operatoriaus efektą banginei funkcijai. Potencinės energijos \\(V\\) operatoriaus eksponentė \\(\\mathrm{e}^{\\frac{-\\mathrm{i}V(x)\\Delta t}{\\hbar}}\\), laiko žingsnyje \\(\\Delta t\\) daugindama banginę funkciją \\(\\psi(x,t)\\), suteikia jai kiekvienoje diskretizuotos erdvės pozicijoje \\(x_v\\) fazę \\(\\theta_v = \\frac{V(x_v)\\Delta t}{\\hbar}\\). Kadangi naudojame \\(2^n\\) erdvės diskretizacijos taškų, nusakytų kubitų baziniais vektoriais, šį operatorių galime išreikšti \\((2^n \\times 2^n)\\) dydžio diagonaliąja matrica: \\[\\begin{equation} \\mathrm{e}^{\\frac{-\\mathrm{i}V(x)\\Delta t}{\\hbar}} = \\begin{bmatrix} \\mathrm{e}^{-\\mathrm{i}\\theta_0} &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 \\\\ 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\theta_1} &amp; \\cdots &amp; 0 &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; \\mathrm{e}^{-\\mathrm{i}\\theta_{2^n - 2}} &amp; 0 \\\\ 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; \\mathrm{e}^{-\\mathrm{i}\\theta_{2^n - 1}} \\end{bmatrix}\\,. \\tag{8.26} \\end{equation}\\] Kinetinės energijos operatoriaus eksponentės \\(\\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}}\\) efektas banginei funkcijai lengviausiai apskaičiuojamas banginės funkcijos judesio kiekio atvaizdavime (angl. momentum space representation). Pritaikius pozicijos \\(x\\) ir judesio kiekio \\(p\\) konjuguojamumą (angl. conjugation), banginės funkcijos Furjė transformacija konvertuoja ją tarp šių atvaizdavimų: \\[\\begin{align} U_{\\mathrm{FT}}\\psi(x) = &amp; \\psi(p)\\,;\\tag{8.27}\\\\ \\psi(p) = &amp; \\frac{1}{\\sqrt{2^n}}\\sum_{x = 0}^{2^n - 1} \\psi(x) \\mathrm{e}^{\\mathrm{i}2\\pi xp/2^n}\\,.\\tag{8.28} \\end{align}\\] Jeigu \\(\\psi(x)\\) yra normuotoji, tada ir \\(\\psi(p)\\) bus normuotoji dėl \\(U_{\\mathrm{FT}}\\) unitarumo. Judesio kiekio operatorius pozicijos atvaizdavime yra \\(p = -\\frac{\\hbar}{\\mathrm{i}} \\frac{d}{dx}\\), tad judesio kiekio atvaizdavime kinetinė energija yra tiesiog \\(K = \\frac{p^2}{2m}\\). Iš to išplaukia unitarinis operatorius \\(\\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}} = \\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}}\\), kuris veikia \\(\\psi(p)\\) banginę funkciją: \\[\\begin{equation} \\mathrm{e}^{\\frac{-\\mathrm{i}K\\Delta t}{\\hbar}}\\psi(x) = U_{\\mathrm{FT}}^{\\dagger}\\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}}U_{\\mathrm{FT}}\\psi(x)\\,. \\tag{8.29} \\end{equation}\\] Atvirkštinė Furjė transformacija \\(U_{\\mathrm{FT}}^{\\dagger}\\) grąžina banginę funkciją \\(\\psi(p)\\) atgal į pozicijos atvaizdavimą \\(\\psi(x)\\). Kinetinės energijos operatorius yra \\((2^n \\times 2^n)\\) dydžio diagonalioji matrica šiame atvaizdavime. Jo efektas banginei funkcijai apskaičiuojamas analogiškai, kaip ir potencinės energijos, tačiau suteikiant fazę \\(\\theta_j = \\frac{p_j^2\\Delta t}{2m\\hbar}\\) kiekviename judesio kiekio diskretizacijos taške \\(j\\) ir turi kvadratinę \\(p_j^2\\) priklausomybę. Realizuojant šią dalį, judesio kiekio banginę funkciją \\(\\psi(p) = \\langle p|\\psi\\rangle\\) išreiškiame gardelėje. Jis sudarytas iš tų pačių \\(2^n\\) skaičiuojamųjų bazinių vektorių, gardelės taškus indeksuojame su \\(|j\\rangle\\): \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{\\sqrt{N}}\\sum_{j = 0}^{2^n - 1}\\psi(p_j)|j\\rangle\\,. \\tag{8.30} \\end{equation}\\] Normavimo faktorius vardiklyje \\(N\\) išlieka nepakitęs: \\[\\begin{equation} N = \\sum_{v = 0}^{2^n - 1}|\\psi(x_v)|^2 \\Delta x = \\sum_{j = 0}^{2^n - 1}|\\psi(p_j)|^2 \\Delta p\\,. \\tag{8.31} \\end{equation}\\] Nustatę erdvinį intervalo dydį ir erdvinį atstumą tarp \\(2^n\\) taškų, galime tiesiogiai susieti juos su judesio kiekio gardele (arba atvirkščiai). Judesio kiekis bus apibrėžtas \\(-\\pi/\\Delta x \\leq p \\leq \\pi/\\Delta x\\) ir turės \\(\\Delta p = 2\\pi/L\\) dydžio intervalus. Judesio kiekio koordinatė \\(p_j\\) gardelėje yra: \\[\\begin{equation} p_j = - \\pi/\\Delta x + j\\Delta p\\,. \\tag{8.32} \\end{equation}\\] Judesio kiekio gardelė yra paprastai centruojama apie \\(p_j = 0\\). Sudėję viską kartu, banginės funkcijos \\(\\psi(x,t)\\) evoliuciją laike iki \\(t = s\\Delta t\\) randame iteraciniu algoritmu: \\[\\begin{equation} \\psi(x,t) = U_{\\mathrm{FT}}^{\\dagger} \\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}} U_{\\mathrm{FT}}\\mathrm{e}^{\\frac{-\\mathrm{i}V(x)\\Delta t}{\\hbar}} \\cdots U_{\\mathrm{FT}}^{\\dagger}\\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}} U_{\\mathrm{FT}}\\mathrm{e}^{\\frac{-\\mathrm{i}V(x)\\Delta t}{\\hbar}}\\psi(x,0)\\,. \\tag{8.33} \\end{equation}\\] Erdvinės funkcijos diskretizacijos gardelė pasirenkama didesnė negu banginės funkcijos išsiplėtimas skaičiavimo metu, nes Furjė transformacija automatiškai padaro gardelę periodinę. Mat, jeigu banginė funkcija plėsdamasi pasieks gardelės kraštą, ji vėl atsiras priešingame krašte ir plėsis į gardelės vidų, o ten gali įvesti klaidingas amplitudes ir padaryti banginę funkciją nebenormuotą. Erdvinio ir judesio kiekio gardelės žingsnių dydžiai parenkami norint pasiekti reikalaujamą erdvinę skiriamąją gebą ir atkurti norimus didžiausius sistemoje atsirandančius judesio kiekius, atitinkamai. 8.2.3 Perteikimas kvantinėje grandinėje Toliau pažiūrėkime, kaip kvantinėje grandinėje realizuoti \\(\\mathrm{e}^{\\frac{-\\mathrm{i}V(x)\\Delta t}{\\hbar}}\\) ir \\(\\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}}\\) narius. Specifinė fizinė situacija diktuos, kokia yra potencinės energijos funkcijos \\(V(x)\\) erdvinė priklausomybė. Kaip paprastą pavyzdį imkime 3 kubitų gardelės diskretizaciją ir potencinės energijos \\(V(x)\\) funkciją, kuri nusako \\(a\\) dydžio barjerus (energijos vienetai) kairiajame ir dešiniajame krašte (\\(x = 0\\) ir \\(x = 7\\)), taip pat \\(b\\) dydžio barjerą \\(x = 3\\) pozicijoje: \\[\\begin{equation} V(x) = \\begin{cases} a\\,, &amp; x = 0\\,\\mathrm{ir}\\,7 \\\\ b\\,, &amp; x = 3 \\\\ 0\\,, &amp; \\mathrm{likusiems}\\,x \\end{cases}\\,. \\tag{8.34} \\end{equation}\\] Kvantinė grandinė, perteikianti \\(\\theta = \\frac{V(x)\\Delta t}{\\hbar}\\) fazes \\(\\{|0\\rangle , |3\\rangle , |7\\rangle\\}\\) būsenoms, parodyta 8.2 pav. 8.2 pav. Loginė grandinė, atliekanti potencinės energijos funkcijos \\(V(x)\\) su trimis barjerais veiksmą banginei funkcijai \\(\\psi(x)\\) viename laiko intervale Matome dvigubai kontroliuojamus 3 kubitų fazės \\(ccP(\\theta)\\) loginius vartus, kuriuose „kontrolinės” yra 1 kubito būsenos \\(|0\\rangle\\) (tušti apskritimai) arba \\(|1\\rangle\\) (užpildyti apskritimai). Šiuos aukštesnio lygio abstrakcijos loginius vartus, selektyviai suteikiančius fazę pasirinktai būsenai, galima realizuoti 4 skyriuje parodytu Tofoli vartais pagrįstu metodu (žr. 4.7 poskyrį). Šitoks metodas yra bendro pobūdžio, tačiau geriausiai tinka paprastoms potencinės energijos funkcijoms. Mat visoms skirtingoms \\(2^n\\) būsenoms selektyviai parinkti reikėtų daug išteklių: papildomų \\(n - 1\\) ancila kubitų; pritaikyti fazę vienam gardelės taškui reikalaujama \\(2(n - 1)\\) Tofoli loginių vartų, o taškų skaičius yra eksponentinis \\(2^n\\). Potencinės energijos funkcijos, pasižyminčios simetrijomis, gali būti efektyviau išreikštos loginiais vartais. Vienas pavyzdys yra harmoninio osciliatoriaus funkcija \\(V(x) = \\gamma x^2\\) (\\(\\gamma\\) – realusis skaičius), turinti veidrodinę simetriją apie \\(x = 0\\). Unitarinį operatorių \\(\\mathrm{e}^{\\frac{-\\mathrm{i}\\gamma x^2\\Delta t}{\\hbar}}\\), veikiantį \\(n\\) kubitų registrą, galima realizuoti naudojant tik \\(O(n^2)\\) kompleksiškumą nulemiančių 2 kubitų loginių vartų. Kadangi kinetinės energijos unitarusis operatorius \\(\\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}}\\) taip pat turi identišką kvadratinę išraišką, pažiūrėsime jo perteikimą loginiais vartais: \\[\\begin{equation} \\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}} = \\mathrm{e}^{\\frac{\\mathrm{i}\\theta}{2^{2n - 3}}{ \\left(1 + \\sum_{k = 1}^n 2^{n - k} Z_k\\right)}^2}\\,. \\tag{8.35} \\end{equation}\\] Čia \\(\\theta\\) nusako efektinę fazę, suteikiamą kiekviename laiko žingsnyje \\(\\Delta t\\), \\(Z_k\\) yra Pauli-\\(Z\\) loginiai vartai, veikiantys \\(k\\) kubitą. Suma atliekama iki algoritme naudojamų \\(n\\) kubitų skaičiaus. Norėdami tai iliustruoti, pateikiame 3 kubitų registro pavyzdį: \\[\\begin{equation} \\mathrm{e}^{\\frac{-\\mathrm{i}p^2\\Delta t}{2m\\hbar}} = \\mathrm{e}^{\\mathrm{i}\\theta\\left(Z_1 + \\frac{1}{2}Z_2 + \\frac{1}{4}Z_3 + 2Z_1\\otimes Z_2 + Z_1\\otimes Z_3 + \\frac{1}{2}Z_2\\otimes Z_3\\right)}\\,. \\tag{8.36} \\end{equation}\\] Jau žinome, kaip kvantinėje grandinėje loginiais vartais perteikti visus čia matomus narius. Šriodingerio lygties sprendime turime paruošti pradinę banginę funkciją \\(\\psi(x,0)\\). Pageidautina, kad šis žingsnis nereikalautų itin didelio loginių operacijų skaičiaus. Banginės funkcijos, pasižyminčios simetrijomis, įprastai gali būti efektyviai koduojamos. Pavyzdžiui, dažnai Gauso funkcija (angl. Gaussian function) yra išreiškiama polinominiu skaičiumi loginių vartų \\(O(\\mathrm{pol}(n+1/\\Delta))\\); čia \\(\\Delta\\) nusako erdvinę skiriamąją gebą. Diskretizuota Gauso funkcija \\(\\psi(x_v)\\), koduojama 4 kubitų registro 16-oje jų amplitudžių, yra pateikta 8.3 pav. Kitas galimas būdas – pasitelkti banginės funkcijos transformaciją iš efektyviai koduojamos funkcijos. Pavyzdžiui, gan komplikuotą Beselio \\(J_0\\) (angl. \\(0^{\\mathrm{th}}\\)-order Bessel function of the \\(1^{\\mathrm{st}}\\) kind) funkciją galima sukurti atliekant Furjė transformaciją funkcijai, kurios forma turi lygias amplitudes tam tikru spinduliu ir yra nulinė visur kitur. Ši Beselio funkcija dažnai aptinkama ir praktikoje, nes ji nusako apvalios apertūros sukurtą tolimojo lauko difrakcijos funkciją. 8.3 pav. Gauso formos diskretizuota banginė funkcija, perteikta 16-os taškų gardelėje Erdvinės Šriodingerio lygties algoritmo pabaigoje turime banginę funkciją \\(\\psi(x,t)\\) arba, ekvivalentiškai, jos judesio kiekio atvaizdavimą \\(\\psi(p,t)\\). Kadangi taikome amplitudžių kodavimo metodą perteikti banginei funkcijai, tiesiogiai visos banginės funkcijos vienu matavimu sužinoti neįmanoma. Pavyzdžiui, galime pasirinkti atlikti kiekvieno kubito standartinį Pauli-\\(Z\\) matavimą, formaliai toks \\(n\\) kubitų matavimas nusakomas apskaičiuojant \\(\\langle\\psi |Z^{\\otimes n}|\\psi\\rangle\\). Dešimtainėje sistemoje rasime vieną iš galimų pozicijos būsenų \\(|x&#39;\\rangle\\) su tikimybe \\(p(x&#39;) = \\psi^{*}(x&#39;)\\psi(x&#39;)dx = |\\psi(x)|^2 dx\\). Pakartoję algoritmą daug kartų ir atlikę tokį matavimą, apytikriai rasime visą tikimybių tankio funkciją \\(|\\psi(x)|^2\\) (angl. probability density function), kuri nusako tikimybes rasti kvantinę sistemą kiekviename erdvės taške \\(x\\). Vietoj šio matavimo galima apskaičiuoti globalius banginės funkcijos parametrus, \\(\\langle\\psi |M|\\psi\\rangle\\); čia \\(M\\) yra kvantinis operatorius. Pavyzdžiui, \\(M\\) gali būti hamiltonianas arba judesio kiekio momento operatorius. Tai suteiks sistemos, esančios būsenoje \\(\\psi(x),\\) vidutinę energiją bei judesio kiekio momentą, atitinkamai. Globalių parametrų nustatymui gali pakakti kartoti algoritmą vos keletą kartų. 8.3 Mašininis mokymasis Mašininis mokymasis (angl. machine learning, ML) yra tyrimų sritis, kurianti metodus, įgalinančius vis geriau atlikti nurodytas užduotis panaudojant duomenis. Mašininio mokymosi algoritmai, remiantis duomenų pavyzdžiais, sukuria prognozę atliekantį ar sprendimus priimantį modelį, tų užduočių neprogramuojant. Mašininis mokymasis yra plačiai taikomas įvairiose srityse, įskaitant kalbos atpažinimą, kompiuterinę regą, mašininį vertimą. 8.3.1 Klasikinis mašininis mokymasis Klasikinio mašininio mokymosi metodai gali būti sugrupuoti į tris sritis: prižiūrimasis mokymasis (angl. supervised learning), neprižiūrimasis mokymasis (angl. unsupervised learning) ir skatinamasis mokymasis (angl. reinforcement learning). Iš visų mašininio mokymosi metodų prižiūrimojo mokymosi algoritmai yra labiausiai ištobulinti ir dažniausiai taikomi praktikoje. Tačiau prižiūrimasis mokymasis turi tą trūkumą, kad jam reikia sužymėtų duomenų, kuriuos gali būti brangu ar sunku gauti. Kai kurie dažniausiai taikomi mašininio mokymosi metodai pavaizduoti 8.4 pav. 8.4 pav. Klasikinio mašininio mokymosi metodai Prižiūrimojo mokymosi atveju modelio kūrimui panaudojami duomenys, kuriuose kiekvienas pavyzdys yra pateikiamas kartu su norima išvestimi. Optimizuojant tikslo funkciją, kuri nusako, kiek modelio išvestis yra arti norimos, prižiūrimojo mokymosi algoritmas išmoksta prognozuoti išvestį, susijusią su nauja įvestimi. Yra sukurta daug prižiūrimojo mokymosi algoritmų, kai kuriuos jų paminėsime toliau. Sprendimų medis (angl. decision tree) ir su juo susijęs atsitiktinis miškas (angl. random forest) yra modelis, pagrįstas srauto diagramomis, kuriose kiekvienas mazgas atitinka duomenų atributo testą, o šakos vaizduoja testo rezultatus. Sprendimų medžių parametrai yra norimas medžio gylis ir mazgų skaičius. Šis modelis nereikalauja išankstinių žinių apie duomenis ir yra atsparus labai nukrypusiems duomenų įrašams ar triukšmui žymėse. Atraminių vektorių mašinos (angl. support vector machines, SVM) naudoja treniravimo duomenis surasti hiperplokštumai, kuri atskiria dvi duomenų klases taip, kad atstumas iki kraštinių skirtingų klasių duomenis vaizduojančių taškų būtų kuo didesnis. Šie taškai yra vadinami atraminiais vektoriais ir nusako galutinį modelį. Kai gera atskyrimo plokštuma negali būti rasta, dažniausiai yra pritaikomi branduolio metodai, projektuojantys duomenis į aukštesnės dimensijos erdvę, kur skirtingos duomenų klasės tampa tiesiškai atskiriamos. Tinkamas branduolio parametrų parinkimas yra svarbus geram modelio veikimui; šių parametrų paieška apsunkina metodo pritaikymą. Atraminių vektorių mašinos pasižymi didele sparta, kai duomenų nedaug, tačiau skaičiavimo ir atminties išteklių poreikis sparčiai auga didėjant duomenų apimčiai. Dabartiniu metu plačiai taikomas dirbtinis neuroninis tinklas yra modelis, sudarytas iš tarpusvyje sujungtų mazgų, vadinamų neuronais. Kiekvienas neuronas susumuoja informaciją iš kitų neuronų ir duoda išvestį, priklausomą nuo neurono netiesinės aktyvacijos funkcijos. Ryšių tarp skirtingų neuronų stiprumą nusako adaptyvūs svoriai. Neuroninio tinklo mokymo metu tinklo svoriai yra keičiami tol, kol tinklo išvestis pasidaro beveik lygi norimai. Pagal neuronų sujungimo pobūdį, dar vadinamą tinklo architektūra, neuroniniai tinklai skirstomi į tipus. Konvoliucinis neuroninis tinklas (angl. convolutional neural network, CNN) naudoja konvoliucijos operacijas su filtrų rinkiniu, užuot pilnai sujungus neuronų sluoksnius. Tokie neuroniniai tinklai naudojami erdviniams duomenims apdoroti, nes konvoliucijos operacijos išlaiko invariantiškumą duomenų erdvinio poslinkio atžvilgiu. Kitas neuroninių tinklų tipas yra rekurentiniai neuroniniai tinklai (angl. reccurent neural network), skirti nuosekliems duomenims apdoroti. Rekurentiniai neuroniniai tinklai naudoja grįžtamąsias jungtis tarp neuronų sluoksnio ir prieš jį einančių sluoksnių. Mokant paprastos architektūros rekurentinius neuroninius tinklus iškyla gęstančių ar sprogstančių gradientų problemos, kurios apsunkina mokymą. Tam išvengti yra pasiūlytas specialus rekurentinių tinklų tipas LSTM (angl. long short-term memory), kuris į modelį įveda sklendžių rinkinį. Taigi sujungimas tarp skirtingų neuronų sluoksnių, jungčių svorių atnaujinimo procesas bei taikomos aktyvacijos funkcijos yra svarbiausi neuroninio tinklo parametrai. Neuroniniai tinklai pasižymi daugeliu lokalių minimumų, todėl gali pateikti klaidingus rezultatus įvedant kitokius duomenis negu treniravimo metu. Neprižiūrimojo mokymosi atveju yra pateikiami nesužymėti duomenys. Kuriamo modelio tikslas – aptikti struktūrą duomenyse, pavyzdžiui, juos sugrupuoti. Dažniausi neprižiūrimojo mokymosi pritaikymai yra duomenų klasterizavimas, matmenų sumažinimas bei anomalijų aptikimas. Klasterizavimo tikslas – sugrupuoti duomenis. Tarp populiariausių klasterizavimo metodų yra k vidurkių klasterizacija (angl. k-means clustering) ir save organizuojantys žemėlapiai (angl. self-organizing maps, SOM). K vidurkių klasterizavimo metu duomenys dalijami į klasterius taip, kad kiekvienas duomenų taškas priklauso klasteriui su artimiausiu taškų vidurkiu, klasterio viduje taškų dispersija minimizuojama. Klasteriams surasti dažniausiai naudojamas iteratyvusis algoritmas: sukuriama k klasterių, kiekvienas taškas susiejamas su artimiausiu vidurkiu, tada kiekvieno iš naujų k klasterių centrai tampa naujais vidurkiais. Saveorganizuojančių žemėlapių metodu duomenys yra pateikiami neuroniniam tinklui, o jis sukuria duomenų erdvės mažos dimensijos vaizdą. Matmenų sumažinimo metodai iš didelės dimensijos duomenų sukuria mažos dimensijos modelius. Pavyzdžiui, pagrindinių komponentų analizė (angl. principal component analysis, PCA) sukuria naujas duomenų požymių kombinacijas. Kombinacijos, turinčios didžiausią dispersiją, yra paliekamos, o visos kitos pašalinamos, taip sumažinant dimensiją. Skatinamojo mokymosi tikslas – programiniam agentui, esančiam nurodytoje aplinkoje, išmokti pasirinkti veiksmus, maksimizuojančius gautą atlygį. Skatinamojo mokymosi modelis yra sudarytas iš aplinkos būsenų, galimų agento veiksmų, perėjimų tarp aplinkos būsenų taisyklių, atlygių už perėjimus tarp būsenų ir stebėjimo taisyklių. Agentas sąveikauja su aplinka pasirinkdamas veiksmus. Aplinka keičiasi atsakydama į tuos veiksmus, ir agentas gauna skaitinį atlygį. Skatinamajame mokyme agentas siekia maksimizuoti atlygį bėgant laikui. Mokymasis gali būti sukoncentruotas viename agente, arba paskirstytas keliuose. Skatinamasis mokymasis yra naudingas kontrolės uždaviniuose, kai negalima pateikti išreikštų taisyklių, o žinoma tik atlygio funkcija. Yra daug skatinamojo mokymosi algoritmų. Vienas iš populiarių metodų yra Q mokymasis. Jame algoritmas skaičiuoja tikėtiną atlygį (Q) veiksmo, atlikto esant nurodytai aplinkos būsenai, nepriklausomai nuo taikomos veiksmų strategijos. Kitas veiksmas yra pasirenkamas remiantis Q verte. Gautas atlygis yra naudojamas Q atnaujinimui imant senos vertės bei naujos informacijos pasvertą vidurkį. 8.3.2 Kvantinis mašininis mokymasis Kvantinis mašininis mokymasis panaudoja kvantinį įrenginį mašininio mokymosi uždaviniams išspręsti su didesniu greičiu ar didesniu tikslumu, negu leidžia klasikiniai mašininio mokymosi metodai. Yra pasiūlyta įvairių klasikinio mašininio mokymosi kvantinių analogų, kurie paspartina klasterizavimą ar atraminių vektorių mašinas. Galimas dar platesnis apibrėžimas, kai kvantinio mašininio mokymosi algoritmai naudoja kvantinį įrenginį klasifikuoti kvantinėms būsenoms, o ne klasikiniams duomenims. Pavyzdžiui, kvantinė pagrindinių komponentų analizė suranda tikrinius vektorius, atitinkančius didžiausias tikrines vertes. Nemažai mašininio mokymosi algoritmų taiko tiesinių lygčių sistemų sprendimą. Kadangi kvantinis HHL algoritmas potencialiai gali greičiau išspręsti tiesinių lygčių sistemą negu klasikiniai algoritmai, kvantinis kompiuteris gali būti panaudojamas mašininiam mokymuisi spartinti. HHL algoritmą naudoja kvantinis k vidurkių metodas bei kvantinės atraminių vektorių mašinos. Klasikiniai neuroniniai tinklai turi netiesines aktyvacijos funkcijas, o štai kvantinių sistemų evoliucija, kaip žinome, yra aprašoma tiesinėmis lygtimis. Kyla klausimas, kaip padaryti kvantinį klasikinio neuroninio tinklo analogą? Vienas iš sprendimo būdų – naudoti hibridinius (iš dalies kvantinius, iš dalies klasikinius) algoritmus. Juose netiesiškumą į evoliuciją įveda kvantinės sistemos matavimas ir su juo susijęs būsenos vektoriaus kolapsas. Nemažai kvantinio mašininio mokymosi metodų naudoja hibridinius algoritmus: parametrizuotos kvantinės grandinės yra treniruojamos taikant klasikinius optimizavimo metodus. Tačiau čia iškyla problema: inicializuojant parametrus visiškai atsitiktinai, dėl eksponentiškai didelės būsenų erdvės gradientas parametrų atžvilgiu dažniausiai yra eksponentiškai mažas didėjant kubitų skaičiui. Šis reiškinys, pavadintas nederlingų plynaukščių (angl. barren plateaus) buvimu, apsunkina kvantinių grandinių treniravimą. Toks nykstamai mažų gradientų buvimas taip pat gali atsirasti dėl triukšmo ar dėl per didelio supynimo tarp kubitų kvantinėje grandinėje. Kvantinis supynimas informaciją patalpina nelokaliai, koreliacijose tarp kubitų. Matuojant tik išvesties kubitus, dalis informacijos prarandama. Visais atvejais, kai kvantinio mašininio mokymosi algoritmas apdoroja klasikinius duomenis, iš pradžių reikia duomenis užkoduoti į kvantinę būseną. Dažniausiai taikomi kodavimo būdai yra bitų kodavimas ir amplitudžių kodavimas (žr. 6.4 poskyrį). Bitų kodavime \\(l\\)-tasis įrašas yra \\(N\\) bitų seka \\(b^{(l)} = \\{b_1 , b_2, \\ldots , b_{N} \\}\\), \\(b_i \\in \\{ 0, 1\\}\\). Operatorius \\(O\\), dar vadinamas kvantiniu orakulu arba kvantine atmintimi, yra naudojamas iškviesti \\(l\\)-tajį įrašą iš duomenų bazės kvantinėje būsenoje: \\[\\begin{equation} O|l\\rangle\\otimes|0\\rangle = |l\\rangle\\otimes|b^{(l)}\\rangle\\,. \\tag{8.37} \\end{equation}\\] Toks vaizdavimas taikomas kvantinėse atraminių vektorių mašinose ir artimiausių kaimynų klasifikatoriuje. Bitų kodavimo privalumas yra tas, kad jis pateikia duomenis tuo pačiu pavidalu, kaip ir atitinkamam klasikiniam mašininio mokymosi algoritmui. Tačiau trūkumas  – didelio kubitų skaičiaus poreikis, jeigu bitų skaičius \\(N\\) didelis. Kitas kodavimo būdas – tai amplitudės kodavimas, kai duomenys pavaizduojami kvantinės bazinių vektorių \\(|i\\rangle\\) superpozicijos amplitudėse \\(x_i\\). 8.3.3 Kvantinėmis grandinėmis paremtas klasifikatorius Kaip pavyzdį panagrinėkime vieną iš kvantinio mašininio mokymosi algoritmų – kvantinėmis grandinėmis paremtą klasifikatorių. Tai prižiūrimojo mokymosi algoritmas, kuriame yra pateikiami treniravimo duomenys kartu su teisingomis žymomis. Naudojant treniravimo duomenis klasifikatorius apmokomas priskirti žymę dar nematytiems duomenims. Šis hibridinis klasikinis-kvantinis algoritmas, pristatytas Shuld, Wiebe ir bendraautorių iš Microsoft nereikalauja didelio kubitų skaičiaus bei gilių grandinių ir todėl yra tinkamas ankstyvosios raidos kvantiniams procesoriams. Algoritme yra panaudojamas duomenų amplitudžių kodavimas (žr. 6.4 poskyrį), tad \\(N = 2^n\\) dydžio duomenų bazė perteikiama tik su \\(n\\) kubitų. Darant prielaidą, kad duomenis galima efektyviai užrašyti į kvantinę registro būseną, kvantinis paralelizmas leidžia sparčią šios būsenos transformaciją ir rezultatų apskaičiavimą. Be to, dėl unitariųjų būsenų transformacijų, toks klasifikatorius nestiprina triukšmo, esančio duomenyse ir jų žymose. Kaip ir dauguma prižiūrimųjų mašininio mokymosi algoritmų, šis hibridinis algoritmas išmoko modelį, formaliai perteikiamą funkcija \\(f(x, \\theta) = y\\), pateikiant duomenis \\(x\\) ir pažymint juos \\(y\\). Binariosios klasifikacijos atveju duomenys priklauso grupei \\(a\\) arba \\(b\\),\\(y \\in {a,b}\\). Tam yra optimizuojamas modelio parametrų rinkinys \\(\\theta\\). Gerai apmokytas modelis \\(f(x, \\theta)\\) turėtų gebėti teisingai priskirti nematytus duomenis \\(x\\) grupei \\(y \\in {a,b}\\). Kvantinėmis grandinėmis paremtas klasifikatorius yra pavaizduotas 8.5 pav. 8.5 pav. Kvantinėmis grandinėmis paremtas klasifikatorius. Loginių operacijų grandinė \\(A\\) atlieka pradinės būsenos paruošimą; ji yra toliau apdorojama modelio \\(U(\\theta)\\) grandinėje optimizuojant klasifikatorių. Galiausiai, atliekama binarinė klasifikacija išmatuojant pirmojo kubito būseną Kvantinė grandinė yra parametrizuota parametrų rinkiniu \\(\\theta\\). Pradinė \\(n\\) kubitų būsena \\(|0\\rangle^{\\otimes n}\\) naudojama koduoti įvesčiai \\(x\\) pasitelkiant būsenos paruošimo unitarųjį operatorių \\(A\\). Operatorius \\(A\\) gali būti ir minėta orakulo funkcija, iškviečianti kvantinėje atmintyje laikomą duomenų bazės įvestį \\(|\\varphi(x)\\rangle\\). Šios būsenos transformacija yra aprašoma unitariuoju operatoriumi \\(U(\\theta)\\). Kvantinės grandinės parametrai \\(\\theta\\) optimizuojami taip, kad klasifikavimo rezultatas atitiktų treniravimo duomenyse pateiktą teisingą žymę. Duomenų klasifikavimo rezultatas \\(f(x, \\theta)\\) yra nuskaitomas iš būsenos \\(U(\\theta)|\\varphi(x)\\rangle\\) atliekant kubitų matavimą. Jeigu klasifikacija yra binarioji, pakanka išmatuoti tik vieną kubitą, pavyzdžiui, grandinėje parodytą pirmąjį, kurio būsena \\(|1\\rangle\\) indikuoja teisingą pateiktų duomenų klasifikavimą. Ši būsena bus randama su tam tikra tikimybe, kurią norima modeliu maksimizuoti. Visgi, norint šią statistiką pamatyti, visą grandinę reikia atlikti keletą kartų. Grandinės parametrams \\(\\theta\\) optimizuoti yra naudojamas klasikinis gradientinio nusileidimo algoritmas. Šiam algoritmui reikalingos unitariojo operatoriaus išvestinės \\(\\partial_{\\theta}U(\\theta)\\) parametrų \\(\\theta\\) atžvilgiu. Kvantinė algoritmo dalis yra naudojama gradientų ir \\(f(x, \\theta)\\) rezultatams apskaičiuoti, klasikinė – parametrams \\(\\theta\\) atnaujinti. Nuodugnus mokymo procesas yra pavaizduotas 8.6 pav. Klasikinė modelio mokymo dalis pavaizduota brūkšnine linija. 8.6 pav. Hibridinis kvantinis-klasikinis mokymo algoritmas. Kvantinis įrenginys yra naudojamas išvesties ir gradientų suskaičiavimui; kvantinės grandinės parametrai \\(\\theta\\) atnaujinami naudojantis klasikiniu algoritmu Panagrinėkime algoritmą išsamiau. Įvesties duomenys \\(x\\) yra pavaizduojami į \\(n\\) kubitų pradinę būseną taiknt amplitudžių kodavimą. Duomenų įrašas \\(x = \\{x_1 , x_2 , \\ldots, x_N \\}\\), \\(x\\in\\mathbb{R}\\), turintis \\(N = 2^n\\) elementų, yra pavaizduojamas bazinių vektorių \\(|i\\rangle\\) superpozicijos amplitudėse \\(x_i\\): \\[\\begin{equation} |\\varphi(x)\\rangle = \\frac{1}{\\chi} \\sum_{i = 1}^N x_i|i\\rangle\\,, \\tag{8.38} \\end{equation}\\] kur \\[\\begin{equation} \\chi = \\sqrt{\\sum_{i = 1}^N x_i^2}\\,. \\tag{8.39} \\end{equation}\\] Prognozuojamos žymos \\(\\ell(x)=\\lambda_1 , \\lambda_2 ,\\ldots\\), atitinkančios duomenis \\(x\\), yra nuskaitomos taikant išvesties būsenos matavimą. Šį matavimą atitinka ermitinis operatorius \\(C\\), kurio tikrinės vertės yra \\(\\lambda_{1},\\lambda_{2},\\ldots\\): \\[\\begin{equation} C = \\sum_j \\lambda_j P_j\\,. \\tag{8.40} \\end{equation}\\] Čia \\(P_j\\) yra projekcinis operatorius, projektuojantis į atitinkamą poerdvį. Klasifikatoriaus mokymo tikslas yra teisingos žymos \\(y\\) prognozavimo maksimizavimas. Tam naudojama tikslo funkcija \\(\\mathcal{L}(\\theta)\\): \\[\\begin{equation} \\mathcal{L}(\\theta)=\\frac{1}{M}\\sum_{\\lambda_j}\\sum_{x:\\ell(x)=\\lambda_j} \\langle\\varphi(x)|U^{\\dagger}(\\theta)P_{\\lambda_j}U(\\theta)|\\varphi(x)\\rangle\\,, \\tag{8.41} \\end{equation}\\] čia \\(M\\) – duomenų rinkinio dydis. Binariosios klasifikacijos atveju, kai yra dvi žymos \\(\\lambda_1\\) ir \\(\\lambda_2\\), tikslo funkciją galime užrašyti taip: \\[\\begin{equation} \\begin{aligned} \\mathcal{L}(\\theta) = &amp; \\frac{1}{M}\\sum_{x:\\ell(x) = \\lambda_j} \\langle\\varphi(x)|U^{\\dagger}(\\theta)P_1 U(\\theta)|\\varphi(x)\\rangle \\\\ &amp; - \\frac{1}{M}\\sum_{x:\\ell(x) = \\lambda_2} \\langle\\varphi(x)|U^{\\dagger}(\\theta)P_2 U(\\theta)|\\varphi(x)\\rangle\\,. \\end{aligned} \\tag{8.42} \\end{equation}\\] Vidines sandaugas galima efektyviai apskaičiuoti pasitelkiant papildomą ancila kubitą, kaip aprašyta Hadamardo teste. Tikslo funkcija \\(\\mathcal{L}(\\theta)\\) yra maksimizuojama taikant klasikinį gradientinio nusileidimo algoritmą. Kvantinė grandinė, realizuojanti \\(U(\\theta)\\), konstruojama taip, kad sparčiai sukurtų kvantinį supynimą ir nepareikalautų gilių grandinių. Kaip pamename, didžioji dalis \\(2^n\\) būsenų yra supintosios, tad panaudojant supintąsias būsenas atsiranda didesnė tikimybė teisingai apmokyti klasifikatorių. Operatorių \\(U(\\theta)\\) realizuojanti grandinė yra sudaroma iš blokų: \\[\\begin{equation} U(\\theta)=G_{\\mathrm{out}}(\\theta_{\\mathrm{out}})B_L(\\theta_L)\\cdots B_2(\\theta_2)B_1(\\theta_1)\\,. \\tag{8.43} \\end{equation}\\] Kiekvienas blokas \\(B_j(\\theta_j)\\) yra sudarytas iš \\(n\\) skaičiaus 1 kubito loginių vartų, \\(n\\) skaičiaus sąlyginių 2 kubitų loginių vartų. Užbaigiama 1 kubito loginiais vartais \\(G_{\\mathrm{out}}\\) matavimui, skirtam pirmajam grandinės kubitui. Vieno kubito loginiai vartai yra bendriausio tipo \\(U_3 (\\alpha,\\beta,\\gamma) \\equiv G\\) (žr. 4.1 poskyrį). O štai 2 kubitų sąlyginius \\(cG\\) galime užrašyti: \\[\\begin{equation} cG = |0\\rangle\\langle 0|\\otimes I + |1\\rangle\\langle 1|\\otimes G\\,. \\tag{8.44} \\end{equation}\\] Sąlyginiai vartai čia sudaro ciklinį kodą, kuris yra charakterizuojamas artumo parametru \\(r\\) (\\(0 &lt; r &lt; n\\)). Kiekvienam kubitui, kurio numeris \\(j\\), pritaikomi sąlyginiai loginiai vartai, kuriuose \\(j\\)-tasis kubitas yra adresatas, o \\((j + r)\\mod(n)\\)-tas kubitas kontroliuojantis. Trijų kubitų atveju, kai \\(r = 1\\), toks blokas pavaizduotas 8.7 pav. 8.7 pav. 3 kubitų kvantinį supynimą sudarančios grandinės blokas. \\(G_j\\) yra 1 kubito loginiai vartai Tikslo funkcijos \\(\\mathcal{L}(\\theta)\\) maksimizavimui taikant gradientinio nusileidimo metodą reikia operatorių \\(U(\\theta)\\) išvestinių \\(\\theta\\) parametrų atžvilgiu. Kadangi realizuojame \\(U(\\theta) \\rightarrow U_3(\\alpha,\\beta,\\gamma)\\), tai savo ruožtu reiškia išvestines \\((\\alpha,\\beta,\\gamma)\\) atžvilgiu. Vieno kubito loginių vartų išvestinės, pvz., \\(I\\otimes\\partial_{\\theta}G\\otimes I\\otimes\\cdots\\otimes I\\), yra taip pat vieno kubito loginiai vartai, tačiau sąlyginių loginių vartų išvestinės \\(\\partial_{\\theta}(cG)\\) nėra unitarusis operatorius. Vis dėlto \\(\\partial_{\\theta}(cG)\\) gali būti realizuojamas kaip dviejų unitariųjų operatorių suma: \\[\\begin{equation} \\partial_{\\theta}(cG) = |1\\rangle\\langle 1|\\otimes\\partial_{\\theta}G = \\frac{1}{2}(I\\otimes\\partial_{\\theta}G - Z\\otimes\\partial_{\\theta}G)\\,. \\tag{8.45} \\end{equation}\\] Kiekviena iš šių grandinių, turinčių \\(I\\otimes\\partial_{\\theta}G\\) bei \\(Z\\otimes\\partial_{\\theta}G\\) narius, yra įvykdoma atskirai, o jų skirtumas suskaičiuojamas klasikinėje algoritmo optimizavimo dalyje. Galop, norint įvertinti tikimybes, kvantinė grandinė turi būti pakartotinai įvykdoma kelis kartus. Pakartojimų skaičius auga su norimu tikslumu \\(\\epsilon\\) kaip \\(O(1/\\epsilon^2)\\). 8.3.4 Pagrindinių komponentų analizė Kvantinė pagrindinių komponentų analizė (angl. quantum principal component analysis¸ trumpinys qPCA) leidžia nustatyti nežinomos kvantinės būsenos, apibūdinamos tankio matrica \\(\\rho\\), tikrinius vektorius, atitinkančius didžiausias tikrines vertes. Tankio matrica \\(\\rho\\) yra išskaidoma tikriniais vektoriais: \\[\\begin{equation} \\rho = \\sum_{k = 1}^N \\lambda_k|a_k\\rangle\\langle a_k|\\,, \\tag{8.46} \\end{equation}\\] čia \\(N\\) – erdvės dydis; \\(|a_k \\rangle\\) – tikriniai vektoriai; \\(\\lambda_k\\) – atitinkamos tikrinės vertės. Kvantinės pagrindinių komponentų analizės tikslas – išrinkti \\(|a_k\\rangle\\) atitinkančius didžiausius \\(\\lambda_k\\). Kadangi tankio matrica \\(\\rho\\) yra ermitinė, operatorius \\(U = \\mathrm{e}^{-\\mathrm{i}\\rho t}\\) yra unitarusis. Tikrinių vektorių nustatymui kvantiniu kompiuteriu galima pritaikyti hamiltoniano kodavimą, aprašytą 8.1.1 skyriuje. Operatoriaus \\(U\\) tikrines vertes \\(\\mathrm{e}^{\\mathrm{i}\\lambda_k t}\\) randamos panaudojant kvantinį fazės nustatymo algoritmą, aprašytą 7.4 poskyryje. Šiuose alogritmuose reikia apskaičiuoti matricos \\(\\rho\\) eksponentę. Šį skaičiavimą paspartina paprastas matematinis triukas pasitelkiant bet kokią pagalbinę tankio matricą \\(\\sigma\\). Laiką \\(t\\) padalijame į \\(s\\) dalių, \\(t = s\\Delta t\\), ir darome prielaidą, kad turime daug būsenos \\(\\rho\\) kopijų. Galima pastebėti, kad galioja tokia lygybė: \\[\\begin{equation} \\mathrm{Tr}_P\\mathrm{e}^{-\\mathrm{i}W\\Delta t}\\rho\\otimes\\sigma \\mathrm{e}^{\\mathrm{i}W\\Delta t} = \\sigma - \\mathrm{i}\\Delta t\\lbrack\\rho,\\sigma\\rbrack + O(\\Delta t^2) = \\mathrm{e}^{-\\mathrm{i}\\rho\\Delta t}\\sigma \\mathrm{e}^{\\mathrm{i}\\rho\\Delta t} + O(\\Delta t^2)\\,, \\tag{8.47} \\end{equation}\\] kur \\(\\mathrm{Tr}_P\\) yra dalinis pėdsakas per pirmą kintamąjį, o \\(W\\) – SWAP operatorius. SWAP operatoriaus eksponentė gali būti efektyviai realizuota kvantinėse grandinėse, todėl, naudojantis (8.47) lygtimi, galima efektyviai realizuoti ir tankio matricos eksponentės skaičiavimą. "],["kvantinių-klaidų-aptikimas-ir-taisymas.html", "9 skyrius. Kvantinių klaidų aptikimas ir taisymas 9.1 Klasikinės ir kvantinės klaidos 9.2 Kvantinis supynimas su aplinka ir klaidų atsiradimas 9.3 Bito apvertimo klaidos aptikimas ir taisymas 9.4 Fazės apvertimo klaidos aptikimas ir taisymas 9.5 Tolydžiosios klaidos 9.6 Bendrieji klaidų taisymo principai 9.7 Kvantinė Hamingo riba 9.8 Šoro 9 kubitų kodas 9.9 Kodų stabilizatoriai 9.10 Klaidoms atsparus skaičiavimas 9.11 Kvantinis tūris", " 9 skyrius. Kvantinių klaidų aptikimas ir taisymas Klaidų taisymas iš pirmo žvilgsnio neatrodo itin estetiškas ar įdomus užsiėmimas. Tačiau kvantinėje kompiuterijoje tai yra viena iš labiausiai apšviečiančių ir stebinančių sričių. Dekoherencija yra artimai susijusi su mus supančių klasikinių reiškinių atsiradimu iš pasaulio, kuris fundamentaliai vadovaujasi kvantinėmis taisyklėmis. Dekoherencija – pagrindinė priežastis, kuri neleidžia realizuoti makroskopinio dydžio objektų, esančių superpozicijos būsenose. Atliekant klaidų analizę ir taisymą taip pat geriau atsiskleidžia gili informacijos sąvokos reikšmė ir kvantinio supynimo svarba. Informacijos atskleidimas gali sugriauti sistemos superpozicijos būseną net ir tada, jeigu su šia sistema nėra tiesioginės sąveikos. 9.1 Klasikinės ir kvantinės klaidos Kvantinė kompiuterija pasikliauja delikačiomis kubitų superpozicijos būsenomis. Praktikoje kubitai nėra idealiai izoliuoti nuo aplinkos, jų neišvengiama sąveika su išorinėmis sistemomis mažina gebėjimą išlikti superpozicijos būsenose ilgą laiką. Pirmame skyriuje minėtos \\(T_1\\) ir \\(T_2\\) dekoherencijos trukmės atspindi, kaip intensyviai išorinės sąveikos vyksta su kubitais, taip pat įvardija laiko skalę, pagal kurią galima spręsti, kiek loginių operacijų įmanoma atlikti iki tol, kol neatsiras didelė klaidų tikimybė. Dekoherencija nėra vienintelis klaidų šaltinis – atliekamų loginių vartų netikslumai taip pat praktiškai neišvengiami. Unitariosios operacijos yra nusakomos tolydžiai kintančiais parametrais, todėl praktikoje atsiremiama į ribotą loginių vartų tikslumą. Nepaisant šių klaidų šaltinių, pageidaujamo tikslumo bei ilgumo kvantiniai skaičiavimai gali būti atlikti pasitelkiant klaidų taisymo algoritmus. Tam yra reikalaujama, kad dekoherencijos trukmės nebūtų per daug trumpos, o loginių vartų netikslumai – per daug dideli. Tada pasitelkus papildomus išteklius – kubitus ir logines operacijas – galima formaliai pasiekti klaidoms atsparius skaičiavimus. Šiame procese klaidos yra taisomos dinaminėje situacijoje viso skaičiavimo proceso metu. Žinoma, kvantines būsenas norima apsaugoti ir statinėse situacijose – siunčiant kubitus kvantiniais ryšiais ar saugant kvantinio kompiuterio atmintyje. Kaip matysime, panašūs principai yra taikomi abiem situacijoms. Šiuolaikiniai klasikiniai kompiuteriai yra itin atsparūs skaičiavimo klaidoms ir šiuo atžvilgiu gali būti traktuojami kaip esantys be trūkumų. Klaidos turi didesnę tikimybę atsirasti siunčiant skaitmeninę informaciją komunikacijos kanalais ir ją užrašant į atmintį. Klaidų atsiradimas daugeliu atvejų yra nenuspėjamas (formaliau – stochastinis) ir šnekamojoje kalboje vadinamas triukšmu (angl. noise). Pagrindinis principas norint užtikrinti, kad esant triukšmui informacija nebus prarasta, yra pasitelkti papildomą, vadinamąją perteklinę informaciją. Jeigu dalis informacijos ir yra prarandama, perteklinė informacija padeda užtikrinti, kad informacijos turinys bus sėkmingai atstatytas. Šį principą taiko ir žmonės tarpusavio komunikacijoje, kai paprašoma pakartoti gerai neišgirstą sakinį. Kaip to pavyzdį kompiuterijoje imkime, kad Agnė ketina nusiųsti Benui informaciją dvejetainiu pavidalu naudodama triukšmingą komunikacijos kanalą, kuriame triukšmo efektas yra kiekvieną bitą apversti (\\(0 \\leftrightarrow 1)\\) su tikimybe \\(p\\) (\\(0 \\leq p \\leq 1\\)), nepriklausomai nuo kitų bitų verčių. Tad tikimybė, kad bus gautas teisingas bitas, yra \\(1 - p\\). Siekdama apsaugoti dvejetainę informaciją, Agnė kiekvieną turinio bitą prieš siuntimą pakeičia trimis identiškais bitais: \\(0 \\rightarrow 000\\), \\(1 \\rightarrow 111\\). Šios 0 ir 1 trijų bitų sekos yra formaliai vadinamos loginiais 0 ir 1 bitais, o pasirinktas specifinis būdas perteikti bitų vertėms vadinamas kodu. Benas, žinodamas Agnės kodavimo būdą ir taikydamas daugumos balsavimo metodą (angl. majority voting), gavęs bitų seką gali nuspręsti, koks bitas jam buvo siųstas. Pavyzdžiui, jeigu gauta seka yra 001, daugumos balso principu jis nusprendžia, kad įvyko klaida trečiajame bite ir buvo siųsta \\(000\\). Toks trijų bitų kodavimo būdas bus sėkmingas, jeigu kode atsiranda ne daugiau nei viena klaida. Galima nesunkiai parodyti, kad bendra tikimybė, nusakanti, jog įvyks nepataisoma dviejų ar trijų bitų apvertimo klaida, yra \\(3p^2 (1 - p) + p^3\\). Tad palyginus su \\(p\\), kai siunčiamas pavienis bitas, trijų bitų kodas sumažina nepataisomų klaidų tikimybę, jeigu \\(p &lt; 0.5\\), ir suteikia sparčiai didėjantį pranašumą toliau mažėjant \\(p\\). Klasikiniuose klaidų taisymo koduose yra taikomas bitų kopijavimas pridedant perteklinę informaciją, o siekiant klaidas aptikti ir jas taisyti bitų sekos yra tiesiogiai nuskaitomos. Akivaizdu, kad abu šie procesai negali būti pritaikomi kvantiniam kompiuteriui ir kvantiniams ryšiams. Bendrosios kvantinės būsenos neįmanoma nukopijuoti, o tokios būsenos tiesioginis nuskaitymas sugriauna superpoziciją ir joje laikomą informaciją. Be to, bitų apvertimas yra vienintelė galima klaida klasikinėje terpėje; o štai kvantinių klaidų įvairovė yra didesnė, nes klaidos kinta tolydžiai dėl analoginio kvantinių būsenų pobūdžio. Pavyzdžiui, 1 kubito būseną \\(|\\psi\\rangle\\) nusakome Blocho vektoriumi, kuris apibūdinamas dviem tolydžiais parametrais, nurodančiais kampus. Jeigu loginiais vartais norima pasukti šį vektorių, sakykime, apie \\(x\\) ašį kampu \\(\\theta\\), tačiau gaunamas \\(\\theta + \\varepsilon\\), netikslumas \\(\\varepsilon\\) yra viena galima klaida. Tai galima formaliai užrašyti dviem unitariaisiais operatoriais, veikiančiais kubitą paeiliui: \\[\\begin{equation} ER_x(\\theta)|\\psi\\rangle = \\mathrm{e}^{-\\mathrm{i}\\varepsilon X/2}\\mathrm{e}^{-\\mathrm{i}\\theta X/2}|\\psi\\rangle\\,. \\tag{9.1} \\end{equation}\\] Čią \\(R_x(\\theta) = \\mathrm{e}^{-\\mathrm{i}\\theta X/2}\\) nusako tikslią operaciją, o po jos rašomas klaidos operatorius \\(E = \\mathrm{e}^{-\\mathrm{i}\\varepsilon X/2}\\). Nepageidaujamos išorinės sąveikos taip pat gali įvesti šias klaidas. Įsivaizduokime vėl, kad sąveikos efektas yra pasukti Blocho vektorių aplink x ašį kampu \\(\\varepsilon\\), kai pradinė kubito būsena yra \\(|0 \\rangle\\). Siekiant supaprastinti simboliką, toliau minuso ženklą ir faktorių 2 įtrauksime į \\(\\varepsilon\\). Randame paveiktą būseną: \\[\\begin{equation} \\mathrm{e}^{\\mathrm{i}\\varepsilon X}|0\\rangle = \\big\\lbrack\\cos(\\varepsilon)I + \\mathrm{i}\\sin(\\varepsilon)X\\big\\rbrack|0\\rangle = \\cos(\\varepsilon)|0\\rangle + \\mathrm{i}\\sin(\\varepsilon)|1\\rangle\\,. \\tag{9.2} \\end{equation}\\] Tai formaliai nusako nepaveiktos būsenos \\(|0\\rangle\\) ir klaidingos būsenos \\(|1\\rangle\\) superpoziciją. Tikimybė, kad atlikus matavimą kubitas bus rastas būsenose \\(|0\\rangle\\) arba \\(|1\\rangle\\), kai \\(\\varepsilon\\) yra itin mažas, tampa: \\[\\begin{align} p\\big(|0\\rangle\\big) = &amp; \\cos^2(\\varepsilon) \\approx 1 - \\varepsilon^2\\,; \\tag{9.3}\\\\ p\\big(|1\\rangle\\big) = &amp; \\sin^2(\\varepsilon) \\approx \\varepsilon^2\\,.\\tag{9.4} \\end{align}\\] Jeigu ši sąveika, ar loginių vartų paklaida, įvyktų sistemiškai \\(n\\) kartų, tada tikimybės būtų atitinkamai \\(1 - (n\\varepsilon)^2\\) ir \\((n\\varepsilon)^2\\). Itin mažos paklaidos skaičiavimo metu gali būti toleruotinos, nes tikimybė rasti klaidingą būseną bus itin maža. Tačiau dideliuose algoritmuose, tokiuose kaip atliekant Šoro pirminių skaičių faktorizavimą, loginių vartų skaičius gali siekti \\(\\sim 10^{10}\\) ir daugiau. Loginių vartų paklaida \\(\\varepsilon\\) atitinkamai turi būti mažesnė nei \\(\\sim 10^{-10}\\). Šios knygos rašymo metu loginių vartų tikslumas siekia \\(\\sim 10^{-4}\\), tad klaidų taisymo algoritmai yra pageidautini. Kvantinis supynimas ir su juo įvedamos koreliacijos klaidų taisymo algoritmuose dar kartą iliustruoja ypatingą šio ištekliaus svarbą. Nepaisant klaidų analoginio pobūdžio ir begalinio tikslumo norint jas apibūdinti, šis išteklius užtikrina, kad reikia taisyti tik diskrečias trijų tipų klaidas. Kitaip tariant, kvantinėje kompiuterijoje klaidos yra efektyviai skaitmenizuojamos. Pirmojo tipo klaida yra, kaip ir klasikinėje skaitmeninėje kompiuterijoje, vadinama bito apvertimo klaida (angl. bit-flip error), kuri sukeičia kubito būsenas \\(|0\\rangle \\leftrightarrow |1\\rangle\\). Kubito apvertimo klaidos procesas yra nusakomas Pauli-\\(X\\) operatoriumi, kuris veikdamas bendrą superpozicijos būseną turi efektą: \\[\\begin{equation} X\\big(a|0\\rangle + b|1\\rangle\\big) = a|1\\rangle + b|0\\rangle\\,. \\tag{9.5} \\end{equation}\\] Fazės apvertimo klaida (angl. phase-flip error) yra išskirtinai kvantinio pobūdžio, nes klasikinėje kompiuterijoje fazės atitikmens nėra. Fazės apvertimo klaidos atsiradimas yra nusakomas Pauli-\\(Z\\) operatoriumi: \\[\\begin{equation} Z\\big(a|0\\rangle + b|1\\rangle\\big) = a|0\\rangle - b|1\\rangle\\,. \\tag{9.6} \\end{equation}\\] Matyti, kad santykinė fazė tarp \\(|0\\rangle\\) ir \\(|1\\rangle\\) kubito būsenų yra pakeičiama. Galiausiai, bito ir fazės apvertimo klaidų kombinacija, \\(XZ\\), yra trečia galima klaida. Primename Pauli operatorių sąryšį \\(XZ = -\\mathrm{i}Y\\). Tad šių dviejų klaidų kombinaciją iki globalios fazės galime išreikšti Pauli-\\(Y\\) loginiais vartais: \\[\\begin{equation} -\\mathrm{i}Y\\big(a|0\\rangle + b|1\\rangle\\big) = a|1\\rangle - b|0\\rangle\\,. \\tag{9.7} \\end{equation}\\] 9.2 Kvantinis supynimas su aplinka ir klaidų atsiradimas Loginių vartų netikslumai po kiekvieno jų pritaikymo gali įvesti tolydžiai kintančias klaidas. Sistemiškai atsirandančios vienodo tipo klaidos yra lengviau aptinkamos bei ištaisomos, na, o kintančios atsitiktiniu būdu įveda triukšmo pobūdį. Tačiau, net ir palikus kubitus ramybėje, jų būsenos gali būti paveikiamos nekontroliuojamų sąveikų su išorinėmis sistemomis. Bendrą kubitų ir aplinkos kvantinę sistemą visada galime apibūdinti kaip naują išplėstinę sistemą, kuri kinta laike deterministiškai vadovaujantis Šriodingerio lygtimi. Tačiau dėl informacijos apie įvykusias sąveikas trūkumo mūsų požiūriu bus stebimi atsitiktiniai, triukšmo pobūdžio, kubitų būsenų pokyčiai. Dėl sąveikų tarp kvantinių sistemų bendroje situacijoje atsiranda supynimas. Siekdami iliustruoti supynimo įtaką imkime paprastą pavyzdį, kuriame kubitas yra paruoštas pradinėje superpozicijos būsenoje: \\[\\begin{equation} |\\psi\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle\\big)\\,. \\tag{9.8} \\end{equation}\\] Jeigu atliksime šiai būsenai (idealiai veikiančius) Hadamardo loginius vartus, ji taps \\(H|\\psi\\rangle = |0\\rangle\\). Tad išmatavus kubito būseną su \\(p = 1\\) tikimybe rasime \\(|0\\rangle\\). Sakykime, kad prieš atliekant \\(H\\) kubitas patyrė sąveiką \\(U\\) su aplinkos sistema \\(|e\\rangle\\), ir tai lėmė jų kvantinį supynimą ir bendrą būseną: \\[\\begin{equation} U|\\psi\\rangle\\otimes|e\\rangle = \\frac{1}{\\sqrt{2}}\\big(|0\\rangle\\otimes|e_1\\rangle + |1\\rangle\\otimes|e_2\\rangle\\big)\\,. \\tag{9.9} \\end{equation}\\] Čia \\(|e_0\\rangle\\) ir \\(|e_1\\rangle\\) yra aplinkos sistemos būsenos. Nežinodami apie įvykusią sąveiką, atliekame kubitui Hadamardo vartus: \\[\\begin{equation} H\\otimes I\\big(U|\\psi\\rangle\\otimes|e\\rangle\\big) = \\frac{1}{2}\\big(|0\\rangle + |1\\rangle )\\otimes|e_1\\rangle + \\frac{1}{2}\\big(|0\\rangle - |1\\rangle )\\otimes|e_2\\rangle\\big)\\,. \\tag{9.10} \\end{equation}\\] Matome, kad kvantinis supynimas neleidžia panaikinti kubito būsenos \\(|1\\rangle\\), kaip tai atsitinka dėl interferencijos \\(H|\\psi\\rangle\\). Tolesniame žingsnyje vėl išmatuojame kubito būseną, tikimybės \\(p(0)\\) ir \\(p(1)\\) rasti \\(|0\\rangle\\) ir \\(|1\\rangle\\) yra: \\[\\begin{align} p(0) = &amp; \\frac{1}{4}\\big(\\langle e_1 | e_1 \\rangle + \\langle e_2 | e_2 \\rangle + \\langle e_1 | e_2 \\rangle + \\langle e_2 | e_1 \\rangle\\big) \\nonumber\\\\ = &amp; \\frac{1}{4}\\big(\\langle e_1 | e_1 \\rangle + \\langle e_2 | e_2 \\rangle + 2\\mathrm{Re}\\lbrack \\langle e_1 | e_2 \\rangle\\rbrack\\big)\\,;\\tag{9.11}\\\\ p(1) = &amp; \\frac{1}{4}\\big(\\langle e_1 | e_1 \\rangle + \\langle e_2 | e_2 \\rangle - 2\\mathrm{Re}\\lbrack \\langle e_1 | e_2 \\rangle\\rbrack\\big)\\,.\\tag{9.12} \\end{align}\\] Norėdami įvertinti šias tikimybes, turime daugiau pasakyti apie išorinę sistemą. Darydami prielaidą, kad ji yra normuotoji, o būsenos ortogonaliosios, \\(\\langle e_1 | e_2 \\rangle = 0\\), randame \\(p(0) = p(1) = 1/2\\). Tai nusako lygias tikimybes rasti \\(|0\\rangle\\) arba \\(|1\\rangle\\) pamatavus sistemos kubito būseną. Todėl nežinant apie įvykusią sąveiką ir kvantinį supynimą mūsų požiūriu atrodys, kad kubito būsena tampa visiškai atsitiktinė, o ne \\(|0\\rangle\\), kaip tikėtasi. Informacija, koduojama bendrosios būsenos amplitudėse, tampa efektyviai nebepasiekiama, nes yra delokalizuojama koreliacijose tarp aplinkos ir kubito. Sąveikos su aplinka priveda kvantines sistemas prie dekoherencijos, dėl kurios jos panašėja į klasikines triukšmingas sistemas. Norėdami aiškiau pamatyti, kaip atsiranda trys minėtos Pauli operatoriais nusakomos kubitų būsenų klaidos, imkime bendriausio tipo unitariąją transformaciją \\(U\\), veikiančią kubito ir aplinkos kvantinę sistemą. Ji nebūtinai apibūdinama dviem skirtingomis būsenomis, kaip kubitai, bet gali turėti jų daug daugiau. Transformacijos įtaka kubito standartiniams baziniams vektoriams ir aplinkos pradinei būsenai \\(|e\\rangle\\) išreiškiama taip: \\[\\begin{align} U|0\\rangle\\otimes|e\\rangle = &amp; |0\\rangle\\otimes|e_1 \\rangle + |1\\rangle\\otimes|e_2 \\rangle\\,;\\tag{9.13} \\\\ U|1\\rangle\\otimes|e\\rangle = &amp; |0\\rangle\\otimes|e_3 \\rangle + |1\\rangle\\otimes|e_4 \\rangle\\,.\\tag{9.14} \\end{align}\\] Bendroje situacijoje, aplinkos sistemos būsena, kuri dalyvavo sąveikoje, gali būti nenormuotoji ir skirtingi \\(|e_i \\rangle\\) tarpusavyje neortogonalūs, \\(\\langle e_i | e_j \\rangle \\neq 0\\). Imkime bendrą kubito būseną \\(|\\psi\\rangle = a|0\\rangle + b|1\\rangle\\), tada randame: \\[\\begin{equation} \\begin{aligned} U|\\psi\\rangle\\otimes|e\\rangle = &amp; a\\big(|0\\rangle\\otimes|e_1 \\rangle + |1\\rangle\\otimes|e_2 \\rangle\\big) + b\\big(|0\\rangle\\otimes|e_3 \\rangle + |1\\rangle\\otimes|e_4 \\rangle\\big) \\\\ = &amp; \\frac{1}{2}\\Big\\lbrack\\big(a|0\\rangle + b|1\\rangle\\big) \\otimes\\big(|e_0 \\rangle + |e_3 \\rangle\\big) + \\big(a|1\\rangle + b|0\\rangle\\big) \\otimes\\big(|e_1 \\rangle + |e_2 \\rangle\\big) \\\\ &amp; + \\big(a|0\\rangle - b|1\\rangle\\big) \\otimes\\big(|e_0 \\rangle - |e_3 \\rangle\\big) + \\big(a|1\\rangle - b|0\\rangle\\big) \\otimes\\big(|e_1 \\rangle - |e_2 \\rangle\\big)\\Big\\rbrack\\,. \\end{aligned} \\tag{9.15} \\end{equation}\\] Antroje eilutėje pergrupavome būsenas siekdami parodyti, kad kubito sąveika su aplinka gali būti išreikšta Pauli operatoriais, veikiančiais kubito superpozicijos būseną: \\[\\begin{equation} U|\\psi\\rangle\\otimes|e\\rangle = I|\\psi\\rangle\\otimes|e_I \\rangle + X|\\psi\\rangle\\otimes|e_x \\rangle + Z|\\psi\\rangle\\otimes|e_z \\rangle + XZ|\\psi\\rangle\\otimes|e_{xz}\\rangle\\,. \\tag{9.16} \\end{equation}\\] Aplinkos būsenas pervadinome taip: \\[\\begin{equation} \\begin{aligned} |e_I \\rangle = &amp; \\frac{\\big(|e_0 \\rangle + |e_3 \\rangle\\big)}{2}\\,,\\quad |e_x \\rangle = \\frac{\\big(|e_1 \\rangle + |e_2 \\rangle\\big)}{2}\\,,\\\\ |e_z \\rangle = &amp; \\frac{\\big(|e_0 \\rangle - |e_3 \\rangle\\big)}{2}\\,,\\quad |e_{xz}\\rangle = \\frac{\\big(|e_1 \\rangle - |e_2 \\rangle\\big)}{2}\\,. \\end{aligned} \\tag{9.17} \\end{equation}\\] Matome, kad aplinkos ir kubito sistema tampa supintąja. Pirmoji superpozicijoje būsena \\(I|\\psi\\rangle\\otimes|e_I \\rangle\\) įvardija nepakitusią kubito pradinę būseną. Kubito apvertimo klaida yra nusakoma nariu \\(X|\\psi\\rangle\\otimes|e_x \\rangle\\), o štai fazės klaida, taip pat fazės ir kubito apvertimo klaidų kombinacija nusako būsenas \\(Z|\\psi \\rangle\\otimes|e_z \\rangle\\) ir \\(XZ|\\psi \\rangle\\otimes|e_xz \\rangle\\), atitinkamai. Tai neturėtų būti stebinantis rezultatas, kadangi visos \\((2 \\times 2)\\) dydžio unitariosios matricos, nusakančios visas įmanomas 1 kubito būsenų transformacijas, gali būti išreikštos Pauli matricų \\(\\{I, X, Y, Z\\}\\) tiesinėmis kombinacijomis. 9.3 Bito apvertimo klaidos aptikimas ir taisymas Darome prielaidą, kad klaidos atsiranda kiekviename registro kubite atskirai nuo kitų kubitų. Tai yra vadinamosios nekoreliuotos triukšmo pobūdžio klaidos. Formaliai sakysime, kad klaidos atsiranda siunčiant kvantines būsenas per triukšmingą kvantinį kanalą (angl. noisy quantum channel). Tai gali įvardyti kubitų siuntimą kvantiniais ryšiais arba kubitų laiko evoliuciją tam tikru laiko intervalu kvantiniame kompiuteryje. Kubitas nukeliauja kanalą nepaveiktas su tikimybe \\(1 - p\\) ir patiria klaidą su tikimybe \\(p\\). Šioje stadijoje taip pat darome prielaidą, kad loginiai vartai veikia idealiai, be netikslumų. Dinaminę klaidų taisymo metodologiją, apimančią dekoherencijos ir loginių vartų efektus kartu, aptariame šio skyriaus pabaigoje. Kvantinių klaidų taisymo algoritmai yra dažnai pristatomi pradedant nuo 3 kubitų kodų, skirtų taisyti bito apvertimo arba fazės apvertimo klaidas. Pavieniui jie nėra pilnieji kodai, galintys ištaisyti visas klaidų kombinacijas, tačiau leidžia pamatyti esminius klaidų aptikimo ir taisymo principus. Šių dviejų kodų sujungimu konkatenacijos būdu (angl. concatenation) yra pagrįstas Šoro 9 kubitų kodas – vienas iš pirmųjų gebantis ištaisyti bendrojo tipo klaidas. Kaip ir klasikiniame bito apvertimo klaidos pavyzdyje, loginis kubitas yra sudaromas iš trijų fizinių kubitų. Vieno kubito būsena \\(|\\psi\\rangle\\) yra perteikiama loginiu kubitu \\(|\\psi\\rangle_L\\) taip: \\[\\begin{equation} |\\psi\\rangle = a|0\\rangle + b|1\\rangle \\rightarrow |\\psi\\rangle_L = a|0\\rangle_L + b|1\\rangle_L = a|000\\rangle + b|111\\rangle\\,. \\tag{9.18} \\end{equation}\\] Būsenos yra normuotosios, \\(|a|^2 + |b|^2 = 1\\), o 1 kubito baziniai vektoriai koduojami \\(|0\\rangle\\rightarrow |000\\rangle\\), \\(|1\\rangle \\rightarrow |111\\rangle\\). Atkreipiame dėmesį, kad loginiame kubite \\(|\\psi\\rangle_L\\) baziniai vektoriai yra „patrigubinami”, tačiau \\(|\\psi\\rangle\\) būsena nėra nukopijuojama tris kartus, \\(|\\psi\\rangle\\otimes|\\psi\\rangle\\otimes|\\psi\\rangle\\), ir todėl neprieštarauja uždraustojo kopijavimo teoremai. Loginis kubitas \\(|\\psi\\rangle_L\\) nusako supintąją trijų fizinių kubitų kvantinę būseną, kurią galima sukurti pradedant nuo kubito \\(|\\psi\\rangle\\) būsenoje ir dviejų papildomų kubitų \\(|00\\rangle\\) būsenoje atliekant dvejus \\(CNOT\\) loginius vartus. 9.1 pav. Loginio kubito būsenos \\(|\\psi\\rangle_L\\) paruošimas naudojant 3 fizinius kubitus Visi trys fiziniai kubitai, formuojantys loginį kubitą, gali būti paveikti triukšmo; tad šis kodas bus veiksmingas, jeigu bito apvertimo klaida atsiranda ne daugiau nei viename iš trijų kubitų. Toliau pažiūrėkime, kaip aptikti atsirandančią bito apvertimo klaidą loginiame kubite. Tiesioginiai 3 kubitų būsenų matavimai nėra išeitis aptikti ir taisyti klaidas. Sakykime, kad atsiranda klaida pirmajame kubite, kuri pakeičia \\(|\\psi\\rangle_L\\) būseną taip: \\[\\begin{equation} |\\psi\\rangle_L \\rightarrow a|100\\rangle + b|011\\rangle\\,. \\tag{9.19} \\end{equation}\\] Atlikę Pauli-\\(Z\\) matavimus su visais 3 kubitais rastume \\(|100\\rangle\\) arba \\(|011\\rangle\\) būsenas su \\(|a|^2\\) ir \\(|b|^2\\) tikimybėmis, atitinkamai. Tai užtikrintų klaidos aptikimą, tačiau superpozicija bus sugriauta, o negalėdami sužinoti \\(a\\) ir \\(b\\) amplitudžių šios būsenos nebeatstatysime. Aptikti klaidas 3 kubitų kode galima pritaikius vadinamąjį nelokalų matavimą, pasitelkiant papildomus ancila kubitus. Atkreipiame dėmesį, kad abu kodai \\(|0\\rangle_L\\) ir \\(|1\\rangle_L\\) yra \\(Z\\otimes Z\\otimes I\\), \\(Z\\otimes I\\otimes Z\\) ir \\(I\\otimes Z\\otimes Z\\) operatorių tikriniai vektoriai su vienodomis tikrinėmis vertėmis \\(\\lambda = 1\\). Pavyzdžiui, \\(Z\\otimes Z\\otimes I|0 \\rangle_L = |0\\rangle_L\\) ir \\(Z\\otimes Z\\otimes I|1\\rangle_L = |1\\rangle_L\\). Tokį dėsningumą matome iš to, kad Pauli-\\(Z\\) operatoriai tenzorinėje operatorių sandaugoje, veikdami pavienių kubitų būsenas \\(|0\\rangle\\) ir \\(|1\\rangle\\) jas sudaugina su \\(\\lambda = 1\\) ir \\(\\lambda = -1\\) tikrinėmis vertėmis, atitinkamai. Tad \\(Z\\otimes Z\\otimes I\\) veikdamas pirmąjį ir antrąjį kubitus \\(|000\\rangle\\) ir \\(|111\\rangle\\) būsenose, arba jų superpozicijoje, sudaugina bendrą būseną su \\(\\lambda_1 \\lambda_2 = 1\\). Tačiau, jeigu vienas iš šių dviejų kubitų patyrė bito apvertimo klaidą, tada jų būsenos skirsis, o tikrinių verčių sandauga taps \\(\\lambda_1 \\lambda_2 = -1\\). Siekiant nustatyti, kuriame iš trijų kubitų įvyko klaida, pakanka atlikti du matavimus \\(Z\\otimes Z\\otimes I\\) ir \\(Z\\otimes I\\otimes Z\\), arba bet kurią iš kitų dviejų porų kombinacijos. Pavyzdžiui, jeigu \\(Z\\otimes Z\\otimes I\\) ir \\(Z\\otimes I\\otimes Z\\) matavimų tikrinės vertės yra abi \\(\\lambda_1 \\lambda_2 = \\lambda_1 \\lambda_3 = -1\\), galime unikaliai konstatuoti, kad įvyko klaida pirmajame kubite. Kitos dvi galimybės \\(\\lambda_1 \\lambda_2 = -1\\) ir \\(\\lambda_1 \\lambda_3 = 1\\) bei \\(\\lambda_1 \\lambda_2 = 1\\) ir \\(\\lambda_1 \\lambda_3 = -1\\) indikuoja klaidą antrajame ir trečiajame kubite, atitinkamai. Kvantinė grandinė 9.2 pav. iliustruoja bito apvertimo klaidos aptikimą ir taisymą. 9.2 pav. Bito apvertimo klaidos aptikimą ir taisymą atliekanti grandinė Siekdami atlikti \\(Z\\otimes Z\\otimes I\\) ir \\(Z\\otimes I\\otimes Z\\) operatorių matavimus panaudojame papildomus ancila kubitus, inicializuotus pradinėje \\(|00\\rangle\\) būsenoje. Keturi \\(CNOT\\) vartai su ancila adresatiniais kubitais nusako aptikimo stadiją, kuri yra pagrįsta dviejų kubitų lyginumo nustatymu. Matome, kad \\(Z\\otimes Z\\otimes I\\) matavimas realizuojamas keičiant pirmosios ancilos \\(a_1\\) būseną. Esant skirtingoms kubitų \\(k_1\\) ir \\(k_2\\) būsenoms, ji tampa \\(|a_1 \\rangle = |k_1\\oplus k_2 \\rangle\\); čia \\(\\oplus\\) yra \\(\\mod(2)\\) bitų sudėtis. Tad, jeigu \\(|k_1 \\rangle = |k_2 \\rangle\\), tada \\(|a_1 \\rangle = |0 \\rangle\\), ir tai atitinka tikrinę vertę \\(\\lambda_1 \\lambda_2 = 1\\), indikuojančią lyginį lyginumą. Jeigu \\(|k_1 \\rangle\\neq |k_2 \\rangle\\), tada \\(|a_1 \\rangle = |1\\rangle\\), ir tai nusako tikrinę vertę \\(\\lambda_1 \\lambda_2 = -1\\) bei nelyginį lyginumą. Operatoriaus \\(Z\\otimes I\\otimes Z\\) matavimas yra analogiškai užrašomas keičiant antrosios ancilos būseną \\(|a_2 \\rangle = |k_1\\oplus k_3 \\rangle\\). Užbaigiant aptikimo stadiją, bendra loginio kubito ir ancilų su klaida pirmajame fiziniame kubite būsena tampa: \\[\\begin{equation} |\\psi\\rangle_L \\rightarrow \\big(a|100\\rangle + b|011\\rangle\\big)\\otimes|11\\rangle\\,. \\tag{9.20} \\end{equation}\\] Atkreipiame dėmesį, kad ancilos ir loginio kubito būsena yra faktorizuojamoji, todėl ancilų kubitų matavimo procesas neturi įtakos loginio kubito būsenai. Ancilų kubitų būsenos yra išmatuojamos, ir tai leidžia aptikti įvykusią klaidą. Čia svarbu atkreipti dėmesį, kad kode atlikti nelokalūs matavimai suteikia informaciją apie koreliacijas tarp dviejų būsenų, nusakančią, ar jos vienodos, ar skirtingos (lyginumas). Šios informacijos pakanka klaidų nustatymui neatskleidžiant loginio kubito būsenos amplitudžių \\(a\\) ir \\(b\\). Jų atskleidimas sugriautų superpoziciją ir joje laikomą informaciją. 9.1 lentelė. Faktorizuojamosios loginio kubito ir 2-jų ancilų kubitų būsenos, kurios indikuoja klaidos sindromą loginiame kubite. Tikimybės dešinėje nurodo rasti atitinkamas būsenas naudojant 3 kubitų bito apvertimo klaidos taisymo kodą. Pirma būsena lentelėje atitinka nepaveiktą, kitos trys nusako bito klaidą viename iš trijų fizinių kubitų. Dar kitos trys būsenos nusako būsenas su dviem bito klaidomis skirtinguose kubituose, paskutinioji – su bito klaidomis visuose trijuose. Būsena po klaidos sindromo nustatymo Tikimybė rasti šią būseną \\(\\big(a|000\\rangle+b|111\\rangle\\big)\\otimes|00\\rangle\\) \\((1-p)^3\\) \\(\\big(a|100\\rangle+b|011\\rangle\\big)\\otimes|11\\rangle\\) \\(p(1-p)^2\\) \\(\\big(a|010\\rangle+b|101\\rangle\\big)\\otimes|10\\rangle\\) \\(p(1-p)^2\\) \\(\\big(a|001\\rangle+b|110\\rangle\\big)\\otimes|01\\rangle\\) \\(p(1-p)^2\\) \\(\\big(a|110\\rangle+b|001\\rangle\\big)\\otimes|01\\rangle\\) \\(p^2(1-p)\\) \\(\\big(a|101\\rangle+b|010\\rangle\\big)\\otimes|10\\rangle\\) \\(p^2(1-p)\\) \\(\\big(a|011\\rangle+b|100\\rangle\\big)\\otimes|11\\rangle\\) \\(p^2(1-p)\\) \\(\\big(a|111\\rangle+b|000\\rangle\\big)\\otimes|00\\rangle\\) \\(p^3\\) Visos įmanomos ancilų kubitų būsenos, šiuo atveju keturios skirtingos, yra vadinamos klaidos sindromais (angl. error syndrome). 9.1 lentelė nusako visas apvertimo klaidas kartu su atitinkamomis būsenomis ir tikimybėmis šią būseną rasti. Pagal sindromo būseną, yra pritaikomi Pauli-\\(X\\) loginiai vartai pažeistam kubitui ir taip ištaisoma bito apvertimo klaida: \\(|11\\rangle\\rightarrow X\\otimes I\\otimes I\\), \\(|10\\rangle\\rightarrow I\\otimes X\\otimes I\\), \\(|01\\rangle\\rightarrow I\\otimes I\\otimes X\\), tačiau nieko nedaroma radus \\(|00\\rangle\\rightarrow I\\otimes I\\otimes I\\). Tai atliekama naudojant parodytus klasiškai kontroliuojamus loginius vartus, pritaikytus pažeistam kubitui. Šio algoritmo pabaigoje, pagal skaičiavimų paskirtį, galima atlikti dekodavimo žingsnį \\(|\\psi\\rangle_L \\rightarrow |\\psi\\rangle\\otimes|00\\rangle\\), kuris panaikina loginį kubitą ir palieka vieną fizinį kubitą \\(|\\psi\\rangle\\) būsenoje. Tai yra atliekama naudojant kodavimo loginių vartų seką atvirkštine tvarka. Toliau panagrinėkime šio 3 kubitų kodo efektyvumą. Tikimybė, kad trys pavieniai kubitai, nusiųsti per triukšmingą kvantinį kanalą, neįgaus klaidos, yra \\((1 - p)^3\\). O štai kiekviena iš būsenų, turinčių vieną klaidą, yra randama su tikimybe \\(p(1 - p)^2\\), būsenos su dviem klaidomis yra \\(p^2(1 - p)\\), ir \\(p^3\\) su trimis. Sindromą nusakančios būsenos pradeda kartotis atsiradus dviem ir daugiau klaidų. Tačiau dviejų ir trijų klaidų tikimybė yra daug mažesnė, jeigu \\(p\\) yra itin mažas. Bendra tikimybė, kad pateiktas trijų kubitų kodas neveiks, yra visų kubitų dviejų ir trijų klaidų tikimybių suma \\(3p^2(1 - p) + p^3\\), ir tai galima palyginti su tikimybe \\(p\\), kai nėra naudojamas klaidų taisymo kodas. Pavyzdžiui, kai \\(p = 0.1\\), nepataisomos klaidos tikimybė trijų kubitų kode yra \\(10^2\\) kartų mažesnė, o kai \\(p = 0.01\\), ji yra \\(10^4\\) mažesnė. Šios tikimybės susilygina kai \\(p = 0.5\\), todėl, kaip ir klasikiniame pavyzdyje, trijų kubitų taisymo metodas suteiks pranašumo prieš pavienio kubito siuntimą triukšmingu kanalu, jeigu \\(p &lt; 0.5\\). 9.4 Fazės apvertimo klaidos aptikimas ir taisymas Bito ir fazės klaidų aptikimas ir taisymas yra glaudžiai susijęs. Surinksime visą informaciją siekdami tai pademonstruoti. 4 skyriuje matėme, kad Pauli-\\(Z\\) loginius vartus galima išreikšti dviejų Hadamardo ir Pauli-\\(X\\) vartų sandauga, \\(Z = HXH\\) bei \\(X = HZH\\). Hadamardo vartai, veikdami Pauli-\\(Z\\) bazinius vektorius transformuoja juos į Pauli-\\(X\\) bazinius vektorius: \\(H|0\\rangle = |0_x \\rangle\\), \\(H|1\\rangle = |1_x \\rangle\\). O pritaikę šiems Pauli-\\(Z\\) vartus randame: \\[\\begin{equation} Z|0_x \\rangle = |1_x \\rangle\\,,\\quad Z|1_x \\rangle = |0_x \\rangle\\,. \\tag{9.21} \\end{equation}\\] Kitaip tariant, fazės apvertimo klaida \\(\\{|0\\rangle , |1\\rangle\\}\\) baziniuose vektoriuose yra ne kas kita, kaip bito apvertimo klaida \\(\\{|0_x \\rangle , |1_x \\rangle\\}\\) baziniuose vektoriuose. Tai reiškia, kad atitinkamai transformavę 3 kubitų bito apvertimo kodą galime jį panaudoti norėdami aptikti ir taisyti fazės klaidas. Siųsdami kubitus per triukšmingą kvantinį kanalą, kuriame atsiranda fazės klaidos, kubito būseną \\(|\\psi\\rangle\\) koduojame dviem žingsniais. Pirmiausia, vėl „patrigubiname” bazinius vektorius: \\[\\begin{equation} |\\psi\\rangle = a|0\\rangle + b|1\\rangle \\rightarrow a|000\\rangle + b|111\\rangle\\,. \\tag{9.22} \\end{equation}\\] Tolesniame žingsnyje pritaikome Hadamardo transformacijas kiekvienam iš trijų kubitų: \\[\\begin{equation} |\\psi\\rangle_L = H^{\\otimes 3}\\big(a|000\\rangle + b|111\\rangle\\big) = a|0_x 0_x 0_x \\rangle + b|1_x 1_x 1_x \\rangle\\,. \\tag{9.23} \\end{equation}\\] 9.3 pav. pateikiame grandinę, iliustruojančią šio loginio kubito paruošimą. 9.3 pav. Loginė grandinė, paruošianti loginį kubitą, skirtą taisyti fazės klaidai Atsiradusi fazės klaida, pavyzdžiui, pirmajame kodo kubite, pakeis loginę būseną taip: \\[\\begin{equation} |\\psi\\rangle_L \\rightarrow a|1_x 0_x 0_x \\rangle + b|0_x 1_x 1_x \\rangle\\,. \\tag{9.24} \\end{equation}\\] Norėdami pritaikyti bito apvertimo klaidos aptikimo ir taisymo algoritmą, turime pirmiausiai šią būseną transformuoti atgal į \\(\\{|0\\rangle , |1\\rangle\\}\\) bazinius vektorius. Atlikę Hadamardo transformacijas pažeistai būsenai randame: \\[\\begin{equation} H^{\\otimes 3}\\big(a|1_x 0_x 0_x \\rangle + b|0_x 1_x 1_x \\rangle\\big) = a|100\\rangle + b|011\\rangle\\,. \\tag{9.25} \\end{equation}\\] Akivaizdu, kad šis fazės klaidų taisymo kodas turi identiškas charakteristikas bito apvertimo kodui, tad anksčiau pateikta analizė tinka ir čia. 9.5 Tolydžiosios klaidos Bendroje situacijoje 1 kubito klaidos gali kisti tolydžiai ir yra nusakomos Blocho vektoriaus posūkio operatoriais \\(R_x(\\theta)\\), \\(R_y(\\theta)\\) ir \\(R_z(\\theta)\\) aplink \\(x\\), \\(y\\) ir \\(z\\) ašis kampu \\(\\theta\\). Pritaikykime tolydžiąją bito apvertimo klaidą \\(R_x(\\theta)\\otimes I\\otimes I\\) pirmajam kubitui \\(|\\psi\\rangle_L\\) būsenoje 3 kubitų bito apvertimo taisymo kode: \\[\\begin{equation} R_{x}(\\theta)\\otimes I\\otimes I|\\psi \\rangle_L = \\cos(\\theta/2)\\big(a|000\\rangle + b|111\\rangle) - \\mathrm{i}\\sin(\\theta/2)\\big(a|100\\rangle + b|011\\rangle\\big)\\,. \\tag{9.26} \\end{equation}\\] Matome loginio kubito būseną, kuri yra klaidos nepaveiktos ir paveiktos būsenos superpozicijoje. Kad aptiktume klaidą, vėl galime taikyti \\(Z\\otimes Z\\otimes I\\) ir \\(Z\\otimes I\\otimes Z\\) operatorių matavimus naudodami identišką grandinę su dviem ancila kubitais. Tai atlikę randame: \\[\\begin{equation} \\cos(\\theta/2)\\big(a|000\\rangle + b|111\\rangle\\big)\\otimes|00\\rangle - \\mathrm{i}\\sin(\\theta/2)\\big(a|100\\rangle + b|011\\rangle\\big)\\otimes|11\\rangle\\,. \\tag{9.27} \\end{equation}\\] Ancilų nusakyta sindromo būsena \\(|00 \\rangle\\) yra supinta su loginio kubito būsena, kuriai neįvyko klaida. O štai \\(|11\\rangle\\) sindromo būsena yra supinta su kubitų būsena, kuriai įvyko bito apvertimo klaida. Kaip ir anksčiau, darome prielaidą, kad fizinis kubitas paveikiamas \\(R_x(\\theta)\\) klaidos nepriklausomai nuo kitų kubitų su tikimybe \\(p\\). Atlikę ancilų kubitų būsenų matavimą galime rasti sindromą \\(|00\\rangle\\) su tikimybe \\(p\\cos^2(\\theta/2)\\), dėl kurio loginio kubito būsena lieka nepažeista \\(|\\psi \\rangle_L = a|000\\rangle + b|111\\rangle\\). Sindromo būsena \\(|11\\rangle\\) randama su tikimybe \\(p\\sin^2(\\theta/2)\\), o po matavimo loginio kubito būsena tampa \\(X\\otimes I\\otimes I|\\psi\\rangle_L = a|100\\rangle + b|011\\rangle\\); tai nusako bito apvertimo klaidą. Klaidų tolydumą nusakantis faktorius \\(\\theta\\) atsiranda šalia amplitudžių ir paveikia tik tikimybes rasti pažeistą ir nepažeistą būsenas. Šiuo atveju, tikimybė rasti pažeistą būseną tampa \\(p \\rightarrow p\\sin^2(\\theta/2)\\). Atlikus ancilų kubitų matavimus \\(\\theta\\) faktorius iškrinta, o bendra loginių kubitų ir ancilų būsena lieka faktorizuojamoji. Radus \\(|a_1 a_2 \\rangle = |00\\rangle\\) sindromą imtis veiksmų nereikia, o štai radus \\(|a_1 a_2 \\rangle = |11\\rangle\\) pritaikomi \\(X\\otimes I\\otimes I\\) loginiai vartai, ištaisantys klaidą pirmame kubite \\((X\\otimes I\\otimes I)(X\\otimes I\\otimes I)|\\psi\\rangle_L \\otimes|11\\rangle = |\\psi\\rangle_L \\otimes|11\\rangle\\). Tai savo ruožtu demonstruoja itin svarbų teiginį, kad kvantinės klaidos gali būti efektyviai diskretizuojamos, nors pačios būsenos gali kisti ir tolydžiai. Tie patys metodai, taikomi taisyti diskrečiosioms kvantinėms klaidoms, kurių yra tik trys rūšys {\\(X\\), \\(Y\\), \\(Z\\)}, kartu ištaiso ir tolydžias klaidas. 9.6 Bendrieji klaidų taisymo principai Šiame poskyryje pateikiame bendruosius principus, kurie įvardija, kokias klaidas kodai gali ištaisyti, ir bendrą taisymo proceso principą. Vadinkime kubitų klaidas nusakantį unitarųjį operatorių \\(E\\). Klaidų operatorius, veikiantis \\(n\\)-kubitų registrą, yra sudarytas iš \\(n\\) tenzorinių Pauli operatorių sandaugų sekos \\({E \\in \\{I,X,Y,Z\\}}^{\\otimes n}\\). Kubitų bazinius vektorius koduojančias būsenas vadinkime \\(|i\\rangle_L\\). Pirma būtina sąlyga, norint užtikrinti klaidų taisymą, reikalauja, kad klaidų operatoriai, veikiantys skirtingas kodų būsenas, pakeistų jas į kitas, ortogonaliąsias, klaidų būsenas. Tai galime užrašyti glaustai: \\[\\begin{equation} \\langle i| E_a^{\\dagger} E_b |j\\rangle_L = 0\\,,\\,\\mathrm{jeigu}\\, i \\neq j\\,. \\tag{9.28} \\end{equation}\\] Jeigu skirtingų kodų būsenos \\(|i\\rangle_L\\) ir \\(|j\\rangle_L\\) klaidų operatoriais yra pakeičiamos į klaidų būsenas, kurios nėra ortogonalios kodų būsenoms ir kitoms klaidų būsenoms, jos nebegali būti patikimai atskirtos, ir todėl taisymas tampa neįmanomas. Šiuo atžvilgiu, klaidų operatoriai \\(E\\) transformuoja kodo būsenas iš kodo erdvės į vieną iš kodo erdvei ortogonalių klaidų būsenų poerdvių. Antroji sąlyga nusako, kad atliekant matavimą sindromui nustatyti gauta informacija negali atskleisti koduojamos kubitų būsenos. Informacijos atskleidimas bendrai paveikia kvantines būsenas ir atsitiktiniu būdu jas negrąžinamai pakeičia. Šią sąlygą galima glaustai užrašyti: \\[\\begin{equation} \\langle i|E_a^{\\dagger} E_b |i\\rangle_L = c_{ab}\\,. \\tag{9.29} \\end{equation}\\] Vertė \\(c_{ab}\\) negali priklausyti nuo būsenos \\(|i\\rangle_L\\), nes tai atskleistų apie ją informaciją. Matavimo rezultatas gali priklausyti tik nuo klaidų operatorių \\(E_a\\) ir \\(E_b\\). Kubito apvertimo ir fazės klaidų aptikimo stadijoje matėme, kad \\(Z\\otimes Z\\otimes I\\) ir \\(Z\\otimes I\\otimes Z\\) operatorių matavimai leidžia identifikuoti kubitų būsenų lyginumą, tačiau neatskleidžia informacijos, kokios tai būsenos, tai yra jų amplitudžių. Jeigu minėtos dvi sąlygos yra užtikrintos, tada \\(E_a\\) ir \\(E_b\\) priklauso ištaisomų klaidų operatorių rinkiniui, \\(\\varepsilon \\subseteq \\{ I,X,Y,Z\\}^{\\otimes n}\\). Siekdami iliustruoti bendrą klaidų taisymo principą, imkime išplėstinę sistemą, sudarytą iš \\(n\\) kubitų registro \\(|\\psi\\rangle\\), aplinkos sistemos būsenų \\(|e\\rangle\\) ir pradinio ancilos kubito būsenoje \\(|0\\rangle\\): \\[\\begin{equation} |\\Psi\\rangle = |\\psi\\rangle\\otimes|e\\rangle\\otimes|0\\rangle\\,. \\tag{9.30} \\end{equation}\\] Šioje stadijoje kubitų registras yra veikiamas klaidų operatoriaus \\(E_i\\) ir supinamas su aplinkos būsenomis. Toliau atliekame unitariąją transformaciją \\(U\\), supinančią ir ancilos kubitą: \\[\\begin{equation} U|\\Psi\\rangle = \\sum_{E_i \\in \\varepsilon} E_i|\\psi\\rangle\\otimes|e_i \\rangle\\otimes|a_i \\rangle\\,. \\tag{9.31} \\end{equation}\\] Siekiant identifikuoti ir atstatyti kodą, yra atliekama \\(U|\\Psi\\rangle\\) būsenos projekcija į vieną iš ortogonaliųjų klaidų poerdvių. Tai matėme bito ir fazės apvertimo klaidų taisyme, kuriuose ancilos kubitai yra supinami su klaidų būsenomis ir atliekamas projekcinis matavimas. Dėl tokios priežasties superpozicija yra sugriaunama ir ši būsena, su tam tikra tikimybe, pasikeičia į vieną iš galimų: \\[\\begin{equation} E_i|\\psi\\rangle\\otimes|e_i \\rangle\\otimes|a_i \\rangle\\,. \\tag{9.32} \\end{equation}\\] Atkreipiame dėmesį, kad šioje stadijoje kubitų registro būsena \\(E_i|\\psi\\rangle\\) yra nebesupinta nei su aplinkos, nei su ancilų sistemų būsenomis. Tad norint atstatyti koduotą būseną yra pritaikomas atvirkštinis klaidos operatorius \\(E_i^{\\dagger}\\), nes \\(E_i^{\\dagger}E_i|\\psi\\rangle = |\\psi\\rangle\\). 9.7 Kvantinė Hamingo riba Siekdami ištaisyti vieno tipo klaidą 1 kubito registre naudojome 3 kubitų kodą. Kyla natūralus klausimas, ar galima rasti kriterijų, pasakantį, kiek minimaliai reikia fizinių kubitų siekiant ištaisyti \\(n\\) kubitų dydžio registrą, kuriame atsiranda daugiausia \\(t\\) skaičius klaidų. Tai iš principo leistų ieškoti optimalaus kodo dydžio, neeikvojančio papildomų fizinių kubitų. Kvantinė Hamingo riba (angl. quantum Hamming bound) suteikia būdą tai įvertinti klasei kodų, kurie yra lietuviškai vadinami neišsigimusiais (angl. non-degenerate). Neišsigimusiuose koduose su kiekvienu skirtingu sindromu galima susieti unikalų kubitą, kuriame įvyko klaida, ir nusakyti klaidos tipą. Klasikiniuose koduose visos klaidos yra neišsigimusios, išsigimusios atsiranda išskirtinai kvantinėje terpėje. Platesnės analizės, apimančios išsigimusius kodus, šios knygos rašymo metu dar nėra, ir lieka išsiaiškinti, ar išsigimusieji kodai gali būti efektyvesni negu neišsigimusieji ir įveikti kvantinę Hamingo ribą. Siekdami išvesti Hamingo ribą pirmiausia įvertinsime, kiek dominančio kodo dydyje egzistuoja skirtingų klaidų. Pirmiausiai, egzistuoja \\(\\binom{n}{j}\\) skirtingų konfigūracijų, nusakančių, kuriuose \\(j\\) skaičiuje kubitų iš esamų \\(n\\) kubitų įvyko klaida. Čia \\(\\binom{n}{j} = n!/j!(n - j)!\\) yra kombinatorinis skaičius. Kiekvienam kubitui yra galimos trys skirtingos klaidos, nusakomos {\\(X\\), \\(Y\\), \\(Z\\)} operatoriais, tad skaičius \\(N(t)\\) klaidų iš viso yra: \\[\\begin{equation} N(t) = \\sum_{j = 0}^t 3^j\\binom{n}{j}\\,. \\tag{9.33} \\end{equation}\\] Suma indeksuojama skaičiais \\(j\\) ir kinta nuo 0 (nėra klaidų) iki didžiausio skaičiaus klaidų \\(t\\), kai \\(t &lt; n\\). Pavyzdžiui, \\(\\binom{3}{2}\\) nusako, kad trijuose kubituose galimos dvi klaidos. Dviejų klaidų išsidėstymo skaičius tarp trijų kubitų, neskaičiuojant skirtingo tipo klaidų, yra iš viso trys (\\(k_1{-}k_2\\), \\(k_1{-}k_3\\), \\(k_2{-}k_3\\)). Atsižvelgdami į tai, kad kiekviename iš kubitų gali būti viena iš trijų skirtingų klaidų, randame \\(N(2) = 3^2\\times 3 = 27\\) galimų klaidų konfigūracijų. Sakykime, kad turime \\(k\\) skaičių loginių kubitų, kurie yra koduojami naudojant \\(n\\) skaičių fizinių kubitų. Loginiai kubitai dengia \\(2^k\\) dimensijų vektorių erdvę, ir visos jos būsenos gali būti išreikštos \\(2^k\\) baziniais kodo vektoriais \\(|i\\rangle_L\\). Pavyzdžiui, vieno loginio kubito Hilberto erdvė yra 2 dimensijų ir dengiama \\(|0\\rangle_L\\) bei \\(|1\\rangle_L\\). Ankstesniame poskyryje minėjome, kad taisytinų klaidų pirmoji sąlyga reikalauja, jog klaidų operatoriai, veikdami kodo būsenas, pakeistų jas į viena kitai ortogonalias klaidų būsenas. Taip pat kodo būsenos, paveiktos skirtingo klaidų operatoriaus, \\(E_a\\), turi būti ortogonalios toms paveiktoms \\(E_b\\). Tad kiekvienai skirtingai klaidai turi būti priskiriamas \\(2^k\\) dimensijų poerdvis. Kadangi yra \\(N(t)\\) skaičius skirtingų klaidų konfigūracijų (ir todėl toks pat skaičius klaidų operatorių), erdvės dimensija, talpinanti visas ortogonaliąsias klaidų būsenas (įskaitant klaidų nepažeistą būseną), turi būti bent \\(N(t)2^{k}\\) dydžio. Tai nusako minimalų \\(n\\) fizinių kubitų, koduojančių \\(k\\) loginius kubitus, dimensijos dydį \\(2^n\\). Hamingo riba randama: \\[\\begin{equation} \\sum_{j = 0}^t 3^j \\binom{n}{j}2^k \\leq 2^n\\,. \\tag{9.34} \\end{equation}\\] Pavyzdžiui, \\(k\\) loginių kubitų, kuriems leidžiama tik viena (\\(t = 1\\)) bendrojo tipo kvantinė klaida, ši nelygybė yra: \\[\\begin{equation} (1 + 3n)2^k \\leq 2^n\\,. \\tag{9.35} \\end{equation}\\] Galima patikrinti, kiek reikia minimaliai fizinių kubitų siekiant koduoti 1 loginį kubitą, kuriam leidžiama viena bendrojo tipo klaida. Šiuo atveju \\(k = t = 1\\) ir Hamingo riba nusako, kad \\(n = 5\\) suteikia lygybę. Tad neegzistuoja neišsigimusis kodas, kuris, koduodamas vieną loginį kubitą mažiau nei penkiuose fiziniuose kubituose, galėtų apsaugoti nuo visų galimų klaidų viename kubite. Kadangi ne visi kodai yra neišsigimusieji, kvantinę Hamingo ribą galima taikyti veikiau kaip pirminį įvertinimą. Egzistuoja ir kitų kvantinių kodų ribų apibrėžimų, pavyzdžiui, kvantinė Singltono riba (angl. quantum Singleton bound) tinka abejoms kodų klasėms. Jos įrodymo čia nepateiksime, tačiau nelygybė yra: \\[\\begin{equation} n - k \\geq 4t\\,. \\tag{9.36} \\end{equation}\\] Simboliai \\(n\\) ir \\(k\\) nusako fizinių ir loginių kubitų skaičių, atitinkamai, taip pat didžiausią klaidų paveiktų kubitų skaičių \\(t\\). Matome, kad mažiausias kubitų skaičius, kai \\(k = t = 1\\), yra \\(n = 5\\) ir atitinka Hamingo ribą neišsigimusiems kodams. Šis optimalus kodas gali būti užrašomas \\([n, k, t] = [5, 1, 1]\\). 9.8 Šoro 9 kubitų kodas Šoro 9 kubitų kodas yra vienas iš pirmųjų atrastų kodų, leidžiančių ištaisyti bet kuriame iš 9 kubitų vieną bendriausio tipo kvantinę klaidą. Taikant viršuje minėtą susitarimą, tai formaliai yra \\([n, k, t] = [9, 1, 1]\\) kodas. Šoro kodas naudoja dviejų lygių konkatenaciją. Pirmajame žingsnyje įvykdomas 3 kubitų kodavimas, naudojamas apsaugoti kubitus nuo fazės apvertimo klaidos, \\(|0\\rangle \\rightarrow |0_x 0_x 0_x \\rangle\\), \\(|1\\rangle \\rightarrow |1_x 1_x 1_x \\rangle\\). Antrajame žingsnyje kiekvienas iš šių 3 kubitų yra toliau koduojamas dar 3 kubitais, apsaugant juos nuo bito apvertimo klaidos: \\[\\begin{equation} |0_x \\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} \\rightarrow \\frac{|000\\rangle + |111\\rangle}{\\sqrt{2}}\\,;\\quad |1_x \\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}} \\rightarrow \\frac{|000\\rangle - |111\\rangle}{\\sqrt{2}}\\,. \\tag{9.37} \\end{equation}\\] Bendroje loginio kubito būsenoje \\(|\\psi\\rangle_L = a|0\\rangle_L + b|1\\rangle_L\\) baziniai vektoriai yra: \\[\\begin{align} |0\\rangle_L = &amp; \\frac{1}{\\sqrt{8}}\\big(|000\\rangle + |111\\rangle\\big) \\otimes\\big(|000\\rangle + |111\\rangle\\big) \\otimes\\big(|000\\rangle + |111\\rangle\\big)\\nonumber\\\\ \\equiv &amp; |+\\rangle\\otimes|+\\rangle\\otimes|+\\rangle\\,;\\tag{9.38}\\\\ |1\\rangle_L = &amp; \\frac{1}{\\sqrt{8}}\\big(|000\\rangle - |111\\rangle\\big) \\otimes\\big(|000\\rangle - |111\\rangle\\big) \\otimes\\big(|000\\rangle - |111\\rangle\\big)\\nonumber\\\\ \\equiv &amp; |-\\rangle\\otimes|-\\rangle\\otimes|-\\rangle\\,.\\tag{9.39} \\end{align}\\] Kubitus sugrupavome į tris blokus ir, siekdami supaprastinti simboliką, blokus pervadinome atitinkamai \\(|+\\rangle\\) ir \\(|-\\rangle\\). Grandinė atliekanti kodo paruošimą pateikta 9.4 pav. 9.4 pav. Šoro 9 kubitų kodo loginio kubito paruošimas Kaip ir 3 kubitų kode, aptikti atsirandančioms bito apvertimo klaidoms pasitelkiami nelokalūs matavimai. Sakykime, kad atsiranda bito apvertimo klaida pirmojo bloko pirmame kubite, \\(|+\\rangle \\rightarrow \\big(|100\\rangle + |011\\rangle\\big)\\). Klaidos aptikimui pirmajame bloke taikome \\(Z_1\\otimes Z_2\\) ir \\(Z_1\\otimes Z_3\\) matavimus pasitelkdami du ancilų kubitus. Čia, supaprastindami simboliką, praleidome vienetinių operatorių \\(I\\) rašymą, tad \\(Z_1\\otimes Z_2 = Z\\otimes Z\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\) ir \\(Z_1\\otimes Z_3 = Z\\otimes I\\otimes Z\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\). Antrajame ir trečiajame bloke klaidos aptikimui analogiškai naudojamos \\(Z_4\\otimes Z_5\\) ir \\(Z_4\\otimes Z_6\\), taip pat \\(Z_7\\otimes Z_8\\) ir \\(Z_7\\otimes Z_9\\) operatorių poros, kurių vertės įrašomos į dar dvi poras ancilų kubitų. Tai leidžia unikaliai nustatyti, kuriame iš 9 kubitų įvyko bito apvertimo klaida, ir ją ištaisyti pritaikius atitinkamam kubitui Pauli-\\(X\\) loginius vartus. Jeigu atsiranda fazės klaida, pavyzdžiui, pirmojo bloko viename iš kubitų, šio bloko būsena pakinta taip: \\[\\begin{align} |0\\rangle_L : &amp; \\quad |000\\rangle + |111\\rangle\\rightarrow |000\\rangle - |111\\rangle\\,;\\tag{9.40}\\\\ |1\\rangle_L : &amp; \\quad |000\\rangle - |111\\rangle\\rightarrow |000\\rangle + |111\\rangle\\,.\\tag{9.41} \\end{align}\\] Atkreipiame dėmesį, kad nesvarbu, kuris iš trijų kubitų bloke patiria fazės klaidą, to bloko būsena pasikeičia lygiai taip pat. Tad identifikuoti, kuris kubitas patyrė fazės klaidą, neįmanoma, ir dėl to Šoro kodas yra formaliai išsigimęs. Įvykus klaidai pradinė būsena \\(|\\psi\\rangle_L\\) pasikeičia taip: \\[\\begin{equation} |\\psi\\rangle_L \\rightarrow a|-\\rangle\\otimes|+\\rangle\\otimes|+\\rangle + b|+\\rangle\\otimes|-\\rangle\\otimes|-\\rangle\\,. \\tag{9.42} \\end{equation}\\] Vietoj pavienių kubitų bloke palyginimo, kaip daroma aptinkant bito apvertimo klaidą, fazės apvertimo klaidos aptikimui tarpusavyje palyginami patys blokai. Tam atlikti pasitelkiame irgi du ancilų kubitus, į kuriuos užrašomi, šiuo atveju, \\(X_1\\otimes X_2\\otimes X_3\\otimes X_4\\otimes X_5\\otimes X_6\\) ir \\(X_1\\otimes X_2\\otimes X_3\\otimes X_7\\otimes X_8\\otimes X_9\\) operatorių matavimų rezultatai (praleidžiame vienetinių operatorių \\(I\\) rašymą likusiems kubitams). Kad tai būtų lengviau suprasti, atkreipiame dėmesį, jog Šoro kodo būsenos \\(|+\\rangle\\otimes|+\\rangle\\otimes|+\\rangle\\) ir \\(|-\\rangle\\otimes|-\\rangle\\otimes|-\\rangle\\) yra šių operatorių tikriniai vektoriai su tikrinėmis vertėmis +1. Galime išskaidyti šias tikrines vertes į dviejų pavienių blokų tikrinių verčių sandaugas. Naudodami pirmąjį bloką kaip pavyzdį matome, kad individualių blokų būsenos \\(|+\\rangle\\) ir \\(|-\\rangle\\) yra trijų Pauli-\\(X\\) tenzorių sandaugos operatorių tikriniai vektoriai su tikrinėmis vertėmis \\(\\lambda = 1\\) ir \\(\\lambda = -1\\), atitinkamai: \\[\\begin{align} X_1\\otimes X_2\\otimes X_3\\big(|000\\rangle + |111\\rangle\\big ) = &amp; |000\\rangle + |111\\rangle = |+\\rangle\\,;\\tag{9.43}\\\\ X_1\\otimes X_2\\otimes X_3\\big(|000\\rangle - |111\\rangle\\big ) = &amp; -\\big(|000\\rangle - |111\\rangle) = - |-\\rangle\\,.\\tag{9.44} \\end{align}\\] Tad bet kurių dviejų blokų būsenų, nepaveiktų klaidos, tikrinių verčių sandauga yra visada +1. Klaidų aptikimo procese, vadindami \\(X_1\\otimes X_2\\otimes X_3\\), \\(X_4\\otimes X_5\\otimes X_6\\) ir \\(X_7\\otimes X_8\\otimes X_9\\) operatorių, veikiančių kiekvieną iš trijų kubitų blokų, tikrines vertes atitinkamai \\(\\lambda_1\\), \\(\\lambda_2\\), \\(\\lambda_3\\), užrašysime jų porų sandaugas \\(\\lambda_1 \\lambda_2\\) ir \\(\\lambda_1 \\lambda_3\\) į du ancilų kubitus. Pirmasis minėtas operatorius patikrina pirmą ir antrą blokus, o antrasis – pirmą ir trečią blokus. Jeigu viename iš blokų įvyksta fazės klaida, tikrinė vertė pasikeičia į -1 ir todėl tikrinių verčių poros sandauga tampa -1. Norėdami realizuoti klaidų aptikimo procesą kvantinėje grandinėje, pirmiausiai Pauli-\\(X\\) operatorius perrašysime \\(X = HZH\\). Kad įvykdytume \\(X\\) operatorių matavimus, kiekvienam kubitui atliekame Hadamardo transformacijas \\(H^{\\otimes 9}\\) ir Pauli-\\(Z\\) matavimus, pasitelkdami \\(CNOT\\) vartus ir ancilos kubitą. Pirmų dviejų blokų palyginimui matavimas \\(Z_1\\otimes Z_2\\otimes Z_3\\otimes Z_4\\otimes Z_5\\otimes Z_6\\) užrašomas ancilos būsenoje \\(|a_1 \\rangle = |k_1\\oplus k_2\\oplus k_3\\otimes k_4\\oplus k_5\\oplus k_6 \\rangle\\) naudojant \\(\\mod(2)\\) bitų sudėtį. Taip randame \\(|a_1 \\rangle = |0\\rangle\\), jeigu dviejų blokų būsenos yra vienodos, ir \\(|a_1 \\rangle = |1\\rangle\\), jeigu jos skiriasi. Tai savo ruožtu atspindi \\(X_1\\otimes X_2\\otimes X_3\\otimes X_4\\otimes X_5\\otimes X_6\\) operatoriaus \\(\\pm 1\\) tikrines vertes. Tas pats procesas atliekamas su pirmojo ir trečiojo bloko matavimais naudojant \\(Z_1\\otimes Z_2\\otimes Z_3\\otimes Z_7\\otimes Z_8\\otimes Z_9\\). Abiejų matavimų rezultatas užrašomas į dviejų ancilų kubitų būsenas \\(|a_1 a_2 \\rangle\\), o standartinis Pauli-\\(Z\\) matavimas leidžia unikaliai nusakyti, kuriame bloke įvyko fazės klaida. Pavyzdžiui, fazės klaida loginio kubito pirmame bloke bus nusakyta šia bendra būsena: \\[\\begin{equation} \\big(a|-\\rangle\\otimes|+\\rangle\\otimes|+\\rangle + b|+\\rangle\\otimes|-\\rangle\\otimes|-\\rangle\\big)\\otimes|11\\rangle\\,. \\tag{9.45} \\end{equation}\\] Fazės klaida pirmajame bloke ištaisoma pritaikius \\(Z_1\\otimes Z_2\\otimes Z_3\\) loginius vartus. Galiausiai atliekami dar vieni Hadamardo vartai \\(H^{\\otimes 9}\\) visiems kubitams siekiant atstatyti būsenas į \\(|+\\rangle\\) ir \\(|-\\rangle\\) kodų formą, o ancilos grąžinamos į \\(|00 \\rangle\\). Šoro kodas gali ištaisyti bendriausio tipo klaidą. Tai išplaukia iš šio skyriaus 9.2 poskyryje pateikto įrodymo, kad visas klaidas galima išreikšti Pauli operatorių \\(\\{I, X, Y, Z\\}\\) ir jų tenzorinių sandaugų tiesinėmis kombinacijomis. Todėl gebant taisyti \\(X\\) (bito apvertimo) ir \\(Z\\) (fazės apvertimo) klaidas, Šoro kode automatiškai galima taisyti ir šių dviejų klaidų kombinaciją, \\(XZ = -\\mathrm{i}Y.\\) Šoro kodas bus efektyvus, jeigu atsiranda ne daugiau nei viena klaida 9 kubituose. Tikimybė, kad siunčiant loginį kubitą per triukšmingą kanalą nė vienas fizinis kubitas nebus pažeistas, yra \\((1 - p)^9\\). Čia \\(p\\) nusako tikimybę, kad fizinis kubitas patirs klaidą. Tikimybė, kad Šoro kode įvyks viena klaida, yra \\(9p(1 - p)^8\\), ir kodas leidžia ją ištaisyti. Tad dvi ar daugiau klaidų atsitiks su tikimybe \\(1 - 9p(1 - p)^8 - (1 - p)^9 \\approx 36p^2\\), jeigu \\(p\\) yra itin mažas. Palyginus su pavieniu fizinio kubito siuntimu, nepataisomų klaidų tikimybės susilygina, kai \\(p \\approx 0.032,\\) ir Šoro kodas suteikia didėjantį pranašumą toliau mažėjant \\(p\\). 9.9 Kodų stabilizatoriai Iki šiol analizavome klaidų taisymo kodus pradėdami nuo kodų būsenų. Idealiai, norėtume turėti sisteminį receptą, leidžiantį sugeneruoti kodą su mus dominančiomis savybėmis – fizinių ir loginių kubitų skaičiumi, ištaisomų klaidų skaičiumi ir juose naudojamais operatoriais aptikti ir taisyti klaidas. Kodų stabilizatorių (angl. code stabilizers) formalizmas atlieka šią funkciją ir yra plačiai taikomas kvantinėje kompiuterijoje. Egzistuoja taisyklės, kaip stabilizatorių kodams konstruoti kvantines grandines, paruošiančias kodų būsenas, aptinkančias ir taisančias klaidas, taip pat leidžiančias lengviau formuluoti klaidoms atsparius skaičiavimus. Kodų stabilizatorių algoritmai gali būti realizuojami vien tik Klifordo grupės loginiais vartais {\\(H\\), \\(S\\), \\(cX\\)}, todėl jų veikimą galima efektyviai modeliuoti ir testuoti klasikiniais kompiuteriais. Toliau glaustai pristatome šios plačios kodų grupės įvadinius principus. Kodų stabilizatorių formalizmas yra pagrįstas ne kvantinių būsenų, o unitariųjų operatorių analize pasitelkiant grupių teoriją (angl. group theory). Sakoma, kad būsena \\(|\\psi\\rangle\\) yra stabilizuojama operatoriaus \\(K\\), jeigu ji yra šio operatoriaus tikrinis vektorius su +1 tikrine verte: \\[\\begin{equation} K|\\psi \\rangle = |\\psi\\rangle\\,. \\tag{9.46} \\end{equation}\\] Pavyzdžiui, 1 kubito būsena \\(|0\\rangle\\) yra stabilizuojama Pauli-\\(Z\\) operatoriaus, nes \\(Z|0\\rangle = |0\\rangle\\). Šoro 9 kubitų kodas yra taip pat stabilizatorių klasės kodas. Aštuoni operatoriai \\(Z_1\\otimes Z_2\\), \\(Z_1\\otimes Z_3\\), \\(Z_4\\otimes Z_5\\), \\(Z_4\\otimes Z_6\\), \\(Z_7\\otimes Z_8\\), \\(Z_7\\otimes Z_9\\) bei \\(X_1\\otimes X_2\\otimes X_3\\otimes X_4\\otimes X_5\\otimes X_6\\) ir \\(X_1\\otimes X_2\\otimes X_3\\otimes X_7\\otimes X_8\\otimes X_9\\) yra jo stabilizatoriai. Apžvelgdami operatorių savybes stabilizuojančių \\(n\\)-kubitų būsenas, pirmiausiai apibūdiname 1 kubito Pauli grupę \\(\\mathcal{P}\\), kuri yra sudaryta iš Pauli operatorių: \\[\\begin{equation} \\mathcal{P} = \\{\\pm I\\,, \\pm \\mathrm{i}I\\,, \\pm X\\,, \\pm \\mathrm{i}X\\,, \\pm Y, \\pm \\mathrm{i}Y\\,, \\pm Z, \\pm \\mathrm{i}Z\\, \\}\\,. \\tag{9.47} \\end{equation}\\] Pauli elementų rinkinys (Pauli operatoriai kartu su juos dauginančiais skaičiais {\\(\\pm 1\\), \\(\\pm \\mathrm{i}\\)}) formuoja grupę operatorių sandaugos operacijų atžvilgiu. Pauli grupė pratesiama \\(n\\) kubitų sistemoms naudojant jos elementų \\(n\\) tenzorių sandaugą, \\(\\mathcal{P}^{\\otimes n}\\). Galima parodyti, kad visi Pauli grupės elementai yra tarpusavyje arba komutatyvūs, arba antikomutatyvūs. Primename, kad du komutatyvūs operatoriai \\(A\\) ir \\(B\\) tenkina \\(AB=BA\\), ir tai standartiškai užrašoma \\(\\lbrack A,B\\rbrack = 0\\). Tačiau \\(A\\) ir \\(B\\) yra antikomutatyvūs, jeigu sandaugoje sukeitus jų vietas atsiranda minuso ženklas, \\(AB = -BA\\). Tai išreiškiama \\(\\{A, B\\} = AB + BA = 0\\). \\(N\\) kubitų stabilizatorių būsena \\(|\\psi\\rangle\\) yra nusakoma Pauli grupės \\(\\mathcal{P}^{\\otimes n}\\) operatorių pogrupe \\(\\mathcal{G}^{\\otimes n}\\), kurios visi elementai, vadinkime juos \\(K_i\\), yra tarpusavyje komutatyvūs. Operatorių pogrupės \\(\\mathcal{G}^{\\otimes n}\\) savybes galima glaustai užrašyti taip: \\[\\begin{equation} \\mathcal{G}^{\\otimes n} = \\big\\{K_i|\\psi\\rangle = |\\psi\\rangle\\,, \\lbrack K_i,K_j \\rbrack = 0\\,, \\forall(i,j)\\big\\} \\subset \\mathcal{P}^{\\otimes n}\\,. \\tag{9.48} \\end{equation}\\] Stabilizatorių tarpusavio komutatyvumas užtikrina, kad ir jų sandauga \\(K_1 K_2 K_3\\cdots\\) taip pat stabilizuoja \\(|\\psi\\rangle\\). Praktiškai taip pat reikalaujame, kad stabilizatorių rinkinyje visi operatoriai būtų tiesiškai nepriklausomi – negali būti išreikšti kitų rinkinio stabilizatorių sandauga. Stabilizatoriai \\(K_i\\) efektyviai užfiksuoja dalį \\(n\\) kubitų \\(2^n\\) dimensijų vektorių erdvės, kitaip tariant, jos poerdvį, kuriame atliekamas būsenų kodavimas. Imkime 2 kubitų pavyzdį, kai naudojamas Belo bazinių vektorių rinkinys {\\(|\\chi^{+}\\rangle\\), \\(|\\chi^{-}\\rangle\\), \\(|\\eta^{+}\\rangle\\), \\(|\\eta^{-}\\rangle\\)}. Galima lengvai patikrinti, kad operatorius \\(X\\otimes X\\) unikaliai stabilizuoja \\(|\\chi^{+}\\rangle\\) ir \\(|\\eta^{+}\\rangle\\) būsenas. Tad, jeigu naudosime poerdvį, stabilizuotą \\(X\\otimes X\\), šias dvi 2 kubitų ortogonaliąsias būsenas galime naudoti formuodami vieną loginį kubitą: \\[\\begin{equation} |0\\rangle_L = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle + |11\\rangle\\big)\\quad \\mathrm{ir}\\quad |1\\rangle_L = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle + |10\\rangle\\big)\\,. \\tag{9.49} \\end{equation}\\] Taip 4 dimensijų erdvę sumažinome iki 2 dimensijų, kuri nusako vieno kubito būsenas. Šioje erdvėje operatorius \\(Z\\otimes Z\\) leidžia atskirti \\(|0\\rangle_L\\) ir \\(|1\\rangle_L\\) vieną nuo kitos, nes \\(Z\\otimes Z|0\\rangle_L = |0\\rangle_L\\) ir \\(Z\\otimes Z|1\\rangle_L = -|1\\rangle_L\\). Jis atlieka loginio Pauli-\\(Z\\) rolę, žymimą su brūkšniu, \\(\\bar{Z} = Z\\otimes Z\\). Žinoma, galėtume pasirinkti ir \\(Z\\otimes Z\\) operatorių, stabilizuojantį \\(|\\chi^{+}\\rangle\\) ir \\(|\\chi^{-}\\rangle\\) būsenas, ir naudoti jas formuodami loginį kubitą. Tada loginis Pauli-\\(Z\\) būtų \\(\\bar{Z} = X\\otimes X\\) ir leistų atskirti šio loginio kubito \\(|0\\rangle_L\\) ir \\(|1\\rangle_L\\) būsenas. Bendrai, jeigu \\(n\\) kubitų koduoja \\(k\\) loginių kubitų, tada yra \\(k\\) loginių Pauli-\\(Z\\), \\(n - k\\) stabilizatorių, o loginių kubitų vektorių erdvės dimensija \\(2^{n - k}\\). Toks stabilizatorių kodas yra glaustai indikuojamas skliausteliuose \\([n, k]\\). Kiekvienas stabilizatorius \\(K_i\\) yra ermitinis ir tuo pačiu unitarusis operatorius, todėl gali turėti dvi tikrines vertes, \\(\\lambda = 1\\) ir \\(\\lambda = -1\\). Klaidų operatoriai \\(\\{E_i\\}\\) taip pat priklauso Pauli grupės operatoriams, \\(\\mathcal{P}^{\\otimes n}\\). Todėl bet kuris \\(E\\) gali būti komutatyvusis arba antikomutatyvusis su tam tikru stabilizatoriumi \\(K\\) dominančioje \\(n\\) kubitų erdvėje. Jeigu \\(E\\) ir \\(K\\) yra komutatyvieji, tada: \\[\\begin{equation} KE|\\psi\\rangle = EK|\\psi\\rangle = E|\\psi\\rangle\\,. \\tag{9.50} \\end{equation}\\] Tad klaidos operatorius išsaugo \\(K\\) stabilizatoriaus +1 tikrinę vertę. Tačiau, jeigu \\(E\\) ir \\(K\\) yra antikomutatyvieji: \\[\\begin{equation} KE|\\psi\\rangle = - EK|\\psi\\rangle = - E|\\psi\\rangle\\,. \\tag{9.51} \\end{equation}\\] Tai galime interpretuoti kaip stabilizatorių \\(K\\), veikiantį klaidos paveiktą \\(E|\\psi\\rangle = |\\psi\\rangle_E\\) kodo būseną, \\(K|\\psi\\rangle_E = - |\\psi\\rangle_E\\); tai galiausiai pakeičia stabilizatoriaus tikrinę vertę į -1. Ši tikrinė vertė gali būti aptikta atlikus stabilizatoriaus matavimą siekiant taisyti klaidas. Kaip matėme Šoro 9 kubitų kode, jo stabilizatorių porų kombinacijų matavimas ir rastų tikrinių verčių kombinacijos \\(\\{ \\pm 1, \\pm 1 \\}\\) leidžia identifikuoti klaidą. Mat dalis kodo stabilizatorių yra antikomutatyvieji su specifiniais klaidų operatoriais, ir jų unikali kombinacija leidžia nustatyti, kokie klaidų operatoriai veikė kodo būsenas. Formaliai \\(h\\) stabilizatorių turi \\(2^h\\) skirtingas \\(\\{\\lambda_i, \\lambda_j\\}\\) kombinacijas ir todėl gali identifikuoti tokį skaičių skirtingų klaidų būsenų (įskaitant nepažeistą būseną). Pavyzdžiui, 1 loginio kubito, apsaugoto nuo vienos bendriausios klaidos 5 kubitų kode \\([5,1,1]\\), Hamingo riba yra \\(1 + 3 \\cdot 5 \\geq 2^4\\). Keturi stabilizatoriai identifikuoja \\(2^4= 16\\) ortogonaliuosius 2 dimensijų klaidų būsenų poerdvius ir todėl suteikia lygybę Hamingo riboje. Šio optimalaus 5 kubitų kodo stabilizatoriai yra: \\[\\begin{align} K_1 = &amp; X\\otimes Z\\otimes Z\\otimes X\\otimes I\\,;\\tag{9.52} \\\\ K_2 = &amp; I\\otimes X\\otimes Z\\otimes Z\\otimes X\\,;\\tag{9.53} \\\\ K_3 = &amp; X\\otimes I\\otimes X\\otimes Z\\otimes Z\\,;\\tag{9.54} \\\\ K_4 = &amp; Z\\otimes X\\otimes I\\otimes X\\otimes Z\\,.\\tag{9.55} \\end{align}\\] Atkreipiame dėmesį, kad cikliškai pakeistas operatorius \\(K_5 = Z\\otimes Z\\otimes X\\otimes I\\otimes X\\) nėra tiesiškai nepriklausomas, nes gali būti išreikštas sandauga, \\(K_5 = K_1 K_2 K_3 K_4\\). Penktasis operatorius, \\(\\bar{Z} = Z\\otimes Z\\otimes Z\\otimes Z\\otimes Z\\), yra komutatyvus su keturiais šio kodo stabilizatoriais ir atlieka loginio Pauli-\\(Z\\) vaidmenį. Taip pat yra apibūdinamas ir loginis Pauli-\\(X\\) operatorius, \\(\\bar{X} = X\\otimes X\\otimes X\\otimes X\\otimes X\\), kuris konvertuoja logines būsenas vieną tarp kitos \\(\\bar{X}|0\\rangle_L = |1\\rangle_L\\), \\(\\bar{X}|1\\rangle_L = |0\\rangle_L\\). Toliau panagrinėkime, kaip sugeneruoti kodo būsenas iš pateiktų stabilizatorių rinkinio. Kodo stabilizatoriai bei loginiai Pauli-\\(Z\\) yra unitariniai ir kartu ermitiniai operatoriai, tad turi dvi tikrines vertes, +1 ir -1. Taikant spektrinę dekompoziciją, tokį \\(n\\) kubitų būsenas veikiantį operatorių \\(K\\) galima užrašyti: \\[\\begin{equation} K = \\sum_{\\lambda} \\lambda P(\\lambda) = P(1) - P(-1)\\,. \\tag{9.56} \\end{equation}\\] Pasitelkdami projekcinius operatorius \\(P(1)\\) ir \\(P(-1)\\) į vektorių poerdvius, asocijuotus su +1 ir -1 tikrinėmis vertėmis, atitinkamai, bei jų pilnumo savybę \\(P(1) + P(-1) = I\\), randame: \\[\\begin{equation} P(1) = \\frac{I + K}{2}\\,,\\quad P(-1) = \\frac{I - K}{2}\\,. \\tag{9.57} \\end{equation}\\] Bet kokią \\(n\\) kubitų būseną \\(|\\psi\\rangle\\) galima išreikšti jos projekcijų į \\(\\pm 1\\) stabilizatoriaus \\(K\\) poerdvių būsenas superpozicija: \\[\\begin{equation} |\\psi\\rangle = P(1)|\\psi\\rangle + P(-1)|\\psi\\rangle\\,. \\tag{9.58} \\end{equation}\\] Norint paruošti stabilizatorių rinkinio kodo būseną \\(|0\\rangle_L\\), užduotis yra atlikti pradinės registro būsenos, standartiškai \\(|0\\rangle^{\\otimes n}\\), projekciją į \\(h\\) skaičiaus stabilizatorių rinkinio bendrą +1 poerdvį bei +1 loginio Pauli-\\(Z\\). Jeigu, sakykime, turime tris tarpusavyje komutatyvius ermitinius operatorius \\(K_1, K_2, K_3\\), tada projekcinis operatorius į jų bendrą +1 poerdvį, nusakytą \\(P(1)\\), bus atitinkamai trijų projekcinių operatorių sandauga, \\(P(1) = P_1(1)P_2(1)P_3(1)\\). Norint paruošti \\(|1\\rangle_L\\), projekcija atliekama į +1 stabilizatorių poerdvį bei loginio Pauli-\\(Z\\) -1 poerdvį. Optimalaus \\([5, 1, 1]\\) kodo atveju pradedame nuo \\(|00000\\rangle\\) ir \\(|11111\\rangle\\) registro būsenų, kurios yra \\(\\bar{Z}\\) tikriniai vektoriai su \\(\\pm 1\\) tikrinėmis vertėmis, atitinkamai. Kodo būsenas (normuotąsias) randame atlikdami projekciją į bendrą keturių stabilizatorių +1 poerdvį: \\[\\begin{align} |0\\rangle_L = &amp; \\frac{1}{4}(I + K_1)\\otimes(I + K_2)\\otimes(I + K_3)\\otimes(I + K_4)|00000\\rangle\\,;\\tag{9.59}\\\\ |1\\rangle_L = &amp; \\frac{1}{4}(I + K_1)\\otimes(I + K_2)\\otimes(I + K_3)\\otimes(I + K_4)|11111\\rangle\\,.\\tag{9.60} \\end{align}\\] Hadamardo testo kvantinė grandinė (žr. 6.7.1 poskyrį) gali atlikti norimą projekciją. Atkreipiame dėmesį, kad galutinė Hadamardo testo būsena \\(|\\chi\\rangle\\) turi ieškomąją formą: \\[\\begin{equation} \\begin{aligned} |\\chi\\rangle = &amp; |0\\rangle\\otimes\\left(\\frac{I + K}{2}\\right)|\\psi\\rangle + |1\\rangle\\otimes\\left(\\frac{I - K}{2}\\right)|\\psi\\rangle \\\\ = &amp; |0\\rangle\\otimes P(1)|\\psi\\rangle + |1\\rangle\\otimes P(-1)|\\psi\\rangle\\,. \\end{aligned} \\tag{9.61} \\end{equation}\\] Atlikus ancilos kubito (pirmasis registras) Pauli-\\(Z\\) matavimą, pagal tai, ar bus rasta \\(|0\\rangle,\\) ar \\(|1\\rangle\\) būsena, antrojo kubito būsenai \\(|\\psi\\rangle\\) bus atlikta projekcija į \\(K\\) operatoriaus +1 arba -1 tikrinių verčių poerdvį, atitinkamai. Šis metodas yra elementariai praplečiamas \\(n\\) kubitų sistemai pasitelkiant daugiau ancilų kubitų, o \\(K\\) gali nusakyti kodų stabilizatorių rinkinio bendrąjį matavimą. Tad jeigu randama +1 ancilos tikrinė vertė, pradinė būsena yra konvertuojama į norimo stabilizatorių kodo būseną. Radus -1 tikrinę vertę, pasitelkus ancilų matavimus atliekama klaidų taisymo stadijai identiška grandinė, konvertuojanti šią būseną į +1 tikrinės vertės būseną. Taip paruošus, pavyzdžiui, loginį \\(|0\\rangle_L\\), kode apibrėžtu loginiu Pauli-\\(X\\) galima konvertuoti \\(|0\\rangle_L\\) į \\(|1\\rangle_L\\), \\(\\bar{X}|0\\rangle_L = |1\\rangle_L\\). 9.10 Klaidoms atsparus skaičiavimas Iki šiol pristatytuose klaidų protokoluose darėme prielaidą, kad klaidos atsiranda tik tada, kai nėra atliekami loginiai vartai ar kubitų matavimai, ancilų kubitai patys nepatiria klaidų, ir kad loginiai vartai yra absoliučiai tikslūs. Šios prielaidos nėra realistinės. Klaidoms atsparus skaičiavimas yra kvantinių grandinių dizaino metodologija, kuri kartu su klaidų taisymo algoritmais leidžia sėkmingai įvykdyti skaičiavimus, kai visi skaičiavimo elementai ir atmintyje laikomi kubitai gali patirti klaidas. Klaidoms atsparus skaičiavimas yra pagrįstas klaidų sklidimo užkirtimu. Galime įvardyti du pagrindinius šaltinius, kurie leidžia pasklisti klaidoms kvantinėse grandinėse. Pirmasis – tai loginiai vartai. Akivaizdu, kad loginiai vartai, veikiantys tik vieną kubitą, nesugeba leisti klaidoms daugintis ir propaguoti neteisingą informaciją. Tačiau, jeigu 2 kubitų \\(cX\\) loginiuose vartuose kontrolinis kubitas patyrė klaidą, tada ši klaida bus perteikta į adresatinį kubitą ir kaskados principu gali sklisti toliau. Taip pat galimas ir grynai kvantinis efektas klaidų sklidime dėl 6 skyriuje minėtos fazės atatrankos. Jeigu, prieš atliekant \\(cX\\) loginius vartus, įvyksta fazės klaida adresatiniame kubite, tada ši klaida perneš fazės klaidą ir į kontrolinį kubitą. Antrasis klaidų sklidimo šaltinis yra kubitų būsenų matavimo procesas, kurio rezultatas naudojamas kaip sąlyga pritaikyti loginius vartus kitiems kubitams. Pavyzdžiui, jeigu klaidų nustatymo procese ancilos matavimas patiria klaidą, tada gali būti pritaikomi neteisingi loginiai vartai taisyti loginiam kubitui. Siekiant užkirsti kelią klaidų dauginimuisi ir sklidimui, kvantinės grandinės loginiai elementai yra pakeičiami klaidoms atspariais loginiais elementais. Imkime kaip pavyzdį 9.5 pav. parodytą kvantinę grandinę, sudarytą iš klaidoms neatsparių loginių elementų, atliekančią 2 kubitų supynimą ir jų matavimus. 9.5 pav. Klaidoms neatspari loginė grandinė, atliekanti kubitų supynimą ir jų matavimą 9.6 pav. pateikiame klaidoms atsparius \\(\\overline{H}\\) ir \\(\\overline{cX}\\) loginius elementus (vėlgi žymime su brūkšniuku) kodui, kuriame \\(k_1\\) ir \\(k_2\\) loginiai kubitai koduojami 3 fiziniais kubitais. Šiuos tris fizinius kubitus, priklausančius \\(k_1\\) arba \\(k_2\\), vadinkime kubitų blokais. Matome, kad jeigu vienam iš fizinių kubitų \\(k_1\\) bloke pritaikomi netikslūs \\(H\\) loginiai vartai, ši klaida gali paveikti tik šį kubitą \\(k_1\\) bloke. Loginiai vartai \\(\\overline{cX}\\), veikiantys tarp atskirų kubitų kiekviename bloke, užtikrina, kad \\(H\\) vartų klaida \\(k_1\\) bloke paveiks daugiausiai vieną papildomą kubitą \\(k_2\\) bloke. Tą patį galima pasakyti ir apie pačius \\(\\overline{cX}\\), kurių klaidingas atlikimas paveikia tik po vieną kubitą kiekviename bloke. Loginiai vartai, veikiantys tarp fizinių kubitų blokuose nepriklausomai nuo kitų kubitų, yra vadinami skersiniais (angl. transversal gates). Klaidoms atspari loginė operacija yra formaliai tokia, kurios metu vieno loginio komponento klaidingas veikimas paveikia ne daugiau negu vieną kubitą kiekviename bloke. 9.6 pav. Kvantinė grandinė, dviem 3 kubitų kodo loginiams kubitams atliekanti klaidoms atsparius loginius vartus Klaidoms atspari kvantinė grandinė pakeičia loginius vartus \\(H\\) ir \\(cX\\), taip pat matavimų operacijas klaidoms atspariais loginiais elementais. Be to, loginių kubitų paruošimas \\(\\overline{|0\\rangle}_L\\) turi būti taip pat atliekamas naudojant klaidoms atsparius loginius vartus, o kubitų būsenos yra periodiškai patikrinamos ir prireikus ištaisomos. 9.7 pav. Iliustracijoje 9.5 pav. parodytos loginės grandinės klaidoms atspari versija. Du loginiai kubitai čia koduojami \\(n\\) kubitais, toliau patikrinama, ar koduojant neįvyko klaidų, ir atitinkamai atliekamas taisymas. Pirmam loginiam kubitui pritaikomi klaidoms atsparūs \\(\\overline{H}\\); matomi dar du periodiškai atliekami klaidų nustatymai ir 2 loginių kubitų klaidoms atsparūs \\(\\overline{cX}\\); galiausiai atliekami klaidoms atsparūs kubitų būsenos matavimai Siekiant realizuoti klaidoms atsparų būsenų matavimą, vėlgi pasitelkiame Hadamardo testu pagrįstą metodą (žr. 6.7.1 poskyrį). Šiuo metodu galima atlikti loginio Pauli-\\(\\overline{Z}\\) ar bet kokio kito \\(n\\) kubitų ermitinio operatoriaus \\(U\\), išreiškiamo skersiniais loginiais vartais, projekcinį matavimą į jo +1 ir -1 poerdvius. Iliustracijai, čia jį pritaikome 3 kubitų būsenos \\(|\\psi\\rangle\\) matavimui. Tai atliekanti kvantinė grandinė pateikta 9.8 pav. Kiekvienam \\(|\\psi\\rangle\\) būsenos kubitui yra pasitelkiamas papildomas ancilos kubitas. Šiuo atveju, trys fiziniai ancilų kubitai pradinėje būsenoje \\(|a_1 a_2 a_3 \\rangle = |000\\rangle\\) yra paruošiami į superpoziciją \\(|\\varphi\\rangle = \\big(|000\\rangle + |111\\rangle\\big)1/\\sqrt{2}\\), panašią į 3 kubitų loginį kubitą. Kodavimo žingsnis nėra klaidoms atsparus, nes naudojami klaidoms neatsparūs \\(H\\) ir \\(cX\\) loginiai vartai. Tačiau po kodo paruošimo kitais trim ancilų kubitais \\((a_4, a_5, a_6)\\) kodas yra patikrinamas (atliekama kodavimo patikra). Patikra yra pagrįsta jau mums žinomu būsenų lyginumo matavimu. Jeigu kodas teisingas, tada šie ancilų kubitai naudojami tolimesnėms operacijoms. Kitu atveju kodavimas kartojamas iš naujo. Tolesniame žingsnyje atliekamas skersinis sąlyginis \\(cU\\) (kontroliuojamas \\(U\\)). Ancilų kubitų būsena \\(|\\varphi\\rangle\\) užtikrina, kad klaidos neplinta šioje stadijoje. Galiausiai ancilų kubitai yra dekoduojami, o galutinė bendra pirmo ancilos kubito ir \\(|\\psi\\rangle\\) būsena lieka supintoji \\(|0\\rangle\\otimes P(1)|\\psi\\rangle + |1\\rangle\\otimes P(-1)|\\psi\\rangle\\). Išmatavus ancilos kubito būseną bus rasta +1 arba -1 tikrinė vertė ir atlikta \\(|\\psi\\rangle\\) būsenos projekcija į atitinkamą poerdvį. Siekiant sumažinti tikimybę, kad klaida dekodavimo stadijos loginiuose vartuose suteiks klaidingą matavimo rezultatą, visa ši matavimo procedūra kartojama tris kartus. Kai taikomas daugumos balso principas nustatant galutinio matavimo rezultatą, klaidingo atsakymo tikimybė sumažėja nuo \\(p\\) iki \\(O(p^2)\\). Čia \\(p\\) yra tikimybė, kad atsiras klaida bet kuriame grandinės elemente. 9.8 pav. Klaidoms atsparūs 3 kubitų kodo loginio kubito būsenos bendrojo tipo matavimai Galima parodyti, kad tikimybė, jog klaidoms atspariose grandinėse atsiras daugiau nei viena klaida kubitų bloke, yra \\(cp^2\\). Čia proporcingumo konstanta \\(c\\) priklauso nuo loginės operacijos bei kodavimo metodo ir bendrai nusako skaičių skirtingų vietų loginiame žingsnyje, kuriose gali įvykti klaida. Tad loginės operacijos klaidoms atsparioje kvantinėje grandinėje įvykdomos sėkmingai su tikimybe \\(1 - cp^2\\) ir toliau įgaunamas pranašumas mažėjant \\(p\\). 9.9 pav. Kodų konkatenacijos schema. Nurodytos nepataisomos klaidos tikimybė kiekviename kodavimo lygyje Kodų konkatenacijos metodas, taikomas kartu su klaidoms atspariomis loginėmis operacijomis, leidžia dar labiau sumažinti atsirandančių klaidų poveikį skaičiavimams. Kodų konkatenacijoje yra atliekamas aukštesnio lygio kodavimas taip sukuriant antro, trečio, ... , \\(k\\) lygio loginius kubitus (nebūtinai tuo pačiu kodu). Pavyzdžiui, jeigu naudotume tris fizinius kubitus sukurti 1 lygio loginį kubitą, tada kiekvieną iš šių kubitų koduodami dar trimis kubitais gautume 2 lygio loginį kubitą, iš viso panaudoję \\(3^2\\) fizinius kubitus. Atlikti logines operacijas šiems 2 lygio loginiams kubitams atitinkamai pasitelkiami jiems pritaikyti klaidoms atsparūs elementai, neleidžiantys klaidoms plisti. Pirmo lygio kodavime klaidos tikimybė yra \\(cp^2\\), antro lygio \\(c(cp^2)^2\\), ir jeigu konkatenacija yra atliekama \\(k\\) kartų, loginiame \\(k\\) lygio kubite – \\((cp)^{2^k}/c\\). Dėl eksponentės, klaidingo atsakymo tikimybė gali būti padaroma pageidaujamai maža didinant konkatenacijų skaičių \\(k\\), jeigu \\(cp &lt; 1\\). Sakykime, kad norima atlikti skaičiavimą su ne didesne negu \\(\\varepsilon\\) klaidos tikimybe, kuriam reikia pasitelkti iš viso \\(p(n)\\) skaičių loginių vartų. Skaičius \\(n\\) nusako problemos dydį, o \\(p(n)\\) – polinomiškai augantį loginių vartų skaičių. Tad klaidos tikimybė \\(p\\) per loginį žingsnį turėtų būti \\(p &lt; \\varepsilon/p(n)\\). Todėl mažiausias konkatenacijų skaičius \\(k\\), reikalingas pasiekti šį tikslą, randamas iš nelygybės: \\[\\begin{equation} \\frac{(cp)^{2^k}}{c} \\leq \\frac{\\varepsilon}{p(n)}\\,. \\tag{9.62} \\end{equation}\\] Iš to išplaukia, kad konkatenacijų skaičius turi būti: \\[\\begin{equation} k \\geq \\left\\{1 + \\frac{\\log\\left\\lbrack\\frac{p(n)}{\\varepsilon}\\right\\rbrack}{\\log\\left\\lbrack\\frac{1}{cp}\\right\\rbrack}\\right\\}\\,. \\tag{9.63} \\end{equation}\\] Iš anksčiau pateiktų argumentų matome, kad kvantinės grandinės ilgis ir fizinių kubitų skaičius auga tik polilogaritmiškai su \\(p(n)/\\varepsilon\\). Ribinė teorema (angl. threshold theorem) formaliai įvardija, kad klaidos atsiradimo tikimybė kiekviename loginių operacijų žingsnyje turi būti \\(p_{\\mathrm{th}} &lt; 1/c\\), norint užtikrinti, kad \\(k\\) lygių konkatenacija leistų atlikti pageidaujamo tikslumo ir ilgio kvantinius skaičiavimus. Šios ribos apskaičiavimas yra svarbus kvantinių kompiuterių dizainui, įvairūs vertinimai rodo, kad \\(p_{\\mathrm{th}} \\approx 10^{-4}–10^{-6}\\). 9.11 Kvantinis tūris Dekoherencijos trukmės bei loginių vartų tikslumas įvardija du esminius klaidų šaltinius (žr. @ref(#dekoherencija-poskyris) poskyrį). Tačiau didėjant kubitų skaičiui ir mažėjant šioms klaidoms atsiranda poreikis tiksliau įvertinti skaičiuojamąją galią. Tam idealiai norėtume suformuluoti rodiklį ar keletą rodiklių, kurie taikant standartinį protokolą leistų palyginti skirtingus įrenginius nepriklausomai nuo jų fizinio realizavimo. Galima įvardyti svarbiausius fizinius parametrus, kurie nulemia ankstyvosios NISQ raidos kvantinių kompiuterių skaičiuojamąją galią: kubitų skaičius; 2 kubitų (arba \\(n\\) kubitų) loginių vartų realizavimo architektūra procesoriuje; loginių grandinių gylis, kurį galima pasiekti, kol rezultatų neužmaskuoja klaidos; pasiekiamas loginių vartų rinkinys; operacijų skaičius, kurį galima vykdyti lygiagrečiai; Siekdami apimti visus šiuos parametrus, panagrinėkime kvantiniu tūriu (angl. quantum volume) vadinamą rodiklį. Kvantinis tūris randamas nustačius didžiausią skaičių procesoriaus kubitų, kurie gali patikimai įvykdyti pateikto gylio specifinę grandinę. Kvantinio tūrio rodiklis yra paremtas kvadratinėmis grandinėmis (angl. square circuits), susidedančiomis iš \\(d\\) skaičiaus loginių vartų sluoksnių, nusakančių grandinės gylį, ir veikia tokiam pačiam \\(d\\) skaičiui kubitų, vadinamam grandinės pločiu (angl. circuit width). Imkime procesorių, sudarytą iš \\(n\\) kubitų. Pradėdami protokolą bandytume įvykdyti kvadratinę \\(2 \\times 2\\) grandinę, sudarytą iš \\(d=2\\) gylio su pasirinktais 2 kubitais. Čia turime laisvę pasirinkti geriausiai funkcionuojančius kubitus procesoriuje. Jeigu, pagal formaliai nustatytus rodiklius, grandinė atliekama sėkmingai, tada tęstume toliau: \\(3 \\times 3, 4 \\times 4, \\ldots\\), kol rastume didžiausią \\(m \\times m\\) dydžio kvadratinę grandinę (\\(m \\leq n\\)), kurios procesorius nebegali sėkmingai įvykdyti. Taip randamas procesoriaus kvantinis tūris, jis žymimas simboliu \\(V_Q\\), o jo formalus apibrėžimas yra: \\[\\begin{equation} \\log_2 V_Q = \\max_{m \\leq n} \\{\\min(m, d(m))\\}\\,. \\tag{9.64} \\end{equation}\\] Ši išraiška nusako, kad ieškomas didžiausias \\(m\\) skaičius kubitų tarp visų procesoriaus \\(n\\) kubitų, kurie sėkmingai įvykdo grandinę, \\(d(m)\\) yra maksimalus gylis didžiausioje \\(m\\) kubitų skaičiaus kvadratinėje grandinėje. Čia tūris pateikiamas naudojant logaritmą su baze 2, tad \\(\\log_2 V_Q\\) galima interpretuoti kaip procesoriaus efektyvų kubitų skaičių, kuris gali būti lygus arba mažesnis nei fizinių kubitų skaičius procesoriuje. Eksponentiškai kubitų skaičiumi išreikštas kvantinis tūris \\(V_Q\\) atspindi kvantinių būsenų erdvės dydį, kurį procesorius gali efektyviai pasiekti atliekant unitariąsias transformacijas. Jeigu, sakykime \\(d(m) = 10\\), tada kvantinis tūris, imant eksponentę su baze 2, yra randamas: \\(V_Q = 2^{10} = 1024\\). Toliau apžvelgiame kvantinio tūrio įvertinimo protokolą. Kiekvieną loginių vartų sluoksnį sudaro dvi dalys: atsitiktinis visų \\(d\\) kubitų indeksavimo sukeitimas (angl. permutation) ir atsitiktinės 2 kubitų unitariosios transformacijos, atliekamos kiekvienai porai vienas šalia kito esančių (ar atsiradusių po sukeitimo) kubitų. Kubitų indeksavimo sukeitimas kvantinėje grandinėje bendrai žymimas raide \\(\\pi\\) ir pasitelkia \\(SWAP\\) loginius vartus. O štai kiekviena iš 2 kubitų operacijų yra parenkama Haar-atsitiktinai (angl. Haar random) iš \\((4 \\times 4)\\) matricų, nusakančių bendro tipo unitariąsias 2 kubitų transformacijas. Šių transformacijų asortimentas yra formaliai vadinamas SU(4) grupe (angl. special unitary group). Haar-atsitiktinis SU(4) matricos parinkimas yra analogiškas atsitiktiniam skaliarinio skaičiaus parinkimui iš lygiai pasiskirsčiusių skaičių rinkinio. Kvantinio tūrio protokolą atliekanti grandinė yra parodyta 9.10 pav. 9.10 pav. Kvadratinėmis \\((d \\times d)\\) grandinėmis pagrįstas kvantinio tūrio nustatymo protokolas Siekiant įvertinti, ar grandinė buvo įvykdyta sėkmingai, taikomas sunkiųjų išvesties būsenų generavimas (angl. heavy output generation). Išmatuotų galutinių būsenų pasiskirstymas yra nusakomas tikimybėmis \\(p_U(x) = |\\langle x|U|0\\rangle|^2\\). Čia \\(|0\\rangle\\) yra pradinė \\(n\\) kubitų registro būsena, \\(U\\) nusako visą \\(n\\) kubitų protokolo unitariųjų transformacijų seką, o \\(|x\\rangle\\) yra galutinė registro būsena. Galutinės būsenos \\(|x\\rangle\\) ir tikimybės \\(p_U(x)\\) randami atliekant modeliavimą klasikiniu kompiuteriu. Sunkiosios išvesties kubitų būsenos yra tos, kurių tikimybės jas rasti yra didesnės nei visų galimų būsenų tikimybių mediana, \\(p_U(x) &gt; p_{\\mathrm{med}}\\). Taikant Haar-atsitiktinumą galima apskaičiuoti, kad tikimybė rasti būsenas \\(|x\\rangle\\) aukščiau medianos yra \\(p=0.85\\) ir asimptotiškai artėja prie \\(p=0.5\\) tikimybės, jeigu įrenginys veikia itin blogai. Kvadratinės grandinės testas yra laikomas įvykdytu, jeigu bent 2/3 visų sugeneruotų būsenų atitinka būsenas su didesnėmis tikimybėmis nei tikimybių mediana. Didesnis kvantinis tūris gali būti pasiektas procesoriuose, kurie turi daugiau kubitų su ilgomis koherencijos trukmėmis ir mažomis loginių vartų klaidomis. Taip pat svarbu, kad protokolo pateikti \\(SWAP\\) bei SU(4) loginiai vartai galėtų būti efektyviai išreikšti kvantinio procesoriaus loginių vartų rinkiniu. Svarbu yra ir kubitų maksimalus tarpusavio jungimas, loginių operacijų paralelizavimo galimybės, taip pat optimaliai sukompiliuotos loginės operacijos. Kitu atveju siekiant įvykdyti pateiktą kvantinę grandinę reikės papildomų loginių operacijų skaičiaus, ir realus grandinės gylis įrenginyje bus didesnis, tad tikimybė ją sėkmingai įvykdyti mažės. Siekdami iliustruoti kubitų tarpusavio jungimo įtaką skaičiavimams, 9.11 pav. pateikiame dvi skirtingas kvantinio procesoriaus kubitų jungčių schemas. Pirmoje pavaizduota IBM superlaidininkais pagrįstų grupės Falcon procesorių architektūra, kurioje kubitų išdėstymas paremtas heksagonine simetrija. Toks kubitų išdėstymas yra specialiai gamintojų pritaikytas atlikti jų parinktiems klaidų taisymo algoritmams, atsižvelgiant į kitus procesoriaus parametrus. Didėjant kubitų skaičiui, jų išdėstymas Falcon procesoriuose toliau bus paremtas heksagonine simetrija. Čia kubitas, pagal savo poziciją, gali turėti nuo vienos iki trijų jungčių su artimiausiai esančiais kubitais kaimynais (angl. nearest-neighbor connectivity). Tai reiškia, kad tiktai tarp šių kubitų įmanomi 2 kubitų loginiai vartai, tokie kaip cX. Pavyzdžiui, atlikti cX tarp kubitų #1 ir #15 tiesiogiai neįmanoma. Tam būtina įvykdyti seką SWAP loginių operacijų tarp tarpinių kubitų, šitaip realizuojant norimą operaciją šiems dviem kubitams. Antroji pateikta kvantinio procesoriaus architektūra leidžia 2 kubitų loginius vartus atlikti tiesiogiai tarp bet kurių kubitų. Tai vadinamasis visų su visais” jungimasis (angl. all-to-all connectivity). Jonų gardelėmis pagrįsti kvantiniai procesoriai pasižymi galimybėmis realizuoti „visų su visais” architektūrą. Neatsižvelgiant į kitus procesoriaus veikimo faktorius, tokio tipo architektūra turi akivaizdų pranašumą prieš IBM Falcon, nes potencialiai sumažina reikalaujamą loginių vartų skaičių atlikti tam pačiam algoritmui. 9.11 pav. Dvi kvantinio procesoriaus architektūros, pasitelkiančios skirtingą kubitų tarpusavio jungimą. Tai nulemia, tarp kurių kubitų galima atlikti 2 ar daugiau kubitų sąlyginius loginius vartus Kvantinis tūris leidžia patikimai įvertinti pagrindinius skaičiuojamąją galią nulemiančius faktorius, tačiau yra orientuotas į artimosios raidos NISQ kvantinius kompiuterius. Spartus klasikinių skaičiavimo išteklių augimas gali užkirsti kelią atlikti klasikiniam kvantinės grandinės modeliavimui, kuris reikalingas rezultatų patikrinimui procesoriuose su daugiau nei ~60 kubitų. Augant kubitų skaičiui bei mažėjant klaidoms bus reikalingas kitas būdas įvertinti kvantinių kompiuterių skaičiuojamajai galiai. "],["debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html", "A Debesyje pasiekiami kvantiniai kompiuteriai ir simuliatoriai", " A Debesyje pasiekiami kvantiniai kompiuteriai ir simuliatoriai https://quantum-computing.ibm.com https://ionq.com https://www.xanadu.ai https://www.rigetti.com https://aws.amazon.com/braket/quantum-computers https://azure.microsoft.com/en-us/products/quantum https://quantumai.google https://qiskit.org https://pennylane.ai/ "],["literatūra.html", "Literatūra Knygos Moksliniai straipsniai", " Literatūra Knygos Audretsch, J. 2007. Entangled Systems. New Directions in Quantum Physics. Wiley. Bell, J. S. 1989. Speakable and Unspeakable in Quantum Mechanics. Cambridge University Press. Benenti, G., G. Casati, and G. Strini. 2005. Principles of Quantum Computation and Information. Volume i: Basic Concepts. World Scientific. ———. 2007. Principles of Quantum Computation and Information. Volume II: Basic Tools and Special Topics. World Scientific. Bohm, D. 1951. Quantum Theory. Englewood Cliffs: Prentice-Hall. Feynman, R. 2000. Feynman Lectures on Computation. Perseus Books Group. Jaeger, R. C., and T. N. Blalock. 2003. Microelectronic Circuit Design. Dubuque: McGraw-Hill. Kitaev, A. Yu., A. H. Shen, and M. N. Vyalyi. 2002. Classical and Quantum Computation. Vol. 47. Graduate Studies in Mathematics. American Mathematical Society. Mermin, N. D. 2007. Quantum Computer Science. An Introduction. Cambridge University Press. Nakahara, M., and T. Ohmi. 2008. Quantum Computing—from Linear Algebra to Physical Realizations. CRC Press. Nielsen, M. A., and I. L. Chuang. 2000. Quantum Computation and Quantum Information. Cambridge: Cambridge University Press. Sakurai, J. J. 1994. Modern Quantum Mechanics. Addison-Wesley. Wittek, P. 2014. Quantum Machine Learning. What Quantum Computing Means to Data Mining. Elsevier. Moksliniai straipsniai Benenti, G., and G. Strini. 2008. “Quantum Simulation of the Single-Particle Schrödinger Equation.” American Journal of Physics 76 (7): 657–62. https://doi.org/10.1119/1.2894532. Biamonte, J., P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe, and S. Lloyd. 2017. “Quantum Machine Learning.” Nature 549 (7671): 195–202. https://doi.org/10.1038/nature23474. Deutsch, D., and R. Jozsa. 1992. “Rapid Solution of Problems by Quantum Computation.” Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439: 1907. Devitt, S. J., W. J. Munro, and K. Nemoto. 2013. “Quantum Error Correction for Beginners.” Reports on Progress in Physics 76 (7): 076001. https://doi.org/10.1088/0034-4885/76/7/076001. Einstein, A., B. Podolsky, and N. Rosen. 1935. “Can Quantum-Mechanical Description of Physical Reality Be Considered Complete?” Physical Review 47: 777. Eraerds, P., N. Walenta, M. Legré, N. Gisin, and H. Zbinden. 2010. “Quantum Key Distribution and 1Gbps Data Encryption over a Single Fibre.” New Journal of Physics 12 (6): 063027. https://doi.org/10.1088/1367-2630/12/6/063027. Figgatt, C., D. Maslov, K. A. Landsman, N. M. Linke, S. Debnath, and C. Monroe. 2017. “Complete 3-Qubit Grover Search on a Programmable Quantum Computer.” Nature Communications 8: 1918. https://doi.org/10.1038/s41467-017-01904-7. Gambetta, J. M., J. M. Chow, and M. Steffen. 2017. “Building Logical Qubits in a Superconducting Quantum Computing System.” Npj Quantum Information 3: 2. https://doi.org/10.1038/s41534-016-0004-0. Giovannetti, V., S. Lloyd, and L. Maccone. 2008. “Quantum Random Access Memory.” Physical Review Letters 100: 160501. https://doi.org/10.1103/physrevlett.100.160501. Harrow, A. W., A. Hassidim, and S. Lloyd. 2009. “Quantum Algorithm for Linear Systems of Equations.” Physical Review Letters 103: 150502. https://doi.org/10.1103/physrevlett.103.150502. J, A., A. Adedoyin, J. Ambrosiano, P. Anisimov, W. Casper, G. Chennupati, C. Coffrin, et al. 2022. “Quantum Algorithm Implementations for Beginners.” ACM Transactions on Quantum Computing 3 (4): 18. https://doi.org/10.1145/3517340. James, D. F. V. 1998. “Quantum Dynamics of Cold Trapped Ions with Application to Quantum Computation.” Applied Physics B: Lasers and Optics 66: 181–90. https://doi.org/10.1007/s003400050373. Jurcevic, P., A. Javadi-Abhari, L. S. Bishop, I. Lauer, D. F. Bogorin, M. Brink, L. Capelluto, et al. 2021. “Demonstration of Quantum Volume 64 on a Superconducting Quantum Computing System.” Quantum Science and Technology 6 (2): 025020. Lloyd, S., M. Mohseni, and P. Rebentrost. 2014. “Quantum Principal Component Analysis.” Nature Physics 10 (9): 631–33. https://doi.org/10.1038/nphys3029. Ma, X.-S., J. Kofler, A. Qarry, N. Tetik, T. Scheidl, R. Ursin, S. Ramelow, et al. 2013. “Quantum Erasure with Causally Disconnected Choice.” Proceedings of the National Academy of Sciences 110 (4): 1221–26. https://doi.org/10.1073/pnas.1213201110. Monroe, C., and J. Kim. 2013. “Scaling the Ion Trap Quantum Processor.” Science 339: 6124. Preskill, J. 2018. “Quantum Computing in the NISQ Era and Beyond.” Quantum 2: 79. https://doi.org/10.22331/q-2018-08-06-79. Rebentrost, P., and S. Lloyd. 2018. “Quantum Computational Finance: Quantum Algorithm for Portfolio Optimization.” https://doi.org/10.48550/arxiv.1811.03975. Schuld, M., A. Bocharov, K. M. Svore, and N. Wiebe. 2020. “Circuit-Centric Quantum Classifiers.” Physical Review A 101: 032308. Shor, P. W. 1997. “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer.” SIAM Journal on Computing 26 (5): 1484–1509. https://doi.org/10.1137/s0097539795293172. Shor, P. W., and J. Preskill. 2000. “Simple Proof of Security of the Bb84 Quantum Key Distribution Protocol.” Physical Review Letters 85: 441. Slussarenko, S., and G. J. Pryde. 2019. “Photonic Quantum Information Processing: A Concise Review.” Applied Physics Reviews 6 (4): 041303. https://doi.org/10.1063/1.5115814. Soklakov, A. N., and R. Schack. 2006. “Efficient State Preparation for a Register of Quantum Bits.” Physical Review A 73: 012307. Somma, R. D. 2016. “Quantum Simulations of One Dimensional Quantum Systems.” Quantum Information and Computation 16 (13-14): 1125–68. Wiebe, N. 2020. “Key Questions for the Quantum Machine Learner to Ask Themselves.” New Journal of Physics 22: 091001. Wootters, W. K., and W. H. Zurek. 1982. “A Single Quantum Cannot Be Cloned.” Nature 299: 802–3. Yin, J., Y. Cao, Y.-H. Li, S.-K. Liao, L. Zhang, J.-G. Ren, W.-Q. Cai, et al. 2017. “Satellite-Based Entanglement Distribution over 1200 Kilometers.” Science 356 (6343): 1140–44. https://doi.org/10.1126/science.aan3211. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
