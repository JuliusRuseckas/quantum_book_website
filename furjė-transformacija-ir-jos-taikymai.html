<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija</title>
  <meta name="description" content="7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija" />
  <meta name="generator" content="bookdown 0.30 and GitBook 2.6.7" />

  <meta property="og:title" content="7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija" />
  <meta name="github-repo" content="JuliusRuseckas/quantum_book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija" />
  
  <meta name="twitter:description" content="7 skyrius. Furjė transformacija ir jos taikymai | Kvantinė kompiuterija" />
  

<meta name="author" content="Tadas Paulauskas" />
<meta name="author" content="Julius Ruseckas" />


<meta name="date" content="2022-12-07" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  <link rel="shortcut icon" href="media/favicon.ico" type="image/x-icon" />
<link rel="prev" href="skaičiavimai-kvantiniu-kompiuteriu.html"/>
<link rel="next" href="sistemu-modeliavimas-ir-qml.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="toc-logo"><a href="./"><img src="media/logo-toc.svg" alt="logo"></a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Pratarmė</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#kaip-skaityti-šią-knygą"><i class="fa fa-check"></i>Kaip skaityti šią knygą</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#padėka"><i class="fa fa-check"></i>Padėka</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#apie-autorius"><i class="fa fa-check"></i>Apie autorius</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#prisidėti-prie-knygos"><i class="fa fa-check"></i>Prisidėti prie knygos</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#licencija"><i class="fa fa-check"></i>Licencija</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html"><i class="fa fa-check"></i><b>1</b> Kvantinės kompiuterijos apžvalga</a>
<ul>
<li class="chapter" data-level="1.1" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#įvadas"><i class="fa fa-check"></i><b>1.1</b> Įvadas</a></li>
<li class="chapter" data-level="1.2" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinės-kompiuterijos-pradmenys"><i class="fa fa-check"></i><b>1.2</b> Kvantinės kompiuterijos pradmenys</a></li>
<li class="chapter" data-level="1.3" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#tiuringo-mašina"><i class="fa fa-check"></i><b>1.3</b> Tiuringo mašina</a></li>
<li class="chapter" data-level="1.4" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#skaičiavimų-ištekliai"><i class="fa fa-check"></i><b>1.4</b> Skaičiavimų ištekliai</a></li>
<li class="chapter" data-level="1.5" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantiniai-bitai"><i class="fa fa-check"></i><b>1.5</b> Kvantiniai bitai</a></li>
<li class="chapter" data-level="1.6" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinės-informacijos-apdorojimas"><i class="fa fa-check"></i><b>1.6</b> Kvantinės informacijos apdorojimas</a></li>
<li class="chapter" data-level="1.7" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#skaičiavimo-procesas"><i class="fa fa-check"></i><b>1.7</b> Skaičiavimo procesas</a></li>
<li class="chapter" data-level="1.8" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#kvantinių-kompiuterių-charakteristikų-palyginimas"><i class="fa fa-check"></i><b>1.8</b> Kvantinių kompiuterių charakteristikų palyginimas</a></li>
<li class="chapter" data-level="1.9" data-path="kvantinės-kompiuterijos-apžvalga.html"><a href="kvantinės-kompiuterijos-apžvalga.html#dekoherencija-poskyris"><i class="fa fa-check"></i><b>1.9</b> Dekoherencijos trukmė ir loginių vartų tikslumas</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html"><i class="fa fa-check"></i><b>2</b> Matematinių įrankių rinkinys</a>
<ul>
<li class="chapter" data-level="2.1" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tiesinė-algebra"><i class="fa fa-check"></i><b>2.1</b> Tiesinė algebra</a></li>
<li class="chapter" data-level="2.2" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#kompleksiniai-skaičiai"><i class="fa fa-check"></i><b>2.2</b> Kompleksiniai skaičiai</a></li>
<li class="chapter" data-level="2.3" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#vidinė-vektorių-sandauga"><i class="fa fa-check"></i><b>2.3</b> Vidinė vektorių sandauga</a></li>
<li class="chapter" data-level="2.4" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#kubito-reprezentacija-blocho-sferoje"><i class="fa fa-check"></i><b>2.4</b> Kubito reprezentacija Blocho sferoje</a></li>
<li class="chapter" data-level="2.5" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tiesiniai-operatoriai-ir-matricos"><i class="fa fa-check"></i><b>2.5</b> Tiesiniai operatoriai ir matricos</a></li>
<li class="chapter" data-level="2.6" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#unitariniai-ir-ermitiniai-operatoriai"><i class="fa fa-check"></i><b>2.6</b> Unitariniai ir ermitiniai operatoriai</a></li>
<li class="chapter" data-level="2.7" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#diadinė-operatorių-dekompozicija"><i class="fa fa-check"></i><b>2.7</b> Diadinė operatorių dekompozicija</a></li>
<li class="chapter" data-level="2.8" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#matricos-pėdsakas"><i class="fa fa-check"></i><b>2.8</b> Matricos pėdsakas</a></li>
<li class="chapter" data-level="2.9" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tenzorinė-vektorių-sandauga"><i class="fa fa-check"></i><b>2.9</b> Tenzorinė vektorių sandauga</a></li>
<li class="chapter" data-level="2.10" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#tenzorinė-operatorių-sandauga"><i class="fa fa-check"></i><b>2.10</b> Tenzorinė operatorių sandauga</a></li>
<li class="chapter" data-level="2.11" data-path="matematikos-skyrius.html"><a href="matematikos-skyrius.html#operatorių-funkcijos"><i class="fa fa-check"></i><b>2.11</b> Operatorių funkcijos</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html"><i class="fa fa-check"></i><b>3</b> Kvantinės mechanikos pagrindai</a>
<ul>
<li class="chapter" data-level="3.1" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#kvantinės-mechanikos-postulatai"><i class="fa fa-check"></i><b>3.1</b> Kvantinės mechanikos postulatai</a></li>
<li class="chapter" data-level="3.2" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#kvantinis-supynimas"><i class="fa fa-check"></i><b>3.2</b> Kvantinis supynimas</a></li>
<li class="chapter" data-level="3.3" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#tankio-operatorius"><i class="fa fa-check"></i><b>3.3</b> Tankio operatorius</a></li>
<li class="chapter" data-level="3.4" data-path="kvantines-mechanikos-pagrindai.html"><a href="kvantines-mechanikos-pagrindai.html#epr-paradoksas"><i class="fa fa-check"></i><b>3.4</b> EPR paradoksas</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html"><i class="fa fa-check"></i><b>4</b> Kvantiniai loginiai vartai ir grandinės</a>
<ul>
<li class="chapter" data-level="4.1" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#vieno-kubito-vartai"><i class="fa fa-check"></i><b>4.1</b> Vieno kubito loginiai vartai</a></li>
<li class="chapter" data-level="4.2" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#kvantinių-grandinių-lygybės-ir-atvirkštiniai-loginiai-vartai"><i class="fa fa-check"></i><b>4.2</b> Kvantinių grandinių lygybės ir atvirkštiniai loginiai vartai</a></li>
<li class="chapter" data-level="4.3" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#kubitų-būsenų-matavimas"><i class="fa fa-check"></i><b>4.3</b> Kubitų būsenų matavimas</a></li>
<li class="chapter" data-level="4.4" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#dviejų-kubitų-loginiai-vartai-cnot"><i class="fa fa-check"></i><b>4.4</b> Dviejų kubitų loginiai vartai <em>CNOT</em></a></li>
<li class="chapter" data-level="4.5" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#tofoli-loginiai-vartai"><i class="fa fa-check"></i><b>4.5</b> Tofoli loginiai vartai</a></li>
<li class="chapter" data-level="4.6" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#swap-ir-fredkin-loginiai-vartai"><i class="fa fa-check"></i><b>4.6</b> SWAP ir Fredkin loginiai vartai</a></li>
<li class="chapter" data-level="4.7" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#bendro-tipo-salyginiai-vartai"><i class="fa fa-check"></i><b>4.7</b> Bendro tipo sąlyginiai loginiai vartai <span class="math inline">\(\boldsymbol{cU}\)</span></a></li>
<li class="chapter" data-level="4.8" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#bendro-tipo-būsenų-matavimai"><i class="fa fa-check"></i><b>4.8</b> Bendro tipo būsenų matavimai</a></li>
<li class="chapter" data-level="4.9" data-path="kvantiniai-loginiai-vartai-grandines.html"><a href="kvantiniai-loginiai-vartai-grandines.html#universalių-loginių-vartų-rinkinys"><i class="fa fa-check"></i><b>4.9</b> Universalių loginių vartų rinkinys</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html"><i class="fa fa-check"></i><b>5</b> Kvantinė informacija ir ryšiai</a>
<ul>
<li class="chapter" data-level="5.1" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinės-informacijos-kopijavimas"><i class="fa fa-check"></i><b>5.1</b> Kvantinės informacijos kopijavimas</a></li>
<li class="chapter" data-level="5.2" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinė-teleportacija"><i class="fa fa-check"></i><b>5.2</b> Kvantinė teleportacija</a></li>
<li class="chapter" data-level="5.3" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinio-supynimo-sukeitimas"><i class="fa fa-check"></i><b>5.3</b> Kvantinio supynimo sukeitimas</a></li>
<li class="chapter" data-level="5.4" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#kvantinė-kriptografija"><i class="fa fa-check"></i><b>5.4</b> Kvantinė kriptografija</a>
<ul>
<li class="chapter" data-level="5.4.1" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#bb84-kvantinis-rakto-pasidalijimo-protokolas"><i class="fa fa-check"></i><b>5.4.1</b> BB84 kvantinis rakto pasidalijimo protokolas</a></li>
<li class="chapter" data-level="5.4.2" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#epr-kvantinis-rakto-pasidalijimo-protokolas"><i class="fa fa-check"></i><b>5.4.2</b> EPR kvantinis rakto pasidalijimo protokolas</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#lokalios-operacijos-ir-klasikiniai-ryšiai"><i class="fa fa-check"></i><b>5.5</b> Lokalios operacijos ir klasikiniai ryšiai</a></li>
<li class="chapter" data-level="5.6" data-path="kvantinė-informacija-ir-ryšiai.html"><a href="kvantinė-informacija-ir-ryšiai.html#belo-nelygybė"><i class="fa fa-check"></i><b>5.6</b> Belo nelygybė</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html"><i class="fa fa-check"></i><b>6</b> Skaičiavimai kvantiniu kompiuteriu</a>
<ul>
<li class="chapter" data-level="6.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#bazinių-vektorių-numeracija"><i class="fa fa-check"></i><b>6.1</b> Bazinių vektorių numeracija</a></li>
<li class="chapter" data-level="6.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#funkcinis-skaičiavimas"><i class="fa fa-check"></i><b>6.2</b> Funkcinis skaičiavimas</a></li>
<li class="chapter" data-level="6.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#kvantinis-paralelizmas"><i class="fa fa-check"></i><b>6.3</b> Kvantinis paralelizmas</a></li>
<li class="chapter" data-level="6.4" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#duomenu-kodavimas"><i class="fa fa-check"></i><b>6.4</b> Duomenų kodavimo būdai</a></li>
<li class="chapter" data-level="6.5" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#doičo-algoritmas"><i class="fa fa-check"></i><b>6.5</b> Doičo algoritmas</a></li>
<li class="chapter" data-level="6.6" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#kvantinė-paieška-ir-groverio-algoritmas"><i class="fa fa-check"></i><b>6.6</b> Kvantinė paieška ir Groverio algoritmas</a>
<ul>
<li class="chapter" data-level="6.6.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#algebrinė-interpretacija"><i class="fa fa-check"></i><b>6.6.1</b> Algebrinė interpretacija</a></li>
<li class="chapter" data-level="6.6.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#geometrinė-interpretacija"><i class="fa fa-check"></i><b>6.6.2</b> Geometrinė interpretacija</a></li>
<li class="chapter" data-level="6.6.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#groverio-paieška-su-n-8"><i class="fa fa-check"></i><b>6.6.3</b> Groverio paieška su <span class="math inline">\(N = 8\)</span></a></li>
</ul></li>
<li class="chapter" data-level="6.7" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamardo-swap-testai"><i class="fa fa-check"></i><b>6.7</b> Hadamardo ir SWAP testai</a>
<ul>
<li class="chapter" data-level="6.7.1" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamard-testas-poskyris"><i class="fa fa-check"></i><b>6.7.1</b> Hadamardo testas</a></li>
<li class="chapter" data-level="6.7.2" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#modifikuotas-hadamardo-testas"><i class="fa fa-check"></i><b>6.7.2</b> Modifikuotas Hadamardo testas</a></li>
<li class="chapter" data-level="6.7.3" data-path="skaičiavimai-kvantiniu-kompiuteriu.html"><a href="skaičiavimai-kvantiniu-kompiuteriu.html#swap-testas"><i class="fa fa-check"></i><b>6.7.3</b> SWAP testas</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html"><i class="fa fa-check"></i><b>7</b> Furjė transformacija ir jos taikymai</a>
<ul>
<li class="chapter" data-level="7.1" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#kvantinė-furjė-transformacija"><i class="fa fa-check"></i><b>7.1</b> Kvantinė Furjė transformacija</a></li>
<li class="chapter" data-level="7.2" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#furjė-transformacijos-realizavimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>7.2</b> Furjė transformacijos realizavimas kvantinėje grandinėje</a></li>
<li class="chapter" data-level="7.3" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#funkcijos-periodiškumo-paieška"><i class="fa fa-check"></i><b>7.3</b> Funkcijos periodiškumo paieška</a></li>
<li class="chapter" data-level="7.4" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#kvantinis-fazes-nustatymas"><i class="fa fa-check"></i><b>7.4</b> Kvantinis fazės nustatymo algoritmas</a></li>
<li class="chapter" data-level="7.5" data-path="furjė-transformacija-ir-jos-taikymai.html"><a href="furjė-transformacija-ir-jos-taikymai.html#tiesinių-lygčių-sprendimas-hhl-algoritmu"><i class="fa fa-check"></i><b>7.5</b> Tiesinių lygčių sprendimas HHL algoritmu</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html"><i class="fa fa-check"></i><b>8</b> Kvantinių sistemų modeliavimas ir mašininis mokymasis</a>
<ul>
<li class="chapter" data-level="8.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#dinaminių-sistemų-modeliavimas"><i class="fa fa-check"></i><b>8.1</b> Dinaminių sistemų modeliavimas</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#ising-hamiltonian-coding"><i class="fa fa-check"></i><b>8.1.1</b> Aizingo modelis</a></li>
<li class="chapter" data-level="8.1.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#troterizacija"><i class="fa fa-check"></i><b>8.1.2</b> Troterizacija</a></li>
<li class="chapter" data-level="8.1.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#aizingo-modelio-realizavimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>8.1.3</b> Aizingo modelio realizavimas kvantinėje grandinėje</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#erdvinės-šriodingerio-lygties-sprendimo-algoritmas"><i class="fa fa-check"></i><b>8.2</b> Erdvinės Šriodingerio lygties sprendimo algoritmas</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#banginė-funkcija"><i class="fa fa-check"></i><b>8.2.1</b> Banginė funkcija</a></li>
<li class="chapter" data-level="8.2.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#diskretizavimas"><i class="fa fa-check"></i><b>8.2.2</b> Diskretizavimas</a></li>
<li class="chapter" data-level="8.2.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#perteikimas-kvantinėje-grandinėje"><i class="fa fa-check"></i><b>8.2.3</b> Perteikimas kvantinėje grandinėje</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3</b> Mašininis mokymasis</a>
<ul>
<li class="chapter" data-level="8.3.1" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#klasikinis-mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3.1</b> Klasikinis mašininis mokymasis</a></li>
<li class="chapter" data-level="8.3.2" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#kvantinis-mašininis-mokymasis"><i class="fa fa-check"></i><b>8.3.2</b> Kvantinis mašininis mokymasis</a></li>
<li class="chapter" data-level="8.3.3" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#kvantinėmis-grandinėmis-paremtas-klasifikatorius"><i class="fa fa-check"></i><b>8.3.3</b> Kvantinėmis grandinėmis paremtas klasifikatorius</a></li>
<li class="chapter" data-level="8.3.4" data-path="sistemu-modeliavimas-ir-qml.html"><a href="sistemu-modeliavimas-ir-qml.html#pagrindinių-komponentų-analizė"><i class="fa fa-check"></i><b>8.3.4</b> Pagrindinių komponentų analizė</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html"><i class="fa fa-check"></i><b>9</b> Kvantinių klaidų aptikimas ir taisymas</a>
<ul>
<li class="chapter" data-level="9.1" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klasikinės-ir-kvantinės-klaidos"><i class="fa fa-check"></i><b>9.1</b> Klasikinės ir kvantinės klaidos</a></li>
<li class="chapter" data-level="9.2" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#supynimas-ir-klaidu-atsiradimas"><i class="fa fa-check"></i><b>9.2</b> Kvantinis supynimas su aplinka ir klaidų atsiradimas</a></li>
<li class="chapter" data-level="9.3" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bito-apvertimo-klaidos-aptikimas-ir-taisymas"><i class="fa fa-check"></i><b>9.3</b> Bito apvertimo klaidos aptikimas ir taisymas</a></li>
<li class="chapter" data-level="9.4" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#fazės-apvertimo-klaidos-aptikimas-ir-taisymas"><i class="fa fa-check"></i><b>9.4</b> Fazės apvertimo klaidos aptikimas ir taisymas</a></li>
<li class="chapter" data-level="9.5" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#tolydžiosios-klaidos"><i class="fa fa-check"></i><b>9.5</b> Tolydžiosios klaidos</a></li>
<li class="chapter" data-level="9.6" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#bendrieji-klaidų-taisymo-principai"><i class="fa fa-check"></i><b>9.6</b> Bendrieji klaidų taisymo principai</a></li>
<li class="chapter" data-level="9.7" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinė-hamingo-riba"><i class="fa fa-check"></i><b>9.7</b> Kvantinė Hamingo riba</a></li>
<li class="chapter" data-level="9.8" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#šoro-9-kubitų-kodas"><i class="fa fa-check"></i><b>9.8</b> Šoro 9 kubitų kodas</a></li>
<li class="chapter" data-level="9.9" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kodu-stabilizatoriai-poskyris"><i class="fa fa-check"></i><b>9.9</b> Kodų stabilizatoriai</a></li>
<li class="chapter" data-level="9.10" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#klaidoms-atsparus-skaičiavimas"><i class="fa fa-check"></i><b>9.10</b> Klaidoms atsparus skaičiavimas</a></li>
<li class="chapter" data-level="9.11" data-path="kvantinių-klaidų-aptikimas-ir-taisymas.html"><a href="kvantinių-klaidų-aptikimas-ir-taisymas.html#kvantinis-tūris"><i class="fa fa-check"></i><b>9.11</b> Kvantinis tūris</a></li>
</ul></li>
<li class="appendix"><span><b>Priedai</b></span></li>
<li class="chapter" data-level="A" data-path="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html"><a href="debesyje-pasiekiami-kvantiniai-kompiuteriai-ir-simuliatoriai.html"><i class="fa fa-check"></i><b>A</b> Debesyje pasiekiami kvantiniai kompiuteriai ir simuliatoriai</a></li>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html"><i class="fa fa-check"></i>Literatūra</a>
<ul>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html#knygos"><i class="fa fa-check"></i>Knygos</a></li>
<li class="chapter" data-level="" data-path="literatūra.html"><a href="literatūra.html#moksliniai-straipsniai"><i class="fa fa-check"></i>Moksliniai straipsniai</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Kvantinė kompiuterija</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="furjė-transformacija-ir-jos-taikymai" class="section level1 hasAnchor" number="7">
<h1><span class="header-section-number">7 skyrius.</span> Furjė transformacija ir jos taikymai<a href="furjė-transformacija-ir-jos-taikymai.html#furjė-transformacija-ir-jos-taikymai" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Šiame skyriuje toliau tęsiame kvantinių skaičiavimų apžvalgą
pristatydami <strong>Furjė transformaciją</strong> (angl. <em>Fourier transform</em>) ir ja
pagrįstus algoritmus. Klasikinė Furjė transformacija yra plačiai
naudojama atliekant duomenų ir signalų analizę bei apdorojimą ir yra
esminės reikšmės įrankis matematinėje funkcijų analizėje. Kaip praktinį
Furjė naudojimo pavyzdį, nebūtinai sunkų skaičiavimo išteklių atžvilgiu,
imkime funkciją <span class="math inline">\(f(t)\)</span>, kuri nusako garso šaltinio kitimą laike. Šios
funkcijos Furjė transformacija, žymima
<span class="math inline">\(\mathrm{FT}\lbrack f(t)\rbrack = f(v)\)</span>, išreiškia ją dažnių (<span class="math inline">\(v\)</span>)
spektro pavidale <span class="math inline">\(f(v)\)</span>. Norėdami atlikti pasirinktų dažnių filtravimą,
pavyzdžiui, siekiant nuslopinti aukštojo dažnio garsus, galime
užmaskuoti šias amplitudes dažnio srities funkcijoje <span class="math inline">\(f(v)\)</span>. Atlikę
atvirkštinę <span class="math inline">\(f(v)\)</span> funkcijos Furjė transformaciją, žymimą
<span class="math inline">\({\mathrm{FT}}^{-1}\lbrack f(v)\rbrack = f(t)\)</span>, grąžiname ją atgal
į laiko sritį, taip atstatydami modifikuotą garso įrašą.</p>
<div id="kvantinė-furjė-transformacija" class="section level2 hasAnchor" number="7.1">
<h2><span class="header-section-number">7.1</span> Kvantinė Furjė transformacija<a href="furjė-transformacija-ir-jos-taikymai.html#kvantinė-furjė-transformacija" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Kvantinė Furjė transformacija</strong> (angl. <em>quantum Fourier transform</em>)
yra klasikinės Furjė transformacijos kvantinis realizavimas. Palyginus
su vadinamuoju <strong>greituoju klasikiniu Furjė transformacijos algoritmu</strong>
(angl. <em>fast Fourier transform</em>), naudojamu diskretiesiems
(skaitmenizuotiems) signalams, kvantinė jos versija pasiekia
eksponentinį pagreitinimą loginių operacijų skaičiaus atžvilgiu. Todėl
kvantinė Furjė transformacija atveria galimybes paspartinti aibę
skaičiavimo užduočių. Tarp jų yra kvantinių sistemų modeliavimas,
tiesinių lygčių sprendinių paieška, kvantinio mašininio mokymosi
algoritmai, Šoro pirminių skaičių faktorizavimas.</p>
<p>Kvantinė Furjė transformacija (vartosime trumpinį FT) priima kaip įvestį
<span class="math inline">\(n\)</span> elementų vektorių ir pateikia išvestyje kitą <span class="math inline">\(n\)</span> elementų vektorių.
FT yra realizuojama unitariąja transformacija, vadinkime ją <span class="math inline">\(U_{\mathrm{FT}}\)</span>,
kurios efektas <span class="math inline">\(n\)</span> kubitų skaičiuojamiesiems baziniams vektoriams
<span class="math inline">\(|x\rangle\)</span> nusakomas:
<span class="math display" id="eq:u-ft">\[\begin{equation}
U_{\mathrm{FT}}|x\rangle =\frac{1}{\sqrt{2^n}}\sum_{y = 0}^{2^n - 1}\mathrm{e}^{\mathrm{i}2\pi xy/2^n}|y\rangle\,.
\tag{7.1}
\end{equation}\]</span>
Čia <span class="math inline">\(x\)</span> ir <span class="math inline">\(y\)</span> yra skaičiai, išreikšti dešimtaine sistema. Iš to gaunama
<span class="math inline">\(U_{\mathrm{FT}}\)</span> operatoriaus matematinė išraiška diadomis:
<span class="math display" id="eq:u-ft-diadom">\[\begin{equation}
U_{\mathrm{FT}} =\frac{1}{\sqrt{2^n}}\sum_{x = 0}^{2^{n} - 1}\sum_{y = 0}^{2^n - 1} \mathrm{e}^{\mathrm{i}2\pi xy/2^n}|y\rangle\langle x|\,.
\tag{7.2}
\end{equation}\]</span>
Matome, kad <span class="math inline">\(U_{\mathrm{FT}}\)</span>, veikiantis bet kurį bazinį vektorių
<span class="math inline">\(|x\rangle\)</span>, transformuoja jį į lygią visų standartinių
bazinių vektorių superpoziciją. Šie vektoriai yra perindeksuojami raide
<span class="math inline">\(y\)</span> ir kartu nešasi skirtingus fazės narius <span class="math inline">\(\mathrm{e}^{\mathrm{i}2\pi xy/2^n}\)</span>. Šios
eksponentės argumentuose <span class="math inline">\(xy\)</span> yra daugyba, pavyzdžiui, jeigu
<span class="math inline">\(|x\rangle = |5\rangle\)</span> ir
<span class="math inline">\(|y\rangle = |3\rangle\)</span>, tada <span class="math inline">\(xy = 15\)</span>.
Operatorių <span class="math inline">\(U_{\mathrm{FT}}\)</span>, žinoma, galima išreikšti ir <span class="math inline">\((2^n \times 2^n)\)</span>
dydžio matrica. Jos <span class="math inline">\(y\)</span> stulpelio ir <span class="math inline">\(x\)</span> eilutės įrašai yra fazės
nariai <span class="math inline">\(\mathrm{e}^{\mathrm{i}2\pi xy/2^n}/\sqrt{2^n}\)</span>.</p>
<p>Būdama unitarioji transformacija, FT išlaiko vektorių normuotumą ir
ortogonalumą
<span class="math inline">\(\langle x&#39;| U^{\dagger}_{\mathrm{FT}}U_{\mathrm{FT}}|x\rangle =\langle x&#39;|x\rangle = 0\)</span>.
Tad <span class="math inline">\(U_{\mathrm{FT}}\)</span> leidžia sukurti naują <span class="math inline">\(n\)</span> kubitų bazinių vektorių rinkinį,
vadinamą <strong>Furjė bazinių vektorių rinkiniu</strong> (angl. <em>Fourier basis</em>).
Viršuje <span class="math inline">\(U^{\dagger}_{\mathrm{FT}}\)</span> yra <span class="math inline">\(U_{\mathrm{FT}}\)</span> operatoriaus ermitinė jungtis
ir nusako atvirkštinę Furjė transformaciją, dar žymimą <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span> arba
<span class="math inline">\(\mathrm{FT}^{-1}\)</span>. Pritaikius <span class="math inline">\(U^{\dagger}_{\mathrm{FT}}|x\rangle\)</span>
skirtumas nuo viršuje parodytos išraiškos bus tik kompleksinėje fazės
narių jungtyje <span class="math inline">\(\mathrm{e}^{\mathrm{i}2\pi xy/2^n} \rightarrow\mathrm{e}^{-\mathrm{i}2\pi xy/2^n}\)</span>. Ar
minuso ženklas vartojamas <span class="math inline">\(U^{\dagger}_{\mathrm{FT}}\)</span>, ar <span class="math inline">\(U_{\mathrm{FT}},\)</span> neturi
esminės įtakos, svarbu tik sistemiškai juos vartoti.</p>
<p>Pritaikę FT bendrai būsenai <span class="math inline">\(|\psi\rangle\)</span>, esančiai
bazinių vektorių <span class="math inline">\(|x\rangle\)</span> superpozicijoje, randame:
<span class="math display" id="eq:u-ft-bendrai-busenai">\[\begin{equation}
U_{\mathrm{FT}}|\psi\rangle = U_{\mathrm{FT}}\sum_{x = 0}^{2^n - 1} c_x|x\rangle
= \frac{1}{\sqrt{2^n}}\sum_{x = 0}^{2^n - 1} \sum_{y = 0}^{2^n - 1} c_x \mathrm{e}^{\mathrm{i}2\pi xy/2^n}|y\rangle\,.
\tag{7.3}
\end{equation}\]</span>
Atkreipiame dėmesį, kad <span class="math inline">\(U_{\mathrm{FT}}|\psi\rangle\)</span> nusako
faktorizuojamą kvantinę <span class="math inline">\(n\)</span> kubitų būseną. Šią išraišką galima
supaprastinti:
<span class="math display" id="eq:u-ft-bendrai-supaprastinimas">\[\begin{equation}
U_{\mathrm{FT}}|\psi\rangle = \sum_{y = 0}^{2^n - 1} b_y|y\rangle\,.
\tag{7.4}
\end{equation}\]</span>
Čia <span class="math inline">\(b_y\)</span> yra gaunamas laikant <span class="math inline">\(y\)</span> fiksuotą ir atliekant sumą <span class="math inline">\(x\)</span>
atžvilgiu, tai formaliai nusako funkciją, priklausančią tik nuo
argumento <span class="math inline">\(y\)</span>:
<span class="math display" id="eq:b-y-apibrezimas">\[\begin{equation}
b_y =\frac{1}{\sqrt{2^n}}\sum_{x = 0}^{2^n - 1} c_x \mathrm{e}^{\mathrm{i}2\pi xy/2^n}\,.
\tag{7.5}
\end{equation}\]</span>
Toliau pateikiame keletą kvantinės Furjė transformacijos pavyzdžių.
Vieno kubito FT, <span class="math inline">\(n = 1\)</span>, yra randama:
<span class="math display" id="eq:vieno-kubito-ft">\[\begin{equation}
U_{\mathrm{FT}}|x\rangle =
\frac{1}{\sqrt{2}}\sum_{y = 0}^1 \mathrm{e}^{\mathrm{i}2\pi xy/2}|y\rangle
=\frac{1}{\sqrt{2}}\big(|0\rangle + \mathrm{e}^{\mathrm{i}\pi x}|1\rangle\big)\,.
\tag{7.6}
\end{equation}\]</span>
Fazės narys <span class="math inline">\(\mathrm{e}^{\mathrm{i}\pi x} = 1\)</span>, jeigu <span class="math inline">\(U_{\mathrm{FT}}\)</span> veikia
<span class="math inline">\(|x\rangle = |0\rangle\)</span>, ir
<span class="math inline">\(\mathrm{e}^{\mathrm{i}\pi x} = -1\)</span>, jeigu <span class="math inline">\(U_{\mathrm{FT}}\)</span> veikia
<span class="math inline">\(|x\rangle = |1\rangle\)</span>. Tad <span class="math inline">\(n = 1\)</span>
Furjė transformaciją galima išreikšti tiesiog Hadamardo loginiais
vartais, <span class="math inline">\(U_{\mathrm{FT}} = H\)</span>. Taip pat matome ir kitą specifinę situaciją, kai
Furjė transformacija pritaikoma <span class="math inline">\(n\)</span> kubitų registrui, esančiam
<span class="math inline">\(|0\rangle\)</span> būsenoje (dešimtainėje sistemoje):
<span class="math display" id="eq:u-ft-0-busenoje">\[\begin{equation}
U_{\mathrm{FT}}|0\rangle =\frac{1}{\sqrt{2^n}}\sum_{y = 0}^{2^n - 1}|y\rangle\,.
\tag{7.7}
\end{equation}\]</span>
Jos efektą galima taip pat nusakyti kiekvienam iš <span class="math inline">\(n\)</span> kubitų pritaikant
Hadamardo vartus, <span class="math inline">\(H^{\otimes n}\)</span>, taip sukuriant lygią visų bazinių
vektorių superpoziciją.</p>
<p>Paskutiniame pavyzdyje imkime vieno iš bazinių vektorių
<span class="math inline">\(|x\rangle\)</span>, nusakančio <span class="math inline">\(n = 3\)</span> kubitų registro būseną,
Furjė transformaciją:
<span class="math display" id="eq:u-ft-3-kubitai">\[\begin{equation}
\begin{aligned}
U_{\mathrm{FT}}|x\rangle = &amp; \frac{1}{\sqrt{8}}\sum_{y = 0}^{7} \mathrm{e}^{\mathrm{i}2\pi xy/8}|y\rangle \\
= &amp; \frac{1}{\sqrt{8}}\big(|0\rangle + \mathrm{e}^{\mathrm{i}\pi x/4}|1\rangle
+ \mathrm{e}^{\mathrm{i}\pi x/2}|2\rangle + \mathrm{e}^{\mathrm{i}\pi x3/4}|3\rangle \\
&amp; + \mathrm{e}^{\mathrm{i}\pi x}|4\rangle + \mathrm{e}^{\mathrm{i}\pi x5/4}|5\rangle
+ \mathrm{e}^{\mathrm{i}\pi x3/2}|6\rangle + \mathrm{e}^{\mathrm{i}\pi x7/4}|7\rangle\big)\,.
\end{aligned}
\tag{7.8}
\end{equation}\]</span>
Toliau pateikiame itin naudingą <span class="math inline">\(n\)</span> kubitų bazinio vektoriaus
<span class="math inline">\(|x\rangle\)</span> kvantinės Furjė transformacijos formą
naudojant pavienių kubitų <span class="math inline">\(n\)</span> tenzorinę sandaugą:
<span class="math display" id="eq:u-ft-n-kubitu">\[\begin{equation}
\begin{aligned}
U_{\mathrm{FT}}|x\rangle = &amp; \frac{1}{\sqrt{2^n}}\prod_{k = 1}^n \big(|0\rangle + \mathrm{e}^{\frac{\mathrm{i}2\pi x}{2^k}}|1\rangle\big) \\
= &amp; \big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi x/2}|1\rangle\big)\otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi x/4}|1\rangle\big)
\otimes\cdots\otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi x/2^n}|1\rangle\big)\,.
\end{aligned}
\tag{7.9}
\end{equation}\]</span>
Tai nusako <span class="math inline">\(n\)</span> kubitų, kurių kiekvienas yra superpozicijoje, tenzorinę
sandaugą ir todėl – faktorizuojamąją būseną. Šią išraišką galima taip
pat perteikti dvejetaine forma pasitelkiant kubitų numeraciją
<span class="math inline">\(|x\rangle = |k_1 k_2 \cdots k_n\rangle\)</span>
su <span class="math inline">\(k_i \in\{0, 1\}\)</span> ir dvejetainės trupmenos
apribrėžimą:
<span class="math display" id="eq:dvejetaine-trupmena">\[\begin{equation}
0.k_1 k_2 \cdots k_n =\frac{k_1}{2} +\frac{k_2}{4} +\cdots +\frac{k_n}{2^n} =\sum_{i = 1}^n k_i 2^{-i}\,.
\tag{7.10}
\end{equation}\]</span>
Keletas dvejetainių trupmenų pavyzdžių: 0.1=1/2, 0.001=1/8, 0.011=3/8.
Viską sudėjus kartu, <span class="math inline">\(U_{\mathrm{FT}}|x\rangle\)</span> dvejetaine forma
yra:
<span class="math display" id="eq:u-ft-dvejetaine-forma">\[\begin{equation}
\begin{split}
U_{\mathrm{FT}}|k_1 k_2\cdots k_n\rangle = &amp; \big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 0.k_{n}}|1\rangle\big)
\otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 0.k_{n - 1}k_n}|1\rangle\big)
\otimes\cdots \\
&amp; \otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 0.k_1 k_2 \cdots k_n}|1\rangle\big)\,.
\end{split}
\tag{7.11}
\end{equation}\]</span></p>
</div>
<div id="furjė-transformacijos-realizavimas-kvantinėje-grandinėje" class="section level2 hasAnchor" number="7.2">
<h2><span class="header-section-number">7.2</span> Furjė transformacijos realizavimas kvantinėje grandinėje<a href="furjė-transformacija-ir-jos-taikymai.html#furjė-transformacijos-realizavimas-kvantinėje-grandinėje" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Kvantinė Furjė transformacija yra
efektyviai realizuojama kvantinėje grandinėje naudojant 1 kubito ir
2 kubitų loginius vartus. Pirmiausiai pateikiame kaip pavyzdį 3 kubitų
registrui <span class="math inline">\(U_{\mathrm{FT}}\)</span> atliekančią kvantinę grandinę (žr. <a href="furjė-transformacija-ir-jos-taikymai.html#fig:3-kubitu-ft-grandine">7.1</a> pav.):</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:3-kubitu-ft-grandine"></span>
<img src="media/image7_1.svg" alt="3 kubitų registrui kvantinę Furjė transformaciją atliekanti loginė grandinė" width="70%" />
<p class="caption">
7.1 pav. 3 kubitų registrui kvantinę Furjė transformaciją atliekanti loginė grandinė
</p>
</div>
<p>Čia matome Hadamardo, 2-kubitų <span class="math inline">\(cP_k\)</span> bei SWAP loginių vartų
kombinaciją. Joje <span class="math inline">\(cP_k\)</span> yra <a href="kvantiniai-loginiai-vartai-grandines.html#kvantiniai-loginiai-vartai-grandines">4</a> skyriuje minėti sąlyginiai fazės
vartai <span class="math inline">\(cP_k(\theta)\)</span> su <span class="math inline">\(\theta = \mathrm{e}^{\mathrm{i}2\pi/2^k}\)</span>, <span class="math inline">\(k\)</span> – sveikasis
skaičius. Matricos forma atrodo taip:
<span class="math display" id="eq:cp-matricos-forma">\[\begin{equation}
cP_{k} =\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; \mathrm{e}^{\mathrm{i}2\pi/2^k}
\end{bmatrix}\,.
\tag{7.12}
\end{equation}\]</span>
Vartai <span class="math inline">\(W\)</span> panaudojami grandinės pabaigoje, kadangi FT algoritmas
sukeičia kubitų indeksavimą aplink centrinius kubitus. Šiuo atveju
<span class="math inline">\(k_1\)</span> sukeičiamas su <span class="math inline">\(k_3\)</span>, tad <span class="math inline">\(W\)</span>, panaudoti grandinės pabaigoje,
atstato juos atgal į standartinę <span class="math inline">\(\{k_1, k_2, k_3\}\)</span> seką. Aišku,
nebūtina to daryti, jeigu toliau atliekami loginiai vartai atsižvelgia
į indeksavimo pasikeitimą.</p>
<p>Atvirkštinė Furjė transformacija <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span> yra realizuojama atvirkštine
loginių vartų seka panaudojant atvirkštinius loginius vartus. Hadamardo
bei SWAP loginiai vartai yra patys sau atvirkštiniai, o štai
atvirkštiniai <span class="math inline">\(cP_k\)</span> vartai yra jų ermitinė jungtis
<span class="math inline">\({cP}_k^{\dagger}\)</span>. Atvirkštinę 3 kubitų transformaciją <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span>
atliekanti grandinė yra pateikta <a href="furjė-transformacija-ir-jos-taikymai.html#fig:atvirkstine-3-kubitu-ft">7.2</a> pav.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:atvirkstine-3-kubitu-ft"></span>
<img src="media/image7_2.svg" alt="Atvirkštinė 3 kubitų kvantinė Furjė transformacija" width="73%" />
<p class="caption">
7.2 pav. Atvirkštinė 3 kubitų kvantinė Furjė transformacija
</p>
</div>
<p>Furjė transformacijoje, atliekamoje <span class="math inline">\(n\)</span>-kubitų registrui,
galime įžvelgti loginių vartų seką. Pradedant nuo viršutinio kubito
<span class="math inline">\(k_1\)</span>, jam atliekami <span class="math inline">\(H\)</span> bei sąlyginiai <span class="math inline">\(cP_k\)</span> vartai poromis su
visais <span class="math inline">\(n-1\)</span> likusiais kubitais. Tai kartojama su <span class="math inline">\(k_2, k_3, \ldots\)</span> ir
likusiais kubitais, paskutiniajam atliekant tik <span class="math inline">\(H\)</span>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:kvantine-ft-grandine-n-kubitu"></span>
<img src="media/image7_3.svg" alt="Loginė grandinė, atliekanti kvantinę Furjė transformaciją $n$ kubitų registrui" width="94%" />
<p class="caption">
7.3 pav. Loginė grandinė, atliekanti kvantinę Furjė transformaciją <span class="math inline">\(n\)</span> kubitų registrui
</p>
</div>
<p>Kaip minėjome, galima FT užbaigti <span class="math inline">\(W\)</span> loginiais vartais siekiant
atstatyti visų kubitų indeksavimo eiliškumą. Apibendrinus, norint
atlikti FT <span class="math inline">\(n\)</span> kubitų registrui yra panaudojami <span class="math inline">\(n\)</span> skaičius <span class="math inline">\(H\)</span> vartų,
<span class="math inline">\(n(n - 1)/2\)</span> sąlyginių <span class="math inline">\(cP_k\)</span>, ir ne daugiau nei <span class="math inline">\(n/2\)</span> <span class="math inline">\(W\)</span>
vartų. Šie vartai gali būti realizuojami trimis <span class="math inline">\(cX\)</span>, o <span class="math inline">\(cP_k\)</span> galima
realizuoti pasitelkus ne daugiau negu 6 elementariuosius loginius
vartus. Tad kvantinės <span class="math inline">\(n\)</span> kubitų Furjė transformacijos sudėtingumas yra
nulemtas <span class="math inline">\(O(n^2)\)</span> elementarių loginių operacijų, o štai klasikinei
diskrečiajai Furjė transformacijai prireiks eksponentiškai daugiau
operacijų, <span class="math inline">\(O(n2^n)\)</span>.</p>
<p>Galima pastebėti, kad sąlyginiuose 2 kubitų vartuose <span class="math inline">\(cP_k\)</span>
adresatiniam kubitui pritaikoma fazė <span class="math inline">\(\theta = \mathrm{e}^{\mathrm{i}2\pi/2^k}\)</span> vis
mažėja su didėjančiu <span class="math inline">\(k\)</span>. Todėl FT atliekama registrui, sudarytam iš
didelio skaičiaus kubitų, nuo tam tikro <span class="math inline">\(k\)</span> skaičiaus galima
atitinkamiems kubitams nebetaikyti <span class="math inline">\(cP_k\)</span>, nes <span class="math inline">\(\theta\)</span> bus
nereikšmingai maža. Tai leidžia dar labiau sumažinti loginių vartų
skaičių, atkreipiant dėmesį dar ir į tai, kad didėjantis <span class="math inline">\(k\)</span> nusako atliekamus
<span class="math inline">\(cP_k\)</span> tarp vis toliau vienas nuo kito esančių kubitų.</p>
</div>
<div id="funkcijos-periodiškumo-paieška" class="section level2 hasAnchor" number="7.3">
<h2><span class="header-section-number">7.3</span> Funkcijos periodiškumo paieška<a href="furjė-transformacija-ir-jos-taikymai.html#funkcijos-periodiškumo-paieška" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Pirmame Furjė transformacijos taikymo pavyzdyje parodysime funkcijos
periodiškumo nustatymo algoritmą. Funkcija <span class="math inline">\(f(x)\)</span> yra periodinė su
periodu <span class="math inline">\(P\)</span>, jeigu <span class="math inline">\(f(x) = f(x + P)\)</span> visiems <span class="math inline">\(x\)</span> funkcijos <span class="math inline">\(f\)</span>
apibrėžimo intervale. Vienas periodinės funkcijos pavyzdys būtų
trigonometrinė funkcija <span class="math inline">\(f(x) =\cos(2\pi x/P)\)</span>, nusakanti osciliacijas
su periodu <span class="math inline">\(P\)</span>. Klasikiniai algoritmai gali nustatyti <span class="math inline">\(P\)</span> su
eksponentiniu laiko sudėtingumu, augančiu didėjant įvesties dydžiui <span class="math inline">\(N\)</span>.
O štai paprastas kvantinis algoritmas, naudojantis FT, leidžia pasiekti
eksponentinį paspartinimą.</p>
<p>Imkime šio algoritmo pavyzdį su įvesties bei išvesties registrais,
turinčiais po 3 kubitus, ir funkciją <span class="math inline">\(f(x)\)</span>, kurios periodas yra
<span class="math inline">\(P = 2\)</span>. Dėl šio periodiškumo funkcijos reikšmės lyginiuose ir
nelyginiuose argumentuose yra nusakytos <span class="math inline">\(y&#39;\)</span> ir <span class="math inline">\(y&#39;&#39;\)</span> vertėmis:
<span class="math inline">\(y&#39; = f(0) = f(2) = f(4) = f(6)\)</span> ir
<span class="math inline">\(y&#39;&#39; = f(1) = f(3) = f(5) = f(7)\)</span>. Pirmiausia pradinės būsenos
<span class="math inline">\(|\psi_0\rangle = |0\rangle\otimes|0\rangle\)</span>
įvesties registrui pritaikome Hadamardo vartus <span class="math inline">\(H^{\otimes 3}\)</span>, kurie
sukuria lygią visų bazinių vektorių superpoziciją:
<span class="math display" id="eq:h-3-pradinei-busenai">\[\begin{equation}
(H^{\otimes 3}\otimes I)|\psi_0\rangle =\frac{1}{\sqrt{8}}\sum_{x = 0}^7 |x\rangle\otimes|0\rangle\,.
\tag{7.13}
\end{equation}\]</span>
Kitame žingsnyje pritaikome abu registrus veikiančią transformaciją
<span class="math inline">\(U_f\)</span>, kuri nusako periodinę funkciją <span class="math inline">\(f(x)\)</span>:
<span class="math display" id="eq:antras-zingsnis-u-f">\[\begin{equation}
|\psi_1\rangle = U_f\frac{1}{\sqrt{8}}\sum_{x = 0}^7 |x\rangle\otimes|0\rangle
= \frac{1}{\sqrt{8}}\sum_{x = 0}^7 |x\rangle\otimes|f(x)\rangle\,.
\tag{7.14}
\end{equation}\]</span>
Atliekame Furjė transformaciją įvesties registrui:
<span class="math display" id="eq:ft-ivesties-registrui">\[\begin{equation}
(U_{\mathrm{FT}}\otimes I)|\psi_1\rangle
= \frac{1}{8}\sum_{x = 0}^7 \sum_{y = 0}^7 \mathrm{e}^{\mathrm{i}2\pi xy/8}|y\rangle\otimes|f(x)\rangle\,.
\tag{7.15}
\end{equation}\]</span>
Šią dvigubą sumą apskaičiuosime pirmiausia sudėdami <span class="math inline">\(x\)</span> indeksuotuosius
narius ir laikant <span class="math inline">\(y\)</span> fiksuotus, nes norime išnaudoti supaprastinimą,
atsirandantį dėl <span class="math inline">\(f(x)\)</span> periodiškumo. Vadindami šioje stadijoje bendrą
būseną <span class="math inline">\(|\psi_2\rangle\)</span> randame:
<span class="math display" id="eq:psi-2-periodiskumas">\[\begin{equation}
\begin{split}
|\psi_2\rangle = &amp; \frac{1}{8}\sum_{y = 0}^7 |y\rangle\otimes\big(|f(0)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y}{4}}|f(1)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y}{2}}|f(2)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y3}{4}}|f(3)\rangle \\
&amp; + \mathrm{e}^{\mathrm{i}\pi y}|f(4)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y5}{4}}|f(5)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y3}{2}}|f(6)\rangle
+ \mathrm{e}^{\frac{\mathrm{i}\pi y7}{4}}|f(7)\rangle\big)\,.
\end{split}
\tag{7.16}
\end{equation}\]</span>
Toliau panaudojame <span class="math inline">\(f(x)\)</span> periodiškumą identifikuodami anksčiau minėtas
vertes <span class="math inline">\(y&#39;\)</span> ir <span class="math inline">\(y&#39;&#39;\)</span> ir sugrupuojame šiuos narius:
<span class="math display" id="eq:psi-2-nariu-sugrupavimas">\[\begin{equation}
|\psi_2\rangle =\frac{1}{8}\sum_{y = 0}^7 |y\rangle\otimes\Big(\big(1 + \mathrm{e}^{\frac{\mathrm{i}\pi y}{2}}
+ \mathrm{e}^{\mathrm{i}\pi y} + \mathrm{e}^{\frac{\mathrm{i}\pi y3}{2}}\big)|y&#39;\rangle
+ \big(\mathrm{e}^{\frac{i\pi y}{4}} + \mathrm{e}^{\frac{\mathrm{i}\pi y3}{4}}
+ \mathrm{e}^{\frac{\mathrm{i}\pi y5}{4}} + \mathrm{e}^{\frac{\mathrm{i}\pi y7}{4}}\big)|y&#39;&#39;\rangle\Big)\,.
\tag{7.17}
\end{equation}\]</span>
Būsenos <span class="math inline">\(|\psi_2\rangle\)</span> išraiška taip pat
susiprastina dėl atsirandančių destruktyviųjų interferencijų sudedant
skliausteliuose fazės narius. Pavyzdžiui, jeigu <span class="math inline">\(y = 1\)</span>, tada:
<span class="math display" id="eq:narys-2-periodiskumas" id="eq:narys-1-periodiskumas">\[\begin{align}
\left(1 + \mathrm{e}^{\frac{\mathrm{i}\pi}{2}} + \mathrm{e}^{\mathrm{i}\pi} + \mathrm{e}^{\frac{\mathrm{i}\pi 3}{2}}\right)|y&#39;\rangle
=  &amp; (1 + \mathrm{i} - 1 - \mathrm{i})|y&#39;\rangle = 0\,.\tag{7.18} \\
\left(\mathrm{e}^{\frac{\mathrm{i}\pi}{4}} + \mathrm{e}^{\frac{\mathrm{i}\pi 3}{4}} + \mathrm{e}^{\frac{\mathrm{i}\pi 5}{4}}
+ \mathrm{e}^{\frac{\mathrm{i}\pi 7}{4}}\right)|y&#39;&#39;\rangle
= &amp; \Bigg(\frac{1}{\sqrt{2}} +\frac{\mathrm{i}}{\sqrt{2}}
- \frac{1}{\sqrt{2}} + \frac{\mathrm{i}}{\sqrt{2}}  \nonumber\\
&amp; - \frac{1}{\sqrt{2}} - \frac{\mathrm{i}}{\sqrt{2}}
+ \frac{1}{\sqrt{2}} - \frac{\mathrm{i}}{\sqrt{2}}\Bigg)|y&#39;&#39;\rangle = 0\,.\tag{7.19}
\end{align}\]</span>
Taip patikrinę visas <span class="math inline">\(y\)</span> vertes sumoje matome, kad konstruktyvioji
interferencija atsiranda tik įvesties registro būsenose
<span class="math inline">\(|y\rangle = |0\rangle\)</span> ir
<span class="math inline">\(|y\rangle = |4\rangle\)</span>. Visų kitų
būsenų amplitudės susideda į 0. Galutinė abiejų registrų būsena
<span class="math inline">\(|\psi_3\rangle\)</span> yra:
<span class="math display" id="eq:galutine-busena-periodiskumas">\[\begin{equation}
|\psi_3\rangle =\frac{1}{2}|0\rangle\otimes\big(|y&#39;\rangle + |y&#39;&#39;\rangle\big)
+ \frac{1}{2}|4\rangle\otimes\big(|y&#39;\rangle - |y&#39;&#39;\rangle\big)\,.
\tag{7.20}
\end{equation}\]</span>
Kadangi <span class="math inline">\(\langle y&#39;|y&#39;&#39;\rangle =\delta_{y&#39;y&#39;&#39;}\)</span>,
pamatavę įvesties registrą rasime būsenas <span class="math inline">\(|0\rangle\)</span>
arba <span class="math inline">\(|4\rangle\)</span> su <span class="math inline">\(p(0) = p(4) = 0.5\)</span> tikimybe. Būsena
<span class="math inline">\(|0\rangle\)</span> nepriklauso nuo periodo, tad radus ją nėra
suteikiama informacijos ir teks kartoti žingsnius kol, šiuo atveju,
bus rasta <span class="math inline">\(|4\rangle\)</span>. Tai prisideda prie algoritmo
laiko sudėtingumo. Būsena <span class="math inline">\(|4\rangle\)</span> tiesiogiai
atspindi <span class="math inline">\(P = 2\)</span> periodiškumą, nes pritaikius šį algoritmą <span class="math inline">\(n\)</span> kubitų
sistemai įvesties registre (žr. <a href="furjė-transformacija-ir-jos-taikymai.html#fig:periodiskuma-nustatanti-grandine">7.4</a> pav.) bendrai išlieka tik šių būsenų
superpozicija:
<span class="math display" id="eq:isliekanti-superpozicija">\[\begin{equation}
|0\rangle\,, |1\cdot 2^n/P\rangle\,, |2\cdot 2^n/P\rangle\,, |3\cdot 2^n/P\rangle\,,\ldots\,, |(P - 1)\cdot 2^n/P\rangle\,.
\tag{7.21}
\end{equation}\]</span>
Darome prielaidą, kad <span class="math inline">\(2^n/P\)</span> yra sveikasis skaičius, tad jeigu
randama būsena <span class="math inline">\(|y\rangle\)</span>, periodas yra
<span class="math inline">\(P = k(2^n/y)\)</span>. Čia <span class="math inline">\(k = 0, 1, 2,\ldots, (P - 1)\)</span> yra sveikasis
neneigiamasis skaičius, o <span class="math inline">\(2^n\)</span> nusako sistemos dimensiją ir yra
žinomas skaičius. Taikydami šią formulę matome, kad minėta būsena
<span class="math inline">\(|4\rangle\)</span> indikuoja <span class="math inline">\(P =\frac{2^3}{4} = 2\)</span> periodą.
Bendrai, jeigu perteiksime sąryšį taip <span class="math inline">\(P/k = 2^n/y\)</span>, tada atlikus
<span class="math inline">\(2^n/y\)</span> naryje abiejų skaičių padalijimą iš jų didžiausio bendrojo
daliklio, gautas vardiklis bus periodas <span class="math inline">\(P\)</span>. Taip pat galima parodyti,
kad jeigu <span class="math inline">\(2^n/P\)</span> ir nėra sveikasis skaičius, amplitudės vis tiek
išlieka tik tų būsenų <span class="math inline">\(|y\rangle\)</span>, kurios yra artimos
<span class="math inline">\(k2^n/P\)</span> sveikajam skaičiui.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:periodiskuma-nustatanti-grandine"></span>
<img src="media/image7_4.svg" alt="Funkcijos periodiškumą nustatanti loginė grandinė. Furjė transformacija $n$ kubitų registrui glaustai užrašyta kaip modulis FT" width="60%" />
<p class="caption">
7.4 pav. Funkcijos periodiškumą nustatanti loginė grandinė. Furjė transformacija <span class="math inline">\(n\)</span> kubitų registrui glaustai užrašyta kaip modulis FT
</p>
</div>
</div>
<div id="kvantinis-fazes-nustatymas" class="section level2 hasAnchor" number="7.4">
<h2><span class="header-section-number">7.4</span> Kvantinis fazės nustatymo algoritmas<a href="furjė-transformacija-ir-jos-taikymai.html#kvantinis-fazes-nustatymas" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Šis algoritmas (angl. <em>quantum phase estimation</em>) pasitelkia kvantinę
Furjė transformaciją ir aptinkamas kaip modulis kituose
algoritmuose. Tarp jų yra kvantinis tiesinių lygčių sprendimo
algoritmas, kurį pristatome kitame poskyryje. Fazės nustatymo algoritmo
sudėtingumas yra nulemtas FT modulio, kuriam prireiks <span class="math inline">\(O(n^2)\)</span>
elementariųjų operacijų. Fazės nustatymo algoritmo užduotis yra rasti
unitariojo operatoriaus <span class="math inline">\(U\)</span> tikrines vertes. Unitariųjų operatorių
tikrinės vertės <span class="math inline">\(\lambda_u\)</span> turi bendrą formą
<span class="math inline">\(\lambda_u = \mathrm{e}^{\mathrm{i}2\pi\theta_u}\)</span> ir tenkina lygtį:
<span class="math display" id="eq:unitariojo-tikrines-funkcijos">\[\begin{equation}
U|u\rangle = \mathrm{e}^{\mathrm{i}2\pi\theta_u}|u\rangle\,.
\tag{7.22}
\end{equation}\]</span>
Čia <span class="math inline">\(U\)</span> yra unitarusis operatorius, kurio tikrinė vertė
<span class="math inline">\(\lambda_u = \mathrm{e}^{\mathrm{i}2\pi\theta_u}\)</span> asocijuota su tikriniu vektoriumi
<span class="math inline">\(|u\rangle\)</span> (darome prielaidą, kad tikriniai vektoriai
yra neišsigimę). Parametras, įvardijantis <span class="math inline">\(U\)</span> skirtingas tikrines vertes
<span class="math inline">\(\lambda_u\)</span>, yra fazė <span class="math inline">\(\theta_u\)</span> (realusis skaičius) ir
<span class="math inline">\(0\leq\theta_u &lt; 1/2\pi\)</span> dėl periodiškumo. Literatūroje galima
rasti pervadintą <span class="math inline">\(\theta_u\)</span> įkomponuojant <span class="math inline">\(2\pi\)</span>, tada
<span class="math inline">\(\lambda_{u} = \mathrm{e}^{\mathrm{i}\theta_u}\)</span> ir
<span class="math inline">\(\theta_u \rightarrow\theta_u/2\pi\)</span>.</p>
<p>Fazės nustatymo algoritmas leidžia, skaičiavimo išteklių atžvilgiu,
efektyviai apskaičiuoti <span class="math inline">\(\theta_u\)</span> pageidaujamu tikslumu. Šiuo metodu
naudojamas fazės atatrankos triukas, kurį jau matėme Doičo ir Groverio
algoritmuose. Imkime paprastą 2 kubitų būsenos pavyzdį:
<span class="math display" id="eq:2-kubitu-busena-faze">\[\begin{equation}
|k_1\rangle\otimes|k_2\rangle =\frac{1}{\sqrt{2}}\big(|0\rangle + |1\rangle\big)\otimes|u\rangle\,.
\tag{7.23}
\end{equation}\]</span>
Čia kubitas <span class="math inline">\(k_2\)</span> yra <span class="math inline">\(U\)</span> operatoriaus tikrinio vektoriaus būsenoje
<span class="math inline">\(|u\rangle\)</span>. Pritaikome šiems dviem kubitams sąlyginį
2 kubitų operatorių <span class="math inline">\(cU\)</span>, kuriame <span class="math inline">\(k_2\)</span> kubitas yra adresatinis:
<span class="math display" id="eq:cu-faze">\[\begin{equation}
cU|k_1\rangle\otimes|k_2\rangle
= \frac{1}{\sqrt{2}}\big(|0\rangle\otimes|u\rangle + |1\rangle\otimes U|u\rangle\big)
= \frac{1}{\sqrt{2}}\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi\theta_{u}}|1\rangle\big)\otimes|u\rangle\,.
\tag{7.24}
\end{equation}\]</span>
Matome, kad amplitudė, nusakanti <span class="math inline">\(|u\rangle\)</span> būsenos
tikrinę vertę <span class="math inline">\(\lambda_u = \mathrm{e}^{\mathrm{i}2\pi\theta_u}\)</span>, yra perkeliama
kubitui <span class="math inline">\(k_1\)</span>. Fazės nustatymo algoritmas pasikliauja gebėjimu
paruošti <span class="math inline">\(U\)</span> operatoriaus tikrinį vektorių <span class="math inline">\(|u\rangle\)</span>
ir atlikti sąlyginius <span class="math inline">\(cU^{2^n}\)</span> vartus, kai <span class="math inline">\(U^{2^n}\)</span> yra <span class="math inline">\(U\)</span>
pritaikytas <span class="math inline">\(2^n\)</span> kartų (pakeltas <span class="math inline">\(2^n\)</span> laipsniu). Pavyzdžiui,
<span class="math inline">\(U^2|u\rangle = UU|u\rangle = \mathrm{e}^{\mathrm{i}2\pi\theta_u}U|u\rangle = \mathrm{e}^{\mathrm{i}2\pi 2\theta_u}|u\rangle\)</span>.
Taip tęsdami matome:
<span class="math display" id="eq:2-n-pakartojimu">\[\begin{equation}
U^{2^n}|u\rangle = \mathrm{e}^{\mathrm{i}2\pi 2^n\theta_u}|u\rangle\,.
\tag{7.25}
\end{equation}\]</span>
Kvantinė grandinė, realizuojanti fazės nustatymą, yra parodyta <a href="furjė-transformacija-ir-jos-taikymai.html#fig:grandine-fazes-nustatymui">7.5</a> pav.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:grandine-fazes-nustatymui"></span>
<img src="media/image7_5.svg" alt="Bendra loginė grandinė, realizuojanti fazės nustatymo algoritmą" width="94%" />
<p class="caption">
7.5 pav. Bendra loginė grandinė, realizuojanti fazės nustatymo algoritmą
</p>
</div>
<p>Pirmasis registras yra sudarytas iš <span class="math inline">\(n\)</span> kubitų, čia skaičius <span class="math inline">\(n\)</span> yra
parenkamas pagal tai, kokį norima pasiekti fazės <span class="math inline">\(\theta\)</span> tikslumą
bitais. Atkreipiame dėmesį, kad naudojamas bazinių vektorių kodavimo
metodas (žr. <a href="skaičiavimai-kvantiniu-kompiuteriu.html#duomenu-kodavimas">6.4</a> poskyrį). Antrasis registras sudarytas iš <span class="math inline">\(m\)</span> kubitų,
reikalingų <span class="math inline">\(U\)</span> operatoriaus tikriniam vektoriui
<span class="math inline">\(|u\rangle\)</span> perteikti. Pritaikę <span class="math inline">\(H^{\otimes n}\)</span> bei
<span class="math inline">\(cU^{2^n}\)</span> vartų sekas, randame šią bendrą būseną:
<span class="math display" id="eq:h-n-cu-2-n-busena">\[\begin{equation}
\begin{aligned}
|\psi\rangle = &amp; \frac{1}{\sqrt{2^n}}\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 2^{n - 1}\theta_u}|1\rangle\big)
\otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 2^{n - 2}\theta_u}|1\rangle\big)
\otimes\cdots \\
&amp; \otimes\big(|0\rangle + \mathrm{e}^{\mathrm{i}2\pi 2^{0}\theta_u}|1\rangle\big)\otimes|u\rangle \\
= &amp; \frac{1}{\sqrt{2^n}}\sum_{y = 0}^{2^n - 1} \mathrm{e}^{\mathrm{i}2\pi y\theta_u}|y\rangle\otimes|u\rangle\,.
\end{aligned}
\tag{7.26}
\end{equation}\]</span>
Antroje eilutėje atlikome supaprastinimą, išskleisdami visas <span class="math inline">\(n\)</span> kubitų
tenzorines sandaugas. Tada, atpažindami <span class="math inline">\(n\)</span> kubitų superpoziciją,
pervadinome <span class="math inline">\(|y\rangle\)</span> bazinius vektorius dešimtainėje
sistemoje. Antrasis <span class="math inline">\(m\)</span> kubitų registras <span class="math inline">\(|u\rangle\)</span>
būsenoje nebeturi įtakos likusiems algoritmo žingsniams. Atliekame
atvirkštinę <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span> pirmam <span class="math inline">\(n\)</span> kubitų registrui:
<span class="math display" id="eq:atvirkstine-ft-pirmam-registrui">\[\begin{equation}
(U_{\mathrm{FT}}^{\dagger}\otimes I)\frac{1}{\sqrt{2^n}}\sum_{y = 0}^{2^n - 1}
\mathrm{e}^{\mathrm{i}2\pi y\theta_u}|y\rangle\otimes|u\rangle
= \frac{1}{2^n}\sum_{l = 0}^{2^n - 1} \sum_{x = 0}^{2^n - 1}
\mathrm{e}^{\frac{-\mathrm{i}2\pi l(x - 2^n \theta_u)}{2^n}}|x\rangle\otimes|u\rangle\,.
\tag{7.27}
\end{equation}\]</span>
Atlikus dvigubą indeksų <span class="math inline">\(l\)</span> ir <span class="math inline">\(x\)</span> sudėtį, pirmojo registro amplitudė
turi didelę vertę tik ties <span class="math inline">\(x\approx 2^n \theta_u\)</span>, tai yra
<span class="math inline">\(|x\rangle = |2^n \theta_u\rangle\)</span>
būsenai. Galutinę <span class="math inline">\(|\psi\rangle\)</span> galima užrašyti:
<span class="math display" id="eq:galutine-busena-fazei">\[\begin{equation}
|\psi\rangle\cong |2^n\theta_u\rangle\otimes|u\rangle\,.
\tag{7.28}
\end{equation}\]</span>
Todėl pirmojo registro būsenos matavimas su didele tikimybe grąžins
<span class="math inline">\(|2^n \theta_u\rangle\)</span> būseną. Fazė yra randama
<span class="math inline">\(\theta_u = x/2^n\)</span>, čia <span class="math inline">\(x\)</span> nusako pirmojo registro matavimo
rezultatą.</p>
<p>Atvirkštinės <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span> naudojimo reikšmę šiame algoritme galima pamatyti,
jeigu fazę perteiksime dvejetainės trupmenos forma,
<span class="math inline">\(\theta_u = 0.k_1 k_2 \cdots k_n\)</span> su <span class="math inline">\(n\)</span> bitų tikslumu. Tada,
pritaikius <span class="math inline">\(H^{\otimes n}\)</span> ir <span class="math inline">\(cU^{2^n}\)</span> sekas, būsena
<span class="math inline">\(|\psi\rangle\)</span> įgauna formą dvejetainėje sistemoje, kuri
yra identiškai nusakoma FT atlikimu
<span class="math inline">\(U_{\mathrm{FT}}|2^n k_1 k_2 \cdots k_n\rangle\)</span>. Iškvietę
atvirkštinę <span class="math inline">\(\mathrm{FT}^{\dagger}\)</span>, randame
<span class="math inline">\(U_{\mathrm{FT}}^{\dagger}U_{\mathrm{FT}}|2^n k_1 k_2 \cdots k_n\rangle = |2^n k_1 k_2 \cdots k_n\rangle\)</span>,
ir tai vėl tiesiogiai įvardija <span class="math inline">\(\theta_u\)</span> dvejetainėje formoje.</p>
<p>Fazės nustatymo algoritme reikalinga paruošti pradinę registrų būseną į
<span class="math inline">\(|0\rangle^{\otimes n}\otimes|u\rangle\)</span>.
Tačiau itin tiksliai paruošti <span class="math inline">\(U\)</span> operatoriaus tikrinį vektorių
<span class="math inline">\(|u\rangle\)</span> gali būti keblu. Kaip tada veiks algoritmas?
Atkreipiame dėmesį, kad bendrą būseną <span class="math inline">\(|\phi\rangle\)</span>
visada galima perteikti <span class="math inline">\(U\)</span> operatoriaus tikriniais vektoriais
<span class="math inline">\(|u\rangle\)</span>:
<span class="math display" id="eq:busena-isreiksta-u-tikriniais">\[\begin{equation}
|\phi\rangle =\sum_u c_u |u\rangle\,.
\tag{7.29}
\end{equation}\]</span>
Čia amplitudės <span class="math inline">\(c_u =\langle u|\phi\rangle\)</span>
nusako šių būsenų persiklojimą. Pritaikius fazės nustatymo algoritmą
(FN), realizuojamą <span class="math inline">\(U_{\mathrm{FN}}\)</span> būsenai <span class="math inline">\(|\phi\rangle\)</span>,
rezultatas bus superpozicija:
<span class="math display" id="eq:u-fn-rezultatas">\[\begin{equation}
U_{\mathrm{FN}}|\phi\rangle\cong\sum_u c_u |2^n \theta_u \rangle\otimes|u\rangle\,.
\tag{7.30}
\end{equation}\]</span>
Tikimybė rasti būseną <span class="math inline">\(|u\rangle\)</span> bei su ja supintą
pirmojo registro būseną <span class="math inline">\(|2^n \theta_u\rangle\)</span>, kuri
nusako tikrinę vertę, yra <span class="math inline">\(|c_u|^2\)</span>. Kitaip tariant, netikslus
<span class="math inline">\(|u\rangle\)</span> paruošimas gali įvesti atsitiktinumo į
rezultatą, dėl šios priežasties bus rasta kita <span class="math inline">\(U\)</span> operatoriaus tikrinė
vertė su tikimybe <span class="math inline">\(|c_u|^2 (1 -\epsilon)\)</span>. Faktorius
<span class="math inline">\((1 -\epsilon)\)</span> atsiranda dėl tikslumo, kuriuo pasirenkama nustatyti
fazę. Todėl nebūtina idealiai tiksliai paruošti
<span class="math inline">\(|u\rangle\)</span>, pakanka pradinę būseną
<span class="math inline">\(|\phi\rangle\)</span> padaryti kuo panašesnę į norimą
<span class="math inline">\(|u\rangle\)</span> maksimizuojant jų persiklojimą
<span class="math inline">\(|\langle u |\phi\rangle|\)</span>.</p>
<p>Jeigu <span class="math inline">\(2^n \theta_u\)</span> ir nėra sveikasis skaičius, šis
algoritmas vis tiek grąžina ieškomąją fazę su didesne nei <span class="math inline">\(p = 0.4\)</span>
tikimybe. Tikimybė rasti ieškomą rezultatą ir <span class="math inline">\(\theta\)</span> skaičiaus
tikslumas gali būti padidinti pasitelkus daugiau <span class="math inline">\(n\)</span> kubitų pirmajame
registre. Galima formaliai parodyti, kad kubitų skaičius <span class="math inline">\(n\)</span> grandinėje auga kaip <span class="math inline">\(O(\log(1/\epsilon))\)</span> siekant <span class="math inline">\(\epsilon\)</span> paklaidos
bei reikalauja <span class="math inline">\(O(1/\epsilon)\)</span> sąlyginių loginių vartų <span class="math inline">\(cU\)</span>.</p>
</div>
<div id="tiesinių-lygčių-sprendimas-hhl-algoritmu" class="section level2 hasAnchor" number="7.5">
<h2><span class="header-section-number">7.5</span> Tiesinių lygčių sprendimas HHL algoritmu<a href="furjė-transformacija-ir-jos-taikymai.html#tiesinių-lygčių-sprendimas-hhl-algoritmu" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Kvantinis HHL algoritmas</strong> (jo kūrėjų <em>Harrow-Hassidim-Lloyd</em>
pavardžių trumpinys) leidžia spręsti tiesinių lygčių sistemas ir
suteikia žymų paspartinimą prieš klasikinius algoritmus: <strong>Gauso
pašalinimą</strong> (angl. <em>Gauss elimination</em>) ir <strong>konjuguotojo gradiento
metodą</strong> (angl. <em>conjugate gradient method</em>). HHL algoritmo laiko vykdymo trukmė auga kaip
<span class="math inline">\(O(\kappa^2\log 2^m)\)</span> ir suteikia eksponentinį paspartinimą sistemos
dydžio <span class="math inline">\(2^m\)</span> atžvilgiu prieš klasikinius algoritmus, kurie pasižymi
<span class="math inline">\(O(\kappa 2^m)\)</span>. Čia <span class="math inline">\(\kappa\)</span> yra <strong>matricos
sąlygos skaičius</strong> (angl. <em>condition number</em>), kuris nusako didžiausios ir
mažiausios matricos <span class="math inline">\(A\)</span> tikrinių verčių santykį,
<span class="math inline">\(\kappa =\lambda_{\max}/\lambda_{\min}\)</span>. Algoritmo stabilumas mažėja, kai <span class="math inline">\(\lambda_{\min} \rightarrow 0\)</span>. Apžvelgsime HHL algoritmo bendruosius veikimo principus ir pateiksime jo realizaciją kvantinėje grandinėje.</p>
<p>Tiesinių lygčių sistema yra išreiškiama lygtimi:
<span class="math display" id="eq:tiesiniu-lygciu-sistema">\[\begin{equation}
A|x\rangle = |b\rangle\,.
\tag{7.31}
\end{equation}\]</span>
Sprendžiant lygčių sistemą kvantiniu kompiuteriu, operatorius <span class="math inline">\(A\)</span>
tiesinėje algebroje yra ermitinė <span class="math inline">\((2^m \times 2^m)\)</span> dydžio matrica,
<span class="math inline">\(|x\rangle\)</span> ir <span class="math inline">\(|b\rangle\)</span> yra <span class="math inline">\(2^m\)</span>
dimensijų normuotieji vektoriai. Matrica <span class="math inline">\(A\)</span> bei vektorius
<span class="math inline">\(|b\rangle\)</span> yra nurodyti, algoritmo užduotis – rasti
vektorių <span class="math inline">\(|x\rangle\)</span>, tenkinantį šią lygčių sistemą.
Bendrai ši sistema nusako <span class="math inline">\(2^m\)</span> skaičių lygčių ir <span class="math inline">\(2^m\)</span> skaičių
nežinomųjų, kurie yra <span class="math inline">\(|x\rangle\)</span> vektoriaus amplitudės.
Sprendimas <span class="math inline">\(|x\rangle\)</span> randamas invertuojant <span class="math inline">\(A\)</span>
matricą, tai yra apskaičiuojant <span class="math inline">\(A^{-1}\)</span> (<span class="math inline">\(A^{-1}A = I\)</span>), nes:
<span class="math display" id="eq:lygciu-sistemos-sprendinys">\[\begin{equation}
|x\rangle = A^{-1}|b\rangle\,.
\tag{7.32}
\end{equation}\]</span>
Reikalavimas, kad <span class="math inline">\(A\)</span> būtų ermitinė matrica, gali būti sušvelninamas;
mat jeigu <span class="math inline">\(A\)</span> nėra ermitinė, galime apibūdinti naują matricą <span class="math inline">\(B\)</span>, kuri
yra ermitinė:
<span class="math display" id="eq:ermitines-matricos-sukonstravimas">\[\begin{equation}
B =\begin{pmatrix}
0 &amp; A\\
A^{\dagger} &amp; 0
\end{pmatrix}\,,
\tag{7.33}
\end{equation}\]</span>
ir išspręsti susijusią lygčių sistemą:
<span class="math display" id="eq:lygciu-sistema-matricai-b">\[\begin{equation}
B\begin{pmatrix}
0\\
|x\rangle
\end{pmatrix} = \begin{pmatrix}
|b\rangle\\
0
\end{pmatrix}\,.
\tag{7.34}
\end{equation}\]</span>
Toliau darome prielaidą, kad <span class="math inline">\(A\)</span> yra ermitinis operatorius, perteikę
spektrine dekompozicija:
<span class="math display" id="eq:spektrine-dekompozicjia-hhl">\[\begin{equation}
A =\sum_{k = 0}^{2^m - 1} \lambda_k |a_k\rangle\langle a_k|\,.
\tag{7.35}
\end{equation}\]</span>
Diados yra sudarytos iš operatoriaus <span class="math inline">\(A\)</span> tikrinių vektorių
<span class="math inline">\(|a_k\rangle,\)</span> asocijuotų su tikrinėmis vertėmis
<span class="math inline">\(\lambda_k\)</span>. Tiesinėje algebroje <span class="math inline">\(A\)</span> yra diagonalioji matrica, kurios
įstrižainės yra tikrinės vertės <span class="math inline">\(\lambda_k\)</span>. Tad jos atvirkštinė
matrica <span class="math inline">\(A^{-1}\)</span> diadų formoje yra tiesiog:
<span class="math display" id="eq:atvirkstine-matrica-diadu-formoje">\[\begin{equation}
A^{-1} =\sum_{k = 0}^{2^m - 1} \frac{1}{\lambda_k}|a_k\rangle\langle a_k|\,.
\tag{7.36}
\end{equation}\]</span>
Tai irgi diagonalioji matrica su įstrižainės vertėmis
<span class="math inline">\(\lambda_k^{-1}\)</span>. Vektorius <span class="math inline">\(|b\rangle\)</span> taip pat gali
būti išreikštas <span class="math inline">\(A\)</span> operatoriaus tikriniais vektoriais
<span class="math inline">\(|a_i\rangle\)</span>:
<span class="math display" id="eq:b-isreikstas-a-tikriniais">\[\begin{equation}
|b\rangle =\sum_{i = 0}^{2^m - 1} b_i|a_i\rangle\,.
\tag{7.37}
\end{equation}\]</span>
Sudėjus šias išraiškas ir pritaikius bazinių vektorių ortogonalumą
<span class="math inline">\(\langle a_k | a_i\rangle =\delta_{k,i}\)</span>,
sprendinys yra ieškomas tokia forma:
<span class="math display" id="eq:sprendinys-a-tikriniais">\[\begin{equation}
|x\rangle =\sum_{k = 0}^{2^m - 1} \lambda_k^{-1} b_k|a_k\rangle\,.
\tag{7.38}
\end{equation}\]</span>
Tad ieškomasis vektorius <span class="math inline">\(|x\rangle\)</span> bus koduojamas kaip
tikrinių vektorių <span class="math inline">\(|a_k\rangle\)</span> amplitudės (žr. 6.4 poskyrį).
Atkreipiame dėmesį, kad būsenų matavimas galiausiai yra
atliekamas Pauli-<span class="math inline">\(Z\)</span> tikrinių vektorių bazėje
{<span class="math inline">\(|0\rangle, |1\rangle\)</span>}, o ne
{<span class="math inline">\(|a_k\rangle\)</span>}. Tačiau galima matematiškai
patikrinti, kad šiuo atveju vis tiek bus gautos teisingos amplitudės, jeigu kubitai nėra
supintieji.</p>
<p>HHL algoritmo pagrindinis tikslas yra perteikti būseną
<span class="math inline">\(|b\rangle\)</span> operatoriaus <span class="math inline">\(A\)</span> tikriniais vektoriais
<span class="math inline">\(|a_k\rangle\)</span> ir nustatyti jo tikrines vertes
<span class="math inline">\(\lambda_k\)</span>. Kadangi <span class="math inline">\(A\)</span> yra ermitinis operatorius, jo eksponentė
nusako unitarinį operatorių, ir todėl galime panaudoti kvantinį fazės
nustatymo algoritmą rasti norimoms vertėms. <strong>Hamiltoniano kodavimo
metodas</strong> (angl. <em>hamiltonian encoding</em>) leidžia simuliuoti matricą <span class="math inline">\(A\)</span>
unitariuoju operatoriumi ir išreikšti loginiais vartais:
<span class="math display" id="eq:a-kaip-unitarusis-op">\[\begin{equation}
U = \mathrm{e}^{\mathrm{i}At}\,.
\tag{7.39}
\end{equation}\]</span>
Kodavimo pavadinime žodis „hamiltonianas” atsiranda dėl to, kad <span class="math inline">\(A\)</span> yra
ermitinis operatorius ir todėl iš principo nusako tam tikros kvantinės
sistemos energijos lygius. Tad iš <span class="math inline">\(A\)</span> suformuotas unitarusis
operatorius <span class="math inline">\(U\)</span> nusako šios sistemos laiko evoliuciją
(žr. <a href="kvantines-mechanikos-pagrindai.html#kvantines-mechanikos-pagrindai">3</a> skyrių),
<a href="furjė-transformacija-ir-jos-taikymai.html#eq:a-kaip-unitarusis-op">(7.39)</a> lygybėje matome laiko kintamąjį <span class="math inline">\(t\)</span>. Pavyzdžiui, mašininio
mokymosi algoritmuose operatorių realizuojanti matrica <span class="math inline">\(A\)</span> gali nusakyti
mokymosi duomenis, o hamiltoniano kodavimas suteikia vieną būdą duomenis
pateikti kvantiniam kompiuteriui. Ermitinio operatoriaus <span class="math inline">\(A\)</span>
matematinė išraiška nusakys, kaip galima realizuoti eksponentę
<span class="math inline">\(\mathrm{e}^{\mathrm{i}At}\)</span>. Tai gali būti itin paprasta diagonalioji matrica, kurią
galima išreikšti be aproksimacijų, arba gali prireikti kitų metodų.
Vieną bendrojo tipo aproksimacijos metodą, vadinamą „troterizacija”,
pristatome <a href="sistemu-modeliavimas-ir-qml.html#sistemu-modeliavimas-ir-qml">8</a> skyriuje.</p>
<p>Tęsiant algoritmo apibūdinimą, išreiškus <span class="math inline">\(U\)</span> spektrine dekompozicija:
<span class="math display" id="eq:u-spektine-dekompozicija-hhl">\[\begin{equation}
\mathrm{e}^{\mathrm{i}At} =\sum_{k = 0}^{2^m - 1}
\mathrm{e}^{\mathrm{i}\lambda_k t}|a_k\rangle\langle a_k|\,.
\tag{7.40}
\end{equation}\]</span></p>
<p>Operatoriaus tikrinės vertės <span class="math inline">\(\mathrm{e}^{\mathrm{i}\lambda_k t}\)</span> yra
asocijuotos su <span class="math inline">\(U\)</span> tikriniais vektoriais
<span class="math inline">\(|a_k\rangle\)</span>, kurie čia taip pat yra ir <span class="math inline">\(A\)</span> tikriniai
vektoriai. Pažvelgus į fazės nustatymo algoritme naudojamus tikrinių
verčių apibrėžimus ir lyginant su šiuo,
<span class="math inline">\(\mathrm{e}^{\mathrm{i}2\pi\theta_k} \rightarrow \mathrm{e}^{\mathrm{i}\lambda_k t}\)</span>,
ermitinio operatoriaus <span class="math inline">\(A\)</span> tikrinė vertė susieta su faze
<span class="math inline">\(\theta_k =\lambda_k t/2\pi\)</span>. Tai yra visi reikalingi matematiniai
įrankiai, naudojami HHL algoritme. Toliau apibūdinsime jo žingsnius,
parodytus kvantinėje grandinėje <a href="furjė-transformacija-ir-jos-taikymai.html#fig:hhl-grandine">7.6</a> pav.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:hhl-grandine"></span>
<img src="media/image7_6.svg" alt="HHL algoritmo realizavimas loginėje grandinėje.  Daroma prielaida, kad būsena $|b\rangle$ jau yra paruošta antrajame registre. Sąlyginiai $m + 1$ kubitų loginiai vartai $cR_y(\theta)$ yra kontroliuojami $m$ kubitais ir keičia adresato ancila kubito būseną. Kartu su parodytomis Furjė transformacijomis ir ancila kubito matavimu ši algoritmo dalis yra kartojama, kol ancila kubitas randamas $|1\rangle$ būsenoje" width="80%" />
<p class="caption">
7.6 pav. HHL algoritmo realizavimas loginėje grandinėje. Daroma prielaida, kad būsena <span class="math inline">\(|b\rangle\)</span> jau yra paruošta antrajame registre. Sąlyginiai <span class="math inline">\(m + 1\)</span> kubitų loginiai vartai <span class="math inline">\(cR_y(\theta)\)</span> yra kontroliuojami <span class="math inline">\(m\)</span> kubitais ir keičia adresato ancila kubito būseną. Kartu su parodytomis Furjė transformacijomis ir ancila kubito matavimu ši algoritmo dalis yra kartojama, kol ancila kubitas randamas <span class="math inline">\(|1\rangle\)</span> būsenoje
</p>
</div>
<p>HHL naudoja tris kubitų registrus. Pirmųjų dviejų registrų funkcijos čia
yra iš esmės tokios pačios, kaip ir fazės nustatymo algoritme. Pirmasis
registras turi <span class="math inline">\(n\)</span> skaičių kubitų, jame užrašomos tikrinės vertės
dvejetaine forma su atitinkamu bitų tikslumu. Antrasis registras turi
<span class="math inline">\(m\)</span> skaičių kubitų, jame įrašoma ir transformuojama būsena
<span class="math inline">\(|b\rangle\)</span>, kurią čia perteikėme tikriniais vektoriais
<span class="math inline">\(|a_k\rangle\)</span>. Antrajame registre ir bus galiausiai
užrašomas sprendinys <span class="math inline">\(|x\rangle\)</span>. Trečiasis registras
yra 1 kubito ancila, kurios paskirtį iliustruosime toliau. Pradinė
normuotoji trijų registrų būsena <span class="math inline">\(|\phi\rangle\)</span> po
būsenos <span class="math inline">\(|b\rangle\)</span> paruošimo yra:
<span class="math display" id="eq:pradine-busena-hhl">\[\begin{equation}
|\phi\rangle =\sum_k b_k|0\rangle\otimes|a_k\rangle\otimes|0\rangle\,.
\tag{7.41}
\end{equation}\]</span>
Tolesniame žingsnyje pritaikome fazės nustatymo algoritmą tarp pirmų
dviejų registrų, kurio visus žingsnius kompaktiškai žymime <span class="math inline">\(U_{\mathrm{FN}}\)</span>.
Randame:
<span class="math display" id="eq:u-fn-hhl">\[\begin{equation}
U_{\mathrm{FN}}|\phi\rangle =
\sum_k b_k|\tilde{\lambda}_k\rangle\otimes|a_k\rangle\otimes|0\rangle\,.
\tag{7.42}
\end{equation}\]</span>
Čia fazė yra koduojama:
<span class="math inline">\(\tilde{\lambda}_k = 2^n \lambda_k t/2\pi\)</span>. Tai leidžia
tiesiogiai susieti <span class="math inline">\(|\tilde{\lambda}_k\rangle\)</span>
būseną su ieškomosiomis tikrinėmis vertėmis <span class="math inline">\(\lambda_k\)</span>. Parametro <span class="math inline">\(t\)</span>
dydis yra pasirenkamas pagal <span class="math inline">\(U\)</span> realizavimo metodą, siekiant sumažinti
<span class="math inline">\(U\)</span> atlikimo klaidas ir nepadaryti algoritmo ilgo loginių vartų
atžvilgiu. Šioje stadijoje norima atlikti pirmojo registro
transformaciją:
<span class="math inline">\(|\tilde{\lambda}_k\rangle \rightarrow C\lambda_k^{-1}|\tilde{\lambda}_k\rangle\)</span>;
čia <span class="math inline">\(C\)</span> yra konstanta, reikalinga užtikrinti būsenų normavimui, ir ji
turėtų būti mažesnė nei mažiausia tikrinė
vertė, <span class="math inline">\(|C| &lt;\lambda_{\min}\)</span>. Tam pasitelkiamas ancila kubitas, kuriam
atliekami sąlyginiai loginiai vartai <span class="math inline">\(cR_y(\theta)\)</span>, kontroliuojami
pirmojo registro <span class="math inline">\(|\tilde{\lambda}_k\rangle\)</span>
būsenomis, su atitinkamai pasirinktu <span class="math inline">\(\theta\)</span>:
<span class="math display" id="eq:cr-y-theta-hhl">\[\begin{equation}
cR_y(\theta)U_{\mathrm{FN}}|\phi\rangle =
\sum_k b_k|\tilde{\lambda}_k\rangle\otimes|a_k\rangle\otimes
\left\lbrack\sqrt{1 - (C\lambda_k^{-1})^2}|0\rangle + C\lambda_k^{-1}|1\rangle\right\rbrack\,.
\tag{7.43}
\end{equation}\]</span>
Matome, kad jeigu išmatuotume ancila kubitą, radus jo būseną esant
<span class="math inline">\(|1\rangle\)</span> bendrai būsenai bus perteikta amplitudė
<span class="math inline">\(C\lambda_k^{-1}\)</span>. Atkreipiame dėmesį, kad pirmi du registrai yra
supintieji, tad norint perteikti teisingas amplitudes antrajam registrui
reikia panaikinti supynimą. Paskutiniame žingsnyje pritaikome
atvirkštinę fazės nustatymo rutiną, <span class="math inline">\(U_{\mathrm{FN}}^{\dagger}\)</span>, grąžindami
pirmąjį registrą į pradinę būseną ir panaikindami supynimą tarp pirmų
dviejų registrų. Ignoruodami potencialius netikslumus, kylančius iš
<span class="math inline">\(U_{\mathrm{FN}}\)</span> ir <span class="math inline">\(U_{\mathrm{FN}}^{\dagger}\)</span>, randame:
<span class="math display" id="eq:u-fn-atvirkstine-hhl">\[\begin{equation}
U_{\mathrm{FN}}^{\dagger} cR_y(\theta)U_{\mathrm{FN}}|\phi\rangle =
\sum_k b_k|0\rangle\otimes|a_k\rangle\otimes
\left\lbrack\sqrt{1 - (C\lambda_k^{-1})^2}|0\rangle + C\lambda_k^{-1}|1\rangle\right\rbrack\,.
\tag{7.44}
\end{equation}\]</span>
Šioje stadijoje atliekame ancila kubito matavimą. Radus jo būseną esant
<span class="math inline">\(|1\rangle\)</span>, sprendinys <span class="math inline">\(|x\rangle\)</span>
matomas antrajame registre:
<span class="math display" id="eq:sprendinys-hhl">\[\begin{equation}
|0\rangle\otimes|x\rangle\otimes|1\rangle
= \frac{1}{\sqrt{N}}\sum_k |0\rangle\otimes b_k \lambda_k^{-1}|a_k\rangle\otimes|1\rangle\,.
\tag{7.45}
\end{equation}\]</span>
Su būsenos normavimo koeficientu <span class="math inline">\(N\)</span>:
<span class="math display" id="eq:normavimas-hhl">\[\begin{equation}
N =\sum_k |b_k \lambda_k^{-1}|^2\,.
\tag{7.46}
\end{equation}\]</span>
Radus ancila kubitą <span class="math inline">\(|0\rangle\)</span> būsenoje tektų kartoti
žingsnius iš naujo, tai prisideda prie algoritmo laiko sudėtingumo.
Kadangi taikomas amplitudžių kodavimas, atsakymo
<span class="math inline">\(|x\rangle\)</span> tiesiogiai nuskaityti nepavyks. Vis dėlto
dažnai yra svarbiau sužinoti ne patį atsakymą, bet jo tam tikras
savybes, vidutines vertes, momentus, santykinę būsenos orientaciją
sprendinių erdvėje. Pasitelkdami Hadamardo testą (<a href="skaičiavimai-kvantiniu-kompiuteriu.html#hadamard-testas-poskyris">6.7.1</a> poskyrį) galime apskaičiuoti sprendinio
funkciją <span class="math inline">\(f(x) =\langle x|M|x\rangle\)</span>,
realizuojant ją atitinkamai suformuluotu kvantiniu operatoriumi <span class="math inline">\(M\)</span>.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="skaičiavimai-kvantiniu-kompiuteriu.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="sistemu-modeliavimas-ir-qml.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/JuliusRuseckas/quantum_book/edit/main/07-skyrius.Rmd",
"text": "Siūlyti turinį"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["kvantinekompiuterija.pdf", "kvantinekompiuterija.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
